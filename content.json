{"meta":{"title":"LeBron_Six 的博客","subtitle":null,"description":"欢迎访问我的博客~","author":"LeBron_Six","url":"http://smuyyh.top","root":"/"},"pages":[{"title":"","date":"24/02/2021","updated":"02/07/2020","comments":true,"path":"baidu_verify_Kw5JTvyvQv.html","permalink":"http://smuyyh.top/baidu_verify_Kw5JTvyvQv.html","excerpt":"","text":"Kw5JTvyvQv"},{"title":"文章分类","date":"03/09/2017","updated":"13/10/2022","comments":true,"path":"categories/index.html","permalink":"http://smuyyh.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"22/12/2014","updated":"13/10/2022","comments":true,"path":"tags/index.html","permalink":"http://smuyyh.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"多个大文件数据排序去重的解题思路","slug":"file-sort","date":"25/10/2023","updated":"30/10/2023","comments":true,"path":"2023/10/25/file-sort/","link":"","permalink":"http://smuyyh.top/2023/10/25/file-sort/","excerpt":"问题假设有四个文件，每个文件 1GB，文件里的每一行存储一个随机的 int正整数 (0 &lt;&#x3D; v &lt; 2^32)，单文件最多 1亿行。要求对这四个文件进行排序去重，输出一个有序的文件。 假设服务器规格 8核16GB内存，希望执行时间尽可能短。 在上述的前提条件下，如果排序完之后，还希望输出每个数字出现的次数呢？ 文件读写效率在 Java 下，文件的 io 方式分为 字节流 和 字符流，字符流又分为 字符输入流 和 字符输出流。字节流和字符流的区别在于，字节流是以字节为单位读写文件，字符流是以字符为单位读写文件。 字符流的好处是可以指定编码，比如 UTF-8，GBK 等，而字节流只能使用默认的编码。 对于该题目，相比之下，字符流更适合，因为我们只需要读取每一行，然后转换成 int，不需要考虑编码的问题。所以后文会有很多BufferReader 和 BufferWriter 相关的代码，这里就不再赘述。 常规思路假设要对所有的数字读取出来进行排序，全部读取出来其实内存里也能放得下。4个文件400000000行，int值占4个字节，理论上只需要 1.6G 的空间，但是做快排时，递归深度太深容易栈溢出。如果数据量更大，或者内存更小，比较理想的方案是外部排序法。 那么我们可以考虑分治的思想，将一个大文件分成多个小文件，每个小文件放到内存里排序，然后再将这些小文件合并成一个大文件。这样就可以解决内存放不下的问题。","text":"问题假设有四个文件，每个文件 1GB，文件里的每一行存储一个随机的 int正整数 (0 &lt;&#x3D; v &lt; 2^32)，单文件最多 1亿行。要求对这四个文件进行排序去重，输出一个有序的文件。 假设服务器规格 8核16GB内存，希望执行时间尽可能短。 在上述的前提条件下，如果排序完之后，还希望输出每个数字出现的次数呢？ 文件读写效率在 Java 下，文件的 io 方式分为 字节流 和 字符流，字符流又分为 字符输入流 和 字符输出流。字节流和字符流的区别在于，字节流是以字节为单位读写文件，字符流是以字符为单位读写文件。 字符流的好处是可以指定编码，比如 UTF-8，GBK 等，而字节流只能使用默认的编码。 对于该题目，相比之下，字符流更适合，因为我们只需要读取每一行，然后转换成 int，不需要考虑编码的问题。所以后文会有很多BufferReader 和 BufferWriter 相关的代码，这里就不再赘述。 常规思路假设要对所有的数字读取出来进行排序，全部读取出来其实内存里也能放得下。4个文件400000000行，int值占4个字节，理论上只需要 1.6G 的空间，但是做快排时，递归深度太深容易栈溢出。如果数据量更大，或者内存更小，比较理想的方案是外部排序法。 那么我们可以考虑分治的思想，将一个大文件分成多个小文件，每个小文件放到内存里排序，然后再将这些小文件合并成一个大文件。这样就可以解决内存放不下的问题。 1、分割文件、子文件排序完后写入临时文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * 每个小文件的行数 */private static final int CHUNK_SIZE = 2500000;/** * 每个大文件拆成的小文件个数 */private static final int SPLIT_COUNT = 40;/** * 总的小文件个数 */private static final int TOTAL_CHUNK_COUNT = FILE_PATHS.length * SPLIT_COUNT;private static final ExecutorService POOL = Executors.newFixedThreadPool(16); private static void splitFiles() &#123; CountDownLatch latch = new CountDownLatch(TOTAL_CHUNK_COUNT); AtomicInteger count = new AtomicInteger(0); for (String filePath : FILE_PATHS) &#123; // 多线程读文件 POOL.submit(new Runnable() &#123; @Override public void run() &#123; splitSingleFile(filePath, new SplitCallback() &#123; @Override public void onSplit(List&lt;Integer&gt; lines) &#123; POOL.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; int index = count.incrementAndGet(); sortChunk(lines, index); writeChunk(lines, index); &#125; catch (IOException ignored) &#123; &#125; finally &#123; latch.countDown(); &#125; &#125; &#125;); &#125; &#125;); &#125; &#125;); &#125; try &#123; latch.await(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; service.shutdown();&#125;/** * 大文件切割成若干个小文件 */private static void splitSingleFile(String filePath, SplitCallback callback) &#123; List&lt;Integer&gt; lines = new ArrayList&lt;&gt;(CHUNK_SIZE); try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) &#123; String line; while ((line = reader.readLine()) != null) &#123; lines.add(StringUtils.stringToInt(line)); if (lines.size() &gt;= CHUNK_SIZE) &#123; List&lt;Integer&gt; originLines = lines; callback.onSplit(originLines); lines = new ArrayList&lt;&gt;(CHUNK_SIZE); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (!lines.isEmpty()) &#123; callback.onSplit(lines); &#125; if (DEBUG) &#123; log(&quot;split file &quot; + filePath + &quot; end&quot;); &#125;&#125;/** * 对每个小文件进行排序 */private static void sortChunk(List&lt;Integer&gt; lines, int index) throws IOException &#123; // Collections.sort(lines); // 归并 CollectionUtils.quickSort(lines); // 快排 if (DEBUG) &#123; log(&quot;sort chunk &quot; + index + &quot; end&quot;); &#125;&#125;/** * 将排序后的内容写入临时文件 */private static void writeChunk(List&lt;Integer&gt; lines, int index) throws IOException &#123; String tempFileName = &quot;temp_&quot; + index + &quot;.txt&quot;; try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFileName))) &#123; for (Integer line : lines) &#123; writer.write(Integer.toString(line)); writer.newLine(); &#125; &#125; if (DEBUG) &#123; log(&quot;write chunk &quot; + index + &quot; end&quot;); &#125;&#125; 2、合并临时文件，通过优先队列不断地从临时文件里的每一行取出最小的，然后写入最终的输出文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static void mergeSortFiles() throws IOException &#123; File[] tempFiles = new File[TOTAL_CHUNK_COUNT]; for (int i = 0; i &lt; TOTAL_CHUNK_COUNT; i++) &#123; tempFiles[i] = new File(&quot;temp_&quot; + (i + 1) + &quot;.txt&quot;); &#125; // 使用优先队列进行合并排序 PriorityQueue&lt;Pair&gt; pq = new PriorityQueue&lt;&gt;(tempFiles.length, Comparator.comparing(Function.identity(), Main::compareLines)); // 将每个临时文件的第一行添加到优先队列中 for (File tempFile : tempFiles) &#123; BufferedReader br = new BufferedReader(new FileReader(tempFile)); pq.offer(new Pair(br, StringUtils.stringToInt(br.readLine()))); &#125; // 合并排序后的结果输出到文件 int current = pollAndOffer(pq); int count = 1; try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_PATH))) &#123; while (!pq.isEmpty()) &#123; int line = pollAndOffer(pq); if (current != line) &#123; writer.write(current + &quot;:&quot; + count + &quot;\\n&quot;); current = line; count = 1; &#125; else &#123; count++; &#125; &#125; writer.write(current + &quot;:&quot; + count + &quot;\\n&quot;); writer.flush(); &#125; if (DEBUG) &#123; log(&quot;merge temp file end&quot;); &#125; // 删除临时文件 for (File tempFile : tempFiles) &#123; tempFile.delete(); &#125;&#125;private static int pollAndOffer(PriorityQueue&lt;Pair&gt; pq) throws IOException &#123; Pair pair = pq.poll(); int value = pair.value; String nextLine = pair.br.readLine(); if (nextLine != null &amp;&amp; nextLine.length() &gt; 0) &#123; pair.value = StringUtils.stringToInt(nextLine); pq.offer(pair); &#125; else &#123; pair.br.close(); &#125; return value;&#125;private static int compareLines(Pair br1, Pair br2) &#123; return (br1.value &lt; br2.value) ? -1 : ((br1.value == br2.value) ? 0 : 1);&#125; 位图思路仔细理解一下题目要求，我们只需要对这四个文件进行排序去重，输出一个有序的文件。我们并不需要知道每个数字出现的次数，只需要知道这个数字是否出现过。那么我们可以使用位图的思想，将每个数字映射到一个bit位上，如果这个数字出现过，那么这个bit位就是1，否则就是0。这样我们就可以用一个bit位来表示一个数字是否出现过，而不需要用一个int来表示一个数字出现的次数。 最后按顺序遍历每一位，如果 bit位是1，就输出对应的数字。 那么在读文件这步就可以优化为以下代码： 12345678910111213141516int[] list = new int[2000000000 / 32 + 1];CountDownLatch latch = new CountDownLatch(filePaths.length * multiple);for (String filePath : filePaths) &#123; try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) &#123; String line; while ((line = reader.readLine()) != null) &#123; int value = stringToInt(line); int index = value &gt;&gt; 5; int mod = value &amp; 31; // 取模，相当于 value % 32 list[index] |= 1 &lt;&lt; mod; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 输出文件： 12345678910try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath))) &#123; for (int i = 0; i &lt; list.length; i++) &#123; for (int j = 0; j &lt; 32; j++) &#123; if ((list[i] &amp; (1 &lt;&lt; j)) != 0) &#123; writer.write(Integer.toString((i &lt;&lt; 5) + j)); writer.newLine(); &#125; &#125; &#125;&#125; 位图的效率，比常规排序的思想，速度快了非常多。 位图并发冲突问题使用位图时，如果多个线程同时对同一个bit位进行写操作，就会出现并发冲突问题。比如线程A和线程B同时对不同bit位进行写1操作，这个是非原子操作，可能会出现线程A写完后，线程B写完后，线程A写的1被覆盖的情况。 借鉴 CAS 的思想，我们可以使用 AtomicIntegerArray 来解决这个问题。 或者借鉴 ConcurrentHashMap 的思想，使用分段锁来解决这个问题。例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 计数分段锁，锁的个数越大，理论上在并发时锁被占用的几率越小 */private static final Object[] LOCKS = new Object[0x1000];for (int i = 0; i &lt; LOCKS.length; i++) &#123; LOCKS[i] = new Object();&#125;private static void splitFiles() throws Exception &#123; int[] list = new int[2000000000 / 32 + 1]; CountDownLatch latch = new CountDownLatch(FILE_PATHS.length * SEGMENT_COUNT); for (String filePath : FILE_PATHS) &#123; POOL.submit(new Runnable() &#123; @Override public void run() &#123; try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) &#123; String line; while ((line = reader.readLine()) != null) &#123; int value = StringUtils.stringToInt(line); int index = value &gt;&gt; 5; int mod = value &amp; 31; // 取模，相当于 value % 32 // 分段锁 synchronized (LOCKS[index &amp; 0xFFF]) &#123; list[index] |= 1 &lt;&lt; mod; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; latch.countDown(); &#125; &#125; &#125;); &#125; try &#123; latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 并发读单个文件首先要解决的问题是，如何并发读单个文件，首先想到的是可以使用 RandomAccessFile 来解决这个问题，但实际上 RandomAccessFile的效率极其低下，如果我们还在 BufferReader 的基础上，可以通过 skip() 方法来跳到指定的位置。从而实现分段并发读单个文件。 1234567891011121314151617181920212223242526272829303132long startPos = file.length() / 2; // 假设分为两段，第二段从文件中间开始读long endPos = file.length();long readLength = 0; // 已读取的长度long segmentLength = endPos - startPos; // 第二段的长度try (BufferedReader reader = new BufferedReader(new FileReader(file))) &#123; if (startPos &gt; 0) &#123; // 跳到指定位置 reader.skip(startPos - 1); char[] chars = new char[1]; reader.read(chars); if (chars[0] != &#x27;\\n&#x27;) &#123; // 如果指针可能在行中间，跳过这个不完整的行。跳过的这行其实会被上一段读取 String line = reader.readLine(); if (line != null) &#123; segmentLength -= line.length() + 1; &#125; &#125; String line; while ((line = reader.readLine()) != null) &#123; readLength += line.length() + 1; if (readLength &gt;= segmentLength) &#123; break; &#125; &#125; &#125; ...&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 实际上 reader.skip() 是有比较大的性能损耗的，因为它是通过不断地跳过字符来实现的。探索了源码发现可以从 BufferReader 构造方法传入的 FileReader 入手。BufferReader 本身并不感知当前读取到的具体位置，而是通过 FileReader 的 FileInputSteam 来实现的。所以我们可以通过反射来获取到 FileInputSteam 的实例，然后调用它的 skip() 方法来实现跳过指定的位置。 123456789101112131415FileReader fileReader = new FileReader(file);FileInputStream inputStream = null;try &#123; Class&lt;?&gt; readerClass = Reader.class; Field field = readerClass.getDeclaredField(&quot;lock&quot;); field.setAccessible(true); is = (FileInputStream)field.get(fileReader); BufferedReader reader = new BufferedReader(fileReader) // 跳到指定位置 is.skip(startPos - 1);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 并发写文件由于要求写入的是有序的，那么多线程写入要如何保证有序呢？我们可以多线程，每个线程负责把一段区间内的数字有序写到文件，然后按顺序合并临时文件。这样就可以保证有序了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/** * 输出到文件，先并发写入多个临时文件，再合并 */private static void output() &#123; int multiple = 4; // 分段数 List&lt;File&gt; tempFiles = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; multiple; i++) &#123; File file = new File(&quot;temp&quot; + i + &quot;.txt&quot;); tempFiles.add(file); &#125; CountDownLatch latch = new CountDownLatch(multiple); // 批量写入字节长度 int maxLength = 2520; int maxIndex = maxLength - 20; char lineBreak = &#x27;\\n&#x27;; char colon = &#x27;:&#x27;; // 多线程分批写文件 for (int i = 0; i &lt; multiple; i++) &#123; int fileIndex = i; POOL.submit(new Runnable() &#123; @Override public void run() &#123; WriteRunnable runnable = null; // 这里有个细节，第一个文件可以直接写到输出文件，后面的文件先写到临时文件，合并的时候就可以少合并一个文件 File file = fileIndex == 0 ? new File(OUTPUT_PATH) : tempFiles.get(fileIndex); try (BufferedWriter writer = new BufferedWriter(new FileWriter(file), 128 * 1024)) &#123; // 生产者-消费者 模式 runnable = new WriteRunnable(writer); POOL.submit(runnable); int index = 0; char[] charArray = new char[maxLength]; int startPos = (int)((long)fileIndex * BIT_ARRAY.length / multiple); int endPos = (int)(((long)fileIndex + 1) * BIT_ARRAY.length / multiple); for (int i = startPos; i &lt; endPos; i++) &#123; if (BIT_ARRAY[i] != 0) &#123; if (index &gt; maxIndex) &#123; char[] res = copyOfRange(charArray, 0, index); // 添加到队列 runnable.queue.offer(res); index = 0; &#125; // 填充数字 index += StringUtils.stringSize(i); StringUtils.getChars(i, index, charArray); // 换行 charArray[index++] = lineBreak; &#125; &#125; if (index &gt; 0) &#123; char[] res = copyOfRange(charArray, 0, index); runnable.queue.offer(res); &#125; while (runnable.queue.size() &gt; 0) &#123; Thread.yield(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; latch.countDown(); if (runnable != null) &#123; runnable.run = false; &#125; &#125; &#125; &#125;); &#125; try &#123; latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; combineFiles(tempFiles, 1, multiple); for (File file : tempFiles) &#123; file.delete(); &#125;&#125;/** * 合并多个文件 */private static void combineFiles(List&lt;File&gt; tempFiles, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; StringBuilder sb = new StringBuilder(); for (int i = start; i &lt; end; i++) &#123; sb.append(tempFiles.get(i).getAbsolutePath()).append(&quot; &quot;); &#125; try &#123; List&lt;String&gt; command = new ArrayList&lt;&gt;(); command.add(&quot;/bin/sh&quot;); command.add(&quot;-c&quot;); command.add(&quot;cat &quot; + sb + &quot; &gt;&gt; &quot; + OUTPUT_PATH); // 合并文件 ProcessBuilder processBuilder = new ProcessBuilder(command); Process process = processBuilder.start(); process.waitFor(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;static class MyRunnable implements Runnable &#123; BufferedWriter writer; Queue&lt;char[]&gt; queue = new ConcurrentLinkedQueue&lt;&gt;(); boolean run = true; public MyRunnable(BufferedWriter writer) &#123; this.writer = writer; &#125; @Override public void run() &#123; try &#123; while (run) &#123; char[] str = queue.poll(); if (str != null) &#123; writer.write(str); &#125; &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 上面取巧通过 cat 指令来合并文件，效率比 nio 高一些。也可以通过 nio 的方式来合并文件。 12345678910111213141516171819202122232425public static void mergeFiles(List&lt;String&gt; fileNames, String outputFileName) &#123; try &#123; FileOutputStream outputStream = new FileOutputStream(outputFileName); FileChannel outputChannel = outputStream.getChannel(); for (String fileName : fileNames) &#123; Path path = Paths.get(fileName); FileChannel inputChannel = FileChannel.open(path); ByteBuffer buffer = ByteBuffer.allocate(1024); while (inputChannel.read(buffer) &gt; 0) &#123; buffer.flip(); outputChannel.write(buffer); buffer.clear(); &#125; inputChannel.close(); &#125; outputChannel.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 细致优化思路parseInt() 方法的优化String.parseInt() 方法里做了很多边界检查，在海量数据的循环里面，这一步的耗时也不容忽视。由于我们知道输入的数字都是正整数，所以可以做一些优化。 123456789101112public static int stringToInt(String str) &#123; int num = 0; int i = 0; int len = str.length(); while (i &lt; len) &#123; num = num * 10 + str.charAt(i) - &#x27;0&#x27;; i++; &#125; return num;&#125; 避免重复的字符串和数字之间的转换例如写入的时候，直接放在 char[] 数组里，而不是先转换成字符串，BufferWriter write 的时候又会再转换成 char[] 数组。虽然字符串里面也是 char[] 数组，但是会有一些额外的开销。 多线程并发均匀分布由于文字是有序的，如果我们简单的按写入行数分割，会发现前面的线程因为写入的数字都比较小，写入明显要比后面的线程快，所以我们可以调整参数，让前面的线程写入的行数多一些，尽可能让每个线程的写入时间均匀分布，减少等待时间，例如： 1234567891011121314151617for (int i = 0; i &lt; SEGMENT_COUNT; i++) &#123; int startPos = (int)(getReadSegmentPosition(i - 1, SEGMENT_COUNT) * totalLength); int endPos = (int)(getReadSegmentPosition(i, SEGMENT_COUNT) * totalLength); ...&#125;// 调整参数，让每个线程写入的数据量分布更均匀private static int[] writeRatios = new int[] &#123;50, 99, 148, 195, 241, 286, 330, 373&#125;;// 获取第 index 个线程读取的结束位置private static float getWriteSegmentPosition(int index, int length) &#123; if (index &lt; 0) &#123; return 0; &#125; return (float)writeRatios[index % length] / writeRatios[writeRatios.length - 1];&#125; 虽然多线程的调度并不可能每次都均匀，但是相比之前的效率提升还是非常明显的。 并发量控制虽然8核理论上可以同时执行8个线程，但实际上每个线程的执行过程中，可能会有一些 io 等待时间，所以并发数要大于8才能达到充分利用，例如并发数16，但也不能过度提升并发数，过度反而会降低效率，因为线程的切换也是需要时间的。所以在并发量上需要根据服务器具体性能做一些调整。 JVM 参数调优JVM 参数也会影响效率，例如 -Xms -Xmx -Xmn -XX:SurvivorRatio -XX:NewRatio 等参数，可以根据服务器的具体情况做一些调整。 例如我们可以预估程序跑的时候大概需要多大的堆空间，把 -Xms 设为该数值，降低频繁GC的概率，或者 -Xms 和 -Xmx 设为相同的值，避免程序运行时扩容、缩容堆空间。 在该题目的背景下，如果能降低 GC 带来的影响是比较理想的，因为内存空间足够，我们不需要太快回收垃圾，可以把垃圾回收器设置为串行回收器，降低一些影响。 进一步优化 在 io 读写方式不变的情况下，上述思路比较难有突破的空间了。Java 中 io 方式大概可以被分为三种：普通 IO(字节流、字符流)，FileChannel(文件通道)，mmap(内存映射)。 FileWriter,FileReader 存在于 java.io 包中，FileChannel 存在于 java.nio 包中，FileChannel 是 NIO 里面的一种，它的底层是通过操作系统的文件通道来实现的，它的效率比普通 IO 高很多，但是它的效率还是比不上 mmap。 由于系统内存足够，4个1G的文件可以直接全部映射到内存里，这样就可以直接操作内存，而不需要通过系统调用来操作文件。 123456789101112MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());int totalLength = buffer.limit();int currentNumber = 0;for (int totalIndex=0; totalIndex &lt; totalLength; totalIndex++) &#123; byte b = buffer.get(totalIndex); if (b == &#x27;\\n&#x27;) &#123; // 记录数字 currentNumber = 0; &#125; else &#123; currentNumber = curNum * 10 + (b - &#x27;0&#x27;); &#125;&#125; 打印重复数量开头提到，在排好序之后，如果还希望输出每个数字出现的次数，那么位图就不行了，因为它只能记录 0和1。系统内存足够的情况下，最多 20亿个数字，我们可以直接创建一个 20亿长度的 byte数组来存储，约暂用2个G的内存，byte 最大可以存储到 127，因为数字是完全随机的，理论上重复数超过 127 的可能性很小。 假设真的重复数超过 127 怎么办？ 1、可以使用 short 数组，short 最大可以存储到 32767，但是这样会占用 4G 的内存。 2、我们可以另起一个 HashMap，key 是数字，value 是出现的次数，当超过 127 时，剩下的数量记录在 HashMap 里面，这样就可以解决重复数超过 127 的问题。","categories":[{"name":"Java","slug":"Java","permalink":"http://smuyyh.top/categories/Java/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://smuyyh.top/tags/%E6%8E%92%E5%BA%8F/"},{"name":"io","slug":"io","permalink":"http://smuyyh.top/tags/io/"}]},{"title":"终端 Terminal 的一些实现细节分享","slug":"terminal-info","date":"02/08/2023","updated":"30/10/2023","comments":true,"path":"2023/08/02/terminal-info/","link":"","permalink":"http://smuyyh.top/2023/08/02/terminal-info/","excerpt":"在日常开发中，相信很多小伙伴好奇过以下一些问题，尤其是经常使用命令行工具的… 为什么 AndroidStudio&#x2F;IDEA 能打印各种颜色的日志 各种 CLI 在执行时，底下的进度条是怎么实现的 Vim 在 Terminal 中是如何做到清屏和恢复屏幕的 StartAgent 运维平台的 Web Terminal 是怎么做到跟 Terminal 类似的 SpringBoot 启动 Logo 是怎么打印出来的 最近在建设云真机平台时，为了便于对 宿主机服务器 &amp; Android设备 的控制，增加了Web Terminal 的功能，通过终端指令控制设备，包含 Web SSH、Android 远程 Shell等，实现过程还蛮有趣的，所以也重新整理了一下 Terminal 的一些细节原理。","text":"在日常开发中，相信很多小伙伴好奇过以下一些问题，尤其是经常使用命令行工具的… 为什么 AndroidStudio&#x2F;IDEA 能打印各种颜色的日志 各种 CLI 在执行时，底下的进度条是怎么实现的 Vim 在 Terminal 中是如何做到清屏和恢复屏幕的 StartAgent 运维平台的 Web Terminal 是怎么做到跟 Terminal 类似的 SpringBoot 启动 Logo 是怎么打印出来的 最近在建设云真机平台时，为了便于对 宿主机服务器 &amp; Android设备 的控制，增加了Web Terminal 的功能，通过终端指令控制设备，包含 Web SSH、Android 远程 Shell等，实现过程还蛮有趣的，所以也重新整理了一下 Terminal 的一些细节原理。 终端（Terminal）通常来讲，操作系统分为两部分，内核 和 用户交互界面。 内核支持各种命令，负责操作系统底层复杂的操作 用户交互界面展示在屏幕的交互界面，例如各种应用程序窗口 终端负责输入输出，为内核和用户交互界面搭桥，我们通常说的终端（Terminal），是指处理终端指令的应用程序，比如 Mac的Terminal、Windows的cmd.exe，实际上是终端命令行界面，在图形界面普及之前使用最广泛，通常不支持鼠标操作，用户通过键盘输入指令，Shell翻译并交给系统执行。正因为通过终端，可以轻易的和内核通信，即便Linux系统无图形界面，也不妨碍它成为优秀的操作系统。 ShellShell常常运行在终端中，是操作系统内核和用户交互的接口程序，可以理解为命令行解释器。例如 Bash、Zsh 都属于 Shell。Linux、Mac早期版本自带的 Shell 就是 bash，正常情况下 Terminal 输入的指令，是交给 bash 执行。 那为什么 Terminal 可以执行 ll 指令，但是 bash 却执行不了呢？原因是 ll 并不是一个标准的 bash 指令，而是 Terminal 在 bash 之上做的扩展，定义了一个别名（alias），实际上相当于执行 ls -l ，所以我们也可以在 bash 里定义一个别名。 macOS 从 Catalina 版开始，使用 Zsh 作为默认 Shell，Zsh 比 bash 有更好的交互体验和兼容性，比如从上图也可以看出来，Zsh 可以设置丰富多彩的颜色。 控制字符&amp;转义序列控制字符在 ASCII 码表中，前32个字符编码是不能用于打印的，而是用于控制终端行为，这些字符被称为控制字符。如下所示： 例如我们常用的控制字符有： 1234\\n（换行）：将光标移动到下一行的开头。\\r（回车）：将光标移动到当前行的开头。\\b（退格）：将光标向后移动一个字符。\\t（制表符）：将光标向右移动到下一个制表符位置。 从图上可以看出，例如Tab 键的 ASCII 码为 9 ，可以用 \\t 表示；Enter键的 ASCII 码为 10，可以用 \\n 表示。 转义字符转义字符是以反斜杠（\\）开头的字符序列，它们表示一些特殊的字符。转义字符可以用于在字符串中插入一些特殊的字符，例如引号或换行符。 以下是一些常见的转义字符及其作用： 12345\\&#x27;（单引号）：用于在字符串中插入一个单引号。&quot;\\（双引号）：用于在字符串中插入一个双引号。\\\\（反斜杠）：用于在字符串中插入一个反斜杠。\\n（换行）：用于表示一个换行符。\\t（制表符）：用于表示一个制表符。 ANSI 转义序列ANSI 转义序列是由 ESC （ASCII 码表中的 27）开头的一些字符序列，用于表示一些特殊的字符或控制序列。转义序列通常用于在终端中显示一些特殊的效果，例如颜色、光标位置等。 转义序列通常以 \\033[……m 开头，以 \\033[0m 结尾。 例如我们通过 Python 打印一些内容： 1print(&quot;\\033[31;1;4mHello\\033[0m&quot;) 或者通过 Java 在控制台打印一些内容： 12System.out.println(&quot;\\u001b[30mHello\\u001b[0m&quot;);System.out.println(&quot;\\u001b[31;1;4mHello\\u001b[0m&quot;) 或者通过 JS 在浏览器控制台里打印一些内容： 12console.log(&quot;\\u001b[91mHello\\u001b[0m&quot;)console.log(&quot;\\u001b[96;1;3mHello\\u001b[0m&quot;) 或者直接在终端通过 Shell 脚本打印： 12echo &quot;\\u001b[91mHello\\u001b[0m&quot; echo &quot;\\u001b[96;1;3mHello\\u001b[0m&quot; 样式说明\\033、\\x1b、\\u001b 三种是一样的，分别代表 8进制、16进制、unicode 16进制 的 27，也就是对应上面提到的 ESC 的 ASCII 码。 左边部分的31代表红色 1代表粗体 4代表下划线 右边部分的0代表清空第一部分的所有效果，如果不清空，则样式会一直延续，如下所示： 当然也可为文字添加背景色，有以下两种形式： 123\\u001b[前景色代码;背景色代码m\\u001b[前景色代码m\\u001b[背景色代码m 例如： 123456# \\u001b[黑字；绿底mprint(&quot;\\u001b[37m\\u001b[42mHello\\u001b[0m&quot;)# \\u001b[黑字；灰底mprint(&quot;\\u001b[30;47mHello\\u001b[0m&quot;)# \\u001b[黑字；灰底；加粗；下划线mprint(&quot;\\u001b[30;47;1;4mHello\\u001b[0m&quot;) 效果如下所示： 3&#x2F;4位颜色表示法起初ANSI只支持3位表示法，也就是只有 2^3&#x3D;8 种。 07：设置字体3037：设置前景色40~47：设置背景色 后来为了实现更明亮的字体，扩展到4位，有 2^4&#x3D;16 种。 07：设置字体3037 9097：设置前景色4047 100~107：设置背景色 1234print(&quot;\\u001b[91mHello\\u001b[0m&quot;)print(&quot;\\u001b[96mHello\\u001b[0m&quot;)# \\u001b[亮青字；亮黄底mprint(&quot;\\u001b[96m\\u001b[103mHello\\u001b[0m&quot;) 每一种终端对颜色代码的实现效果上有一些差异。颜色代码对照表如下所示： 8位颜色表示法随着显卡支持256色查找表，相应的转义序列也增加到 2^8&#x3D;256 种。 015: 标准颜色 &amp; 高强度色16231: 216种 RGB 颜色232~255： 24种灰度色 123print(&quot;\\u001b[48;5;177mHello\\u001b[0m&quot;)print(&quot;\\u001b[38;5;177mHello\\u001b[0m&quot;)print(&quot;\\u001b[38;5;177m\\u001b[48;5;159mHello\\u001b[0m&quot;) 8位颜色对照表如下所示： 24位颜色表示法后来”真彩色“显卡普及，支持24位颜色，转义序列也增加到 2^24&#x3D;16777216 种，也就是我们常用的 RGB 颜色。但是 Mac 的终端目前不支持，浏览器控制台支持。 123console.log(&quot;\\u001b[38;2;255;0;0mHello\\u001b[0m&quot;)console.log(&quot;\\u001b[38;2;255;0;0;1;3mHello\\u001b[0m&quot;)console.log(&quot;\\u001b[38;2;255;255;0;1;3m\\u001b[48;2;0;0;255mHello\\u001b[0m&quot;) 光标移动前面提到 ANSI 转义序列，只是控制了颜色，实际上转义序列还有其他许多能力，例如光标移动，转义序列如下： 上: \\u001b[{n}A 下: \\u001b[{n}B 右: \\u001b[{n}C 左: \\u001b[{n}D 注：{n} 表示移动n个字符 通常来讲，我们打印内容时如果不做特殊处理，光标会自动移动到最后，例如： 那如果想在打印进入的时候，不断刷新前面的进度数字呢？那就需要依靠光标移动，例如： 123456789101112import time, sysdef loading(): print(&quot;Loading...&quot;) for i in range(0, 100): time.sleep(0.05) sys.stdout.write(u&quot;\\u001b[1000D&quot; + str(100-i + 1) + &quot;%&quot;) sys.stdout.flush() print(&quot;\\nDone!&quot;)loading() 打印 1%~100% 进度的时候，通过 sys.stdout.write 标准输出，打印在同一行，在每次打印进度之前，通过 \\u001b[1000D 指令，把光标移动到行首，之后打印的值会覆盖前面的。但这里有其实个细节，比如光标移动到行首并打印3个字符，就只会覆盖前三个字符，假设原来这一行里面有4个字符，那么第4个字符就不会被清除。不过这里 1-100 刚好是字符数越变越大，所以也没问题。 进度条光展示数字显然不够骚气，平时各种 CLI 命令行的进度条是怎么实现的呢？ 12345678910111213import time, sysdef loading(): print(&quot;Loading...&quot;) for i in range(0, 100): time.sleep(0.05) width = int((i + 1) / 4) bar = &quot;[&quot; + &quot;▆&quot; * width + &quot; &quot; * (25 - width) + &quot;]&quot; # ▆表示当前进度 空格表示其余部分 sys.stdout.write(u&quot;\\u001b[1000D&quot; + bar) sys.stdout.flush() print(&quot;\\nDone!&quot;)loading() 每次根据当前进度，光标移到行首，覆盖打印对应的小方块，其余部分打印空格。 很多时候，CLI 背后可能在同时执行多个任务，那么通过光标移动也可以实现同时打印多个进度条，例如： 1234567891011121314151617181920212223import time, sys, randomdef loading(count): all_progress = [0] * count sys.stdout.write(&quot;\\n&quot; * count) while any(x &lt; 100 for x in all_progress): # 等待所有进度条 100% time.sleep(0.01) # 随机为其中一个还没完成的进度条 进度+1 unfinished = [(i, v) for (i, v) in enumerate(all_progress) if v &lt; 100] index, _ = random.choice(unfinished) all_progress[index] += 1 # 光标向左移动到行首 sys.stdout.write(u&quot;\\u001b[1000D&quot;) # 光标向上移动到对应进度条的那一行 sys.stdout.write(u&quot;\\u001b[&quot; + str(count) + &quot;A&quot;) for i in range(len(all_progress)): progress = all_progress[i] width = int(progress / 4) # 打印对应进度 print(&quot;progress&quot; + str(i + 1) + &quot;: [&quot; + &quot;▇&quot; * width + &quot; &quot; * (25 - width) + &quot;]&quot;) print(&quot;Done!&quot;)loading(3) 自定义命令行工具如何自定义一个命令行工具？核心就是 接收输入数据-&gt;交给系统执行-&gt;打印输出-&gt;继续接收输入数据…..前面提到，当键盘摁下的键属于控制字符时（ASCII码 &lt; 32），例如 回车、删除、方向键、Tab键，不做特殊处理是无法识别成对应操作的，例如： 12345678910111213141516171819202122232425import sys, ttydef command_line(): tty.setraw(sys.stdin) while True: input_text = &quot;&quot; index = 0 while True: char = ord(sys.stdin.read(1)) if char == 3: # CTRL + C return elif 32 &lt;= char &lt;= 126: # 正常字符输入 input_text = input_text[:index] + chr(char) + input_text[index:] index += 1 elif char in &#123;10, 13&#125;: # 回车换行 sys.stdout.write(u&quot;\\u001b[1000D&quot;) # 光标回到行首 print(&quot;\\nechoing... &quot;, input_text) input_text = &quot;&quot; sys.stdout.write(u&quot;\\u001b[1000D&quot;) sys.stdout.write(input_text) sys.stdout.flush()command_line() 在接收输入的时候，只处理了 CTRL+C 和 ENTER 键，当我们摁下方向键时，上下左右 就会变成 [A[B[D[C，这样就无法实现光标移动，输入数据插入到前面的效果。 解析方向键&amp;删除键从输入的字符里面，解析是否是方向键或删除键（这里没有处理 上键和下键，一般对应获取历史输入的命令） 1234567891011121314151617181920212223242526272829303132333435363738394041import sys, ttydef command_line(): tty.setraw(sys.stdin) while True: input_text = &quot;&quot; index = 0 while True: char = ord(sys.stdin.read(1)) if char == 3: # CTRL + C return elif 32 &lt;= char &lt;= 126: # 正常字符输入 input_text = input_text[:index] + chr(char) + input_text[index:] index += 1 elif char in &#123;10, 13&#125;: # 回车换行 sys.stdout.write(u&quot;\\u001b[1000D&quot;) # 光标回到行首 print(&quot;\\nechoing... &quot;, input_text) input_text = &quot;&quot; index = 0 elif char == 27: next1, next2 = ord(sys.stdin.read(1)), ord(sys.stdin.read(1)) if next1 == 91: if next2 == 68: # 左方向键ANSI：\\u001b[D 27表示ESC，91表示[ 68表示D index = max(0, index - 1) elif next2 == 67: # 右方向键ANSI：\\u001b[D 27表示ESC，91表示[ 67表示C index = min(len(input_text), index + 1) elif char == 127: # 退格键 input_text = input_text[:index - 1] + input_text[index:] index -= 1 sys.stdout.write(u&quot;\\u001b[1000D&quot;) # 光标移动到行首 sys.stdout.write(u&quot;\\u001b[0K&quot;) # 清除当前行 sys.stdout.write(input_text) # 重新打印当前行的数据 sys.stdout.write(u&quot;\\u001b[1000D&quot;) # 移动光标到行首 if index &gt; 0: sys.stdout.write(u&quot;\\u001b[&quot; + str(index) + &quot;C&quot;) # 移动光标到当前位置 sys.stdout.flush()command_line() 可能涉及的其他常用指令： 清除屏幕：\\u001b[{n}J n&#x3D;0：清除光标到屏幕末尾的所有字符。 n&#x3D;1：清除屏幕开头到光标的所有字符。 n&#x3D;2：清除整个屏幕的字符。 清除行：\\u001b[{n}K n&#x3D;0：清除光标到当前行末所有的字符。 n&#x3D;1：清除当前行到光标的所有字符。 n&#x3D;2：清除当前行。 光标按行向下移动：\\u001b[{n}E 将光标向下移动n行并且将光标移至行首。 光标按行向上移动：\\u001b[{n}F 将光标向上移动n行并且将光标移至行首。 设置光标所在列：\\u001b[{n}G 将光标移至当前行的第n列。 设置光标所在位置：\\u001b[{n};{m}H 将光标移至第n行m列。 Vim 清屏实现原理保存&#x2F;恢复 Terminal屏幕：通过 smcup、rmcup 控制码smcup (Start Cursor Position) 用于启用终端屏幕上的复杂图形和窗口环境。当 smcup 被发送到终端时，终端会将当前屏幕内容保存到缓冲区中，并进入图形环境。rmcup (Reset Cursor Position) 用于禁用终端屏幕上的复杂图形和窗口环境。当 rmcup 被发送到终端时，终端会从缓冲区中恢复上一个屏幕状态，结束图形环境并返回到普通终端模式。 以下通过 Shell 脚本模拟一个类似 Vim 清屏-&gt;输入数据-&gt;恢复屏幕 的过程 1234567891011121314# !/bin/bash # 保存屏幕内容tput smcup# 清除屏幕内容clearread -p &quot;Enter your name:&quot; name # 等待输入信息# 输入完成，按任意键结束read -n1 -p &quot;Press any key to continue...&quot;# 恢复屏幕内容tput rmcup Tab 键自动补全原理在 Terminal 中，Tab 键可以用于自动补全命令和文件名。当用户在 Terminal 中输入部分命令或文件名并按下 Tab 键时，终端程序会根据当前所在目录以及用户输入的内容，搜索与之匹配的命令和文件名，并在屏幕上显示匹配的结果。摁下Tab键之后，如果有多个匹配项，继续摁Tab可以实现在这些匹配项里面顺序选择。里面实际上也是不断修改输入的内容，调整光标位置，当前选中的项加上背景色。 SpringBoot 启动广告如何实现这个跟 Terminal 关系不大，其实就是一种艺术字符号转换。在线生成链接，里面有很多花里胡哨的字体：https://tooltt.com/art-ascii/生成后复制下来保存到文件（因为有些艺术字包含特殊字符 直接放到代码里会报错）里，读取并打印到控制台。也可通过前面提到的 ANSI 为其加上字体颜色。 12345import os.pathif __name__ == &quot;__main__&quot;: print(&quot;\\033[5;36m&#123;&#125;\\033[0m&quot;.format(open(os.path.dirname(__file__) + &quot;/banner&quot;, &#x27;r&#x27;).read())) # ...","categories":[{"name":"Terminal","slug":"Terminal","permalink":"http://smuyyh.top/categories/Terminal/"}],"tags":[{"name":"Terminal","slug":"Terminal","permalink":"http://smuyyh.top/tags/Terminal/"}]},{"title":"IDEA 插件开发","slug":"idea-plugin-dev","date":"21/08/2022","updated":"30/10/2023","comments":true,"path":"2022/08/21/idea-plugin-dev/","link":"","permalink":"http://smuyyh.top/2022/08/21/idea-plugin-dev/","excerpt":"前言官方开发文档：http://www.jetbrains.org/intellij/sdk/docs/welcome.html 首先需要开启 Plugin Devkit , IDEA 中默认带了 Plugin Devkit插件，但是没有开启。","text":"前言官方开发文档：http://www.jetbrains.org/intellij/sdk/docs/welcome.html 首先需要开启 Plugin Devkit , IDEA 中默认带了 Plugin Devkit插件，但是没有开启。 插件工程创建 插件工程结构12345678BundleFileFinder/ resources/ META-INF/ plugin.xml ... src/ com.yuyang.finder ... src 实现插件功能的classes resources 存放工程需要用到的资源文件，例如一些引用的jar包、图片资源等。 META-INF&#x2F;plugin.xml 插件的配置文件，指定插件名称、描述、版本号、支持的 IntelliJ IDEA 版本、插件的 components 和 actions 以及软件商等信息。 plugin.xml12345678910111213141516171819202122232425262728293031323334353637383940&lt;idea-plugin&gt; &lt;!-- 插件相关信息， 会展示在IDEA插件的描述中 --&gt; &lt;!-- 插件唯一id, 遵循使用包名的原则 --&gt; &lt;id&gt;com.yuyang.finder&lt;/id&gt; &lt;!-- 插件名称 --&gt; &lt;name&gt;BundleFileFinder&lt;/name&gt; &lt;!-- 插件版本 --&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!-- 开发者信息 --&gt; &lt;vendor email=&quot;smuyyh@gmail.com&quot; url=&quot;http://smuyyh.top&quot;&gt;$Company|$Name&lt;/vendor&gt; &lt;!-- 插件的描述 --&gt; &lt;description&gt;my plugin description&lt;/description&gt; &lt;!-- 插件版本变更信息 --&gt; &lt;change-notes&gt;Initial release of the plugin.&lt;/change-notes&gt; &lt;!-- 如果该插件还依赖了其他插件，则配置对对应的插件id --&gt; &lt;depends&gt;com.intellij.modules.all&lt;/depends&gt; &lt;!-- 插件兼容IDEA的最大和最小build号，不配置则不做限制 --&gt; &lt;idea-version since-build=&quot;94.539&quot; until-build=&quot;192&quot;/&gt; &lt;!-- Actions: 如添加一个文件右击菜单按钮 --&gt; &lt;actions&gt; &lt;action id=&quot;FinderAction&quot; class=&quot;com.yuyang.finder.FinderAction&quot; text=&quot;FileFinder&quot; description=&quot;FileFinder&quot;&gt; &lt;add-to-group group-id=&quot;ProjectViewPopupMenu&quot; anchor=&quot;first&quot;/&gt; &lt;/action&gt; &lt;/actions&gt; &lt;!-- 插件定义的扩展点，以供其他插件扩展该插件，类似Java的抽象类的功能 --&gt; &lt;extensionPoints&gt; ... &lt;/extensionPoints&gt; &lt;!-- 声明该插件对IDEA core或其他插件的扩展 --&gt; &lt;extensions xmlns=&quot;com.intellij&quot;&gt; ... &lt;/extensions&gt;&lt;/idea-plugin&gt; Plugin ActionAction 是什么Action 用于描述一个动作、行为，可以通过快捷键、点选的方式进行触发。一个 Action 是一个 class，是 AnAction 的子类，actionPerformed 方法在菜单Item或者标题栏按钮被选中的时候会被调用。 Action 允许添加到右键菜单或者Toolbar菜单上面。Action也可以成组添加到具体的一个Group下面。 创建Action1234567891011121314151617181920212223242526272829303132public class FinderAction extends AnAction &#123; private Project mProject; @Override public void actionPerformed(AnActionEvent event) &#123; mProject = event.getData(PlatformDataKeys.PROJECT); DataContext dataContext = event.getDataContext(); if (&quot;apk&quot;.equals(getFileExtension(dataContext))) &#123; //获取选中的文件 VirtualFile file = DataKeys.VIRTUAL_FILE.getData(event.getDataContext()); if (file != null) &#123; // 创建面板 java swing // 后面章节会有 java GUI 面板介绍 &#125; &#125; else &#123; Messages.showInfoMessage(&quot;请选择.apk文件&quot;, &quot;提示&quot;); &#125; &#125; @Override public void update(AnActionEvent event) &#123; String extension = getFileExtension(event.getDataContext()); this.getTemplatePresentation().setEnabled(extension != null &amp;&amp; &quot;apk&quot;.equals(extension)); &#125; public String getFileExtension(DataContext dataContext) &#123; VirtualFile file = DataKeys.VIRTUAL_FILE.getData(dataContext); return file == null ? null : file.getExtension(); &#125;&#125; 注册Action123456789101112131415161718192021222324252627282930313233343536373839404142&lt;actions&gt; &lt;!-- 添加单个Action --&gt; &lt;action id=&quot;FinderAction&quot; class=&quot;com.yuyang.finder.FinderAction&quot; text=&quot;FileFinder&quot; description=&quot;当前插件菜单功能说明&quot; icon=&quot;icons/garbage.png&quot; keymap=&quot;未知&quot; popup=&quot;&quot; project-type=&quot;&quot; use-shortcut-of=&quot;&quot;&gt; &lt;!-- 将菜单添加至工程的右击菜单 --&gt; &lt;add-to-group group-id=&quot;ProjectViewPopupMenu&quot; anchor=&quot;first&quot; relative-to-action=&quot;GenerateJavadoc&quot; /&gt; &lt;!-- 设置快捷键 --&gt; &lt;keyboard-shortcut keymap=&quot;Mac OS X&quot; first-keystroke=&quot;control alt G&quot; second-keystroke=&quot;C&quot; remove=&quot;true&quot;/&gt; &lt;/action&gt; &lt;!-- 添加成组的action --&gt; &lt;group id=&quot;FinderGroup&quot; text=&quot;组名&quot; description=&quot;描述&quot;&gt; &lt;add-to-group group-id=&quot;MainMenu&quot; anchor=&quot;last&quot; /&gt; &lt;action id=&quot;Action1&quot; class=&quot;com.yuyang.finder.FinderAction1&quot; text=&quot;名称1&quot; description=&quot;描述1&quot; /&gt; &lt;!-- 添加分割线 --&gt; &lt;separator/&gt; &lt;action id=&quot;Action2&quot; class=&quot;com.yuyang.finder.FinderAction2&quot; text=&quot;名称2&quot; description=&quot;描述2&quot; /&gt; &lt;!-- 可以添加一个已存在的action到该group --&gt; &lt;reference ref=&quot;EditorCopy&quot;/&gt; &lt;/group&gt;&lt;/actions&gt; 如果 anchor 设置为 before 或者 after，则必须设置 relative-to-action。 快速创建ActionPlugin Devkit提供了快捷创建Action的方式。 信息填写基本遵循注册Action时的字段内容。 Action ID: action 唯一 id，推荐使用全类名 Class Name: 要被创建的 action class 名称 Name: menu item 的文本 Description: action 描述，toolbar 上按钮的提示文本，可选 Add to Group：选择新 action 要被添加到的 action group（Groups, Actions）以及相对其他 actions 的位置（Anchor），比如 EditMenu 就是顶部菜单栏的 Edit 菜单。 Keyboard Shortcuts：指定 action 的第一和第二快捷键 运行插件点击 Run | Edit Configurations，若无配置项，则新建一个，配置一下 Use classpath of module,选择要调试的Module。 若需要查看调试日志，则需要勾选 Logs的选项。运行插件时将会输出log到console，也可以设置输出到具体文件。 打包插件Build -&gt; Prepare All Plugin Modules For Deployment，一般会将插件输出到工程根目录底下。 如果该插件没有依赖其他的library，则插件会被打包成.jar，否则会被打包成.zip 1234567891011121314151617.jar 类型的文件内容结构BundleFileFinder.jar/ com/yuyang/finder/ ... META-INF/ plugin.xml .zip 类型的文件内容结构BundleFileFinder.zip/ lib/ lib1.jar lib2.jar BundleFileFinder.jar/ com/yuyang/finder/ ... META-INF/ plugin.xml 安装插件Intellij IDEA -&gt; Preferences -&gt; Plugins -&gt; Install Plugin From Disk，选择打包出来的 .jar 或者 .zip 文件。 Plugin ComponentsComponents 类型 Components 接口类型 描述 Application Component IDEA启动时会初始化，IDEA生命周期中仅存在一个实例。 Project Component IDEA 会为每一个 Project 实例创建一个 Project 级别的component Module Component IDEA 会为每一个 Project 的加载过的Module实例Module级别的component 创建 Component与 Action 一样，可以通过快捷方式创建。 右击菜单 -&gt; New -&gt; Plugin Devkit -&gt; Application&#x2F;Project&#x2F;Module Component。 例如创建 Application Component，默认会生成一个 Application 类 和 plugin.xml 的配置 1234567891011121314151617181920public class FinderApplication implements ApplicationComponent &#123; public FinderApplication() &#123; &#125; @Override public void initComponent() &#123; // TODO: insert component initialization logic here &#125; @Override public void disposeComponent() &#123; // TODO: insert component disposal logic here &#125; @Override @NotNull public String getComponentName() &#123; return &quot;FinderApplication&quot;; &#125;&#125; 12345&lt;application-components&gt; &lt;component&gt; &lt;implementation-class&gt;com.yuyang.finder.FinderApplication&lt;/implementation-class&gt; &lt;/component&gt;&lt;/application-components&gt; Project Component 123456789101112131415161718192021222324252627282930public class FinderProject implements ProjectComponent &#123; public FinderProject(Project project) &#123; &#125; @Override public void initComponent() &#123; &#125; @Override public void disposeComponent() &#123; &#125; @Override @NotNull public String getComponentName() &#123; return &quot;FinderProject&quot;; &#125; @Override public void projectOpened() &#123; // called when project is opened &#125; @Override public void projectClosed() &#123; // called when project is being closed &#125;&#125; 12345&lt;project-components&gt; &lt;component&gt; &lt;implementation-class&gt;com.yuyang.finder.FinderProject&lt;/implementation-class&gt; &lt;/component&gt;&lt;/project-components&gt; Module Component 1234567891011121314151617181920212223242526public class FinderModule implements ModuleComponent &#123; public FinderModule(Module module) &#123; &#125; @Override public void initComponent() &#123; // TODO: insert component initialization logic here &#125; @Override public void disposeComponent() &#123; // TODO: insert component disposal logic here &#125; @Override @NotNull public String getComponentName() &#123; return &quot;FinderModule&quot;; &#125; @Override public void moduleAdded() &#123; // Invoked when the module corresponding to this component instance has been completely // loaded and added to the project. &#125;&#125; 12345&lt;module-components&gt; &lt;component&gt; &lt;implementation-class&gt;com.yuyang.finder.FinderModule&lt;/implementation-class&gt; &lt;/component&gt;&lt;/module-components&gt; 获取 Component 实例例如 获取定义的一个 Application Component 实例： 12//获取application容器中的组件FinderApplication finderApplication = ApplicationManager.getApplication().getComponent(FinderApplication.class); Project 与 Module 12345678910111213public class FinderProject implements ProjectComponent &#123; private Project project; public FinderProject(Project project) &#123; this.project = project; &#125; @Override public void initComponent() &#123; FinderModule finderModule = project.getComponent(FinderModule.class); &#125;&#125; 也可以通过 AnAction 的事件获取。 1234567891011121314151617181920public class FinderAction extends AnAction &#123; private Application mApplication; private Project mProject; private Module mModule; @Override public void actionPerformed(AnActionEvent event) &#123; DataContext dataContext = event.getDataContext(); // DataConstants 被标记为 @deprecated mProject = (Project)dataContext.getData(DataConstants.PROJECT); mModule =(Module)dataContext.getData(DataConstants.MODULE); // OR mProject = event.getData(PlatformDataKeys.PROJECT); // mModule = ??? &#125;&#125; 持久化对于IDEA插件的一些配置，一般情况下都不会希望用户每次使用插件时都要配置一遍，所以 IntelliJ Platform 提供了一些 API，来做数据的持久化。 PropertiesComponent对于简单的 key - value 数据结构，可以使用 PropertiesComponent，用于保存 application 和 project 级别的数据。用法如下： 12345678//获取 application 级别的 PropertiesComponentPropertiesComponent propertiesComponent = PropertiesComponent.getInstance();//获取 project 级别的 PropertiesComponent，指定相应的 projectPropertiesComponent propertiesComponent = PropertiesComponent.getInstance(Project);// set &amp; getpropertiesComponent.setValue(name, value)propertiesComponent.getValue(name) 所有的 PropertiesComponent设置的键值对共用同一个namespance，所以需要避免key冲突。 PersistentStateComponent对于复杂的数据结构，可以使用 PersistentStateComponent，PersistentStateComponent 可以指定持久化的存储位置。 需要提供一个 PersistentStateComponent 的实现类，T代表需要持久化的数据结构类型，然后重写 getState() 和 loadState() 方法。T可以是任意的类，或者是实现类自身。 若需要指定存储位置，则在实现类上增加 @State 注解 若不希望其中的某个字段被持久化，可以在该字段上增加 @Transient 注解 123456789101112131415161718192021222324252627@State(name = &quot;PersistentStateComponentImpl&quot;, storages = &#123; @Storage(value = &quot;PersistentStateComponentImpl.xml&quot;) &#125;)class PersistentStateComponentImpl implements PersistentStateComponent&lt;State&gt; &#123; State myState; // 当组件被创建或 xml 文件被外部改变（比如git更新）时被调用 public State getState() &#123; return myState; &#125; // 当 settings 被保存时，该方法会被调用并保存状态值。 public void loadState(State state) &#123; myState = state; &#125;&#125;class State &#123; public State() &#123;&#125; // 支持基本的数据类型、Map、Collection、enum public String value; @Transient public String disableSave;&#125; 若是 application 级别的组件 运行调试时 xml 文件的位置： ~&#x2F;IdeaICxxxx&#x2F;system&#x2F;plugins-sandbox&#x2F;config&#x2F;options 正式安装时 xml 文件的位置： ~&#x2F;IdeaICxxxx&#x2F;config&#x2F;options 若是 project 级别的组件 默认为项目的 .idea&#x2F;misc.xml 若指定为 StoragePathMacros.WORKSPACE_FILE，则会被保存在 .idea&#x2F;worksapce.xml 注册持久化组件持久化组件可以声明为 Service，也可以声明为 Component，声明为 Component 则与前面介绍注册与获取的方法一致，声明为Service如下：获取方式为： 123456&lt;extensions defaultExtensionNs=&quot;com.intellij&quot;&gt; &lt;!-- application 级别--&gt; &lt;applicationService serviceImplementation=&quot;com.yuyh.finder.PersistentStateComponentImpl1&quot;/&gt; &lt;!-- project 级别 --&gt; &lt;projectService serviceImplementation=&quot;com.yuyh.finder.PersistentStateComponentImpl2&quot;/&gt; &lt;/extensions&gt; GUI 面板IDEA - Preference - Editor - Gui Designer，勾选 Java Source Code，表示我们通过面板编辑后可以生成 java代码。 创建GUI Form指定位置右击 - New - GUI Form 面板编辑完成之后，点击Toolbar工具条那里的按钮，进行编译。编译完成后，GUI的代码会生成在 对应的 Java文件里面。如图是 Demo.java 文件结构默认根JPanel是没有配置 “field name”控件属性的，所以我们需要给他配置一下。 生成的java文件如图，$$$setupUI$$$() 方法里面是具体创建布局的代码。 布局预览在需要插入main方法的地方，按下 Command + n，点击 Form main，则会生成可执行的main方法。 运行 main 方法，可以预览之前创建的布局。 插件上传插件也支持上传到 idea 仓库，让其他人搜索到。官方文档：http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started&#x2F;publishing_plugin.html 示例项目实现反编译APK来查找是否引用了某个类；仓库地址：BundleFileFinder","categories":[{"name":"Java","slug":"Java","permalink":"http://smuyyh.top/categories/Java/"}],"tags":[{"name":"idea plugin","slug":"idea-plugin","permalink":"http://smuyyh.top/tags/idea-plugin/"},{"name":"java","slug":"java","permalink":"http://smuyyh.top/tags/java/"}]},{"title":"Kotlin官方文档翻译","slug":"kotlin-in-chinese","date":"14/09/2021","updated":"13/10/2022","comments":true,"path":"2021/09/14/kotlin-in-chinese/","link":"","permalink":"http://smuyyh.top/2021/09/14/kotlin-in-chinese/","excerpt":"翻译文档地址：https://smuyyh.top/kotlin-in-chinese/","text":"翻译文档地址：https://smuyyh.top/kotlin-in-chinese/","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[]},{"title":"深入理解 Android Transition 场景动画","slug":"android-transition","date":"19/10/2020","updated":"20/10/2020","comments":true,"path":"2020/10/19/android-transition/","link":"","permalink":"http://smuyyh.top/2020/10/19/android-transition/","excerpt":"Transition 概念Transition 是指不同 UI 状态转换时的动画。其中有两个关键概念：场景（Scene）和转换（Transition）。场景定义了一个确定的 UI 布局状态，而转换定义了两个场景切换时过渡的动画。 当两个场景进行切换时，Transition 主要有下面两个行为： 1、 确定开始场景和结束场景中每个 view 的状态。2、 根据状态差异创建 Animator，用于场景切换时每个 view 的动画。 例如最简单的对View的隐藏增加渐变动画：","text":"Transition 概念Transition 是指不同 UI 状态转换时的动画。其中有两个关键概念：场景（Scene）和转换（Transition）。场景定义了一个确定的 UI 布局状态，而转换定义了两个场景切换时过渡的动画。 当两个场景进行切换时，Transition 主要有下面两个行为： 1、 确定开始场景和结束场景中每个 view 的状态。2、 根据状态差异创建 Animator，用于场景切换时每个 view 的动画。 例如最简单的对View的隐藏增加渐变动画： 12TransitionManager.beginDelayedTransition(viewGroup, new Fade());view.setVisibility(View.GONE); 动画执行的基本流程：1、TransitionManager.beginDelayedTransition(viewGroup, new Fade()); 确定子view初始状态。2、调用view.setVisibility(View.GONE);之后，framework会调用Transition类的captureEndValues()方法，记录每个view最新的可见状态。3、 framework调用Transition的createAnimator()方法。transition会分析每个view的开始和结束时的数据发现view在开始时是可见的，结束时是不可见的。Fade（Transition的子类）会利用这些信息创建一个用于把view的alpha属性变为0的 Animator，并返回 Animator 对象。4、framework会执行返回的 Animator 动画 beginDelayedTransition 方法分析12345678910111213141516171819202122232425262728293031323334353637public static void beginDelayedTransition(final ViewGroup sceneRoot, Transition transition) &#123; ... ... // 确定 sceneRoot 的子 view 初始状态 sceneChangeSetup(sceneRoot, transitionClone); Scene.setCurrentScene(sceneRoot, null); // 在下一次 sceneRoot 绘制之前，确定 view 结束状态 sceneChangeRunTransition(sceneRoot, transitionClone);&#125;private static void sceneChangeRunTransition(final ViewGroup sceneRoot, final Transition transition) &#123; MultiListener listener = new MultiListener(transition, sceneRoot); sceneRoot.addOnAttachStateChangeListener(listener); // PreDraw 监听，确定结束状态 sceneRoot.getViewTreeObserver().addOnPreDrawListener(listener);&#125;private static class MultiListener implements ViewTreeObserver.OnPreDrawListener, View.OnAttachStateChangeListener &#123; ... ... @Override public boolean onPreDraw() &#123; ... ... mTransition.captureValues(mSceneRoot, false); if (previousRunningTransitions != null) &#123; for (Transition runningTransition : previousRunningTransitions) &#123; runningTransition.resume(mSceneRoot); &#125; &#125; // 执行动画 调用 Transition.createAnimators() &amp; Transition.runAnimators() mTransition.playTransition(mSceneRoot); return true; &#125;&#125;; 页面过渡动画过渡动画使得 Activity 跳转或者 Fragment 切换等显得不那么生硬，通过共享元素（Share Element）过渡决定了两个 Activity&#x2F;Fragment 共享的视图如何在这些跳转的时候执行过渡动画。例如，如果两个 Activity 使用相同的图片（但位置和大小不同），通过 changeImageTransform 共享元素过渡就会在这些 Activity&#x2F;Fragment 之间流畅地平移和缩放该图片。如图所示共享元素过渡效果： 支持的Android最低版本：Android 5.0 (API 21) Content Transition内容变换（Content Transition）决定了非共享view元素在 activity 和 fragment 切换期间是如何进入或者退出场景的。Content Transition 的触发是通过改变 view 的 visibility 来实现的。 setExitTransition() - 当A start B时，使A中的View退出场景的transition setEnterTransition() - 当A start B时，使B中的View进入场景的transition setReturnTransition() - 当B 返回 A时，使B中的View退出场景的transition setReenterTransition() - 当B 返回 A时，使A中的View进入场景的transition Shared Element Transition共享元素变换（Shared Element Transition）决定了共享view元素从一个 Activity&#x2F;Fragment 到另一个 Activity&#x2F;Fragment t 的切换中是如何动画变化的。共享元素变换并不是真正实现了两个activity或者Fragment之间元素的共享，Framework采用了不同的方法来达到相同的视觉效果。共享元素默认其实是绘制在整个view树结构的最上层，在一个叫ViewOverlay的东西上面。 setSharedElementEnterTransition() - 设置在A进入B的时候播放的动画，共享元素以A中的位置作为起始，B中的位置为结束来播放动画。 setSharedElementReturnTransition() - 设置在B返回A的时候播放的动画，共享元素以B中的位置作为起始，A中的位置为结束来播放动画。 Activity 共享元素过渡动画设置允许过渡动画按官方文档的说法，使用过渡动画之前需要在 Activity 设置启用，须在 setContentView() 之前调用，最好是放在 super.onCreate() 之前，避免 6.0 及以下机型报错：requestFeature() must be called before adding content。 1getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); 或者在Theme的定义里面加上 1&lt;item name=&quot;android:windowActivityTransitions&quot;&gt;true&lt;/item&gt; 开启过渡动画例如上面示例图里面，由搜索结果页跳商详页，主图缩放效果 1、两个页面执行过渡的共享元素分别设置相同的 transitionName 123&lt;ImageView ... android:transitionName=&quot;imgTransition&quot; /&gt; 2、执行过渡动画跳转 12345678910111213// 纯页面过渡，无共享元素，可以替代 Activity 过渡动画startActivity(new Intent(this, DetailActivity.class), ActivityOptions.makeSceneTransitionAnimation(this).toBundle());// 单个共享元素startActivity(new Intent(this, DetailActivity.class), ActivityOptionsCompat.makeSceneTransitionAnimation(this, imageView, &quot;imgTransition&quot;).toBundle()); // 多个共享元素Pair&lt;View, String&gt; pair1 = Pair.create((View) image, &quot;imgTransition&quot;);Pair&lt;View, String&gt; pair2 = Pair.create((View) title, &quot;titleTransition&quot;);...ActivityOptionsCompat transitionActivityOptions = ActivityOptionsCompat.makeSceneTransitionAnimation(ActTransitionActivity.this, pair1, pair2, ...);startActivity(new Intent(this, DetailActivity.class), transitionActivityOptions.toBundle()); 3、由于一个页面布局里面不允许有重名的 transitionName 的元素，对于列表，例如 RecyclerView，可以在 onBindViewHolder 的时候，手动设置 transitionName。 1234public void onBindViewHolder(final ViewHolder viewHolder, final int position) &#123; ... ViewCompat.setTransitionName(viewHolder.image, position + &quot;_imgTransition&quot;);&#125; 那么点击跳转到商详页的时候，把对应位置的 transitionName 通过参数带过去，并设置给商详页主图 ImageView 的 transitionName。 Tips1、页面退出时，应该调用 **Activity.finishAfterTransition()**，不能直接调用 finish()， 否则过渡动画将不执行。 2、过渡动画过程包括 Shared Element Transition 和 Content Transition， 指共享元素 和 其他非共享元素 的过渡动画。 Fragment 共享元素过渡动画Fragment 的过渡动画是天然支持的，在为 Fragment 添加 Transition 的时候并不需要像 Activity 一样设置 Window.FEATURE_ACTIVITY_TRANSITIONS 和 Window.FEATURE_CONTENT_TRANSITIONS。 例如，FragmentA 切换到 FragmentB，需要分别设置共享元素的 transitionName。Fragment 同样也支持设置过渡动画类型 123456Fragment.setSharedElementEnterTransition()Fragment.setSharedElementExitTransition()Fragment.setExitTransition()Fragment.setEnterTransition()Fragment.setReturnTransition()Fragment.setReenterTransition() 1. 对于fragment通过 replace() 的情况： 123456getSupportFragmentManager() .beginTransaction() .addSharedElement(holder.image, &quot;imgTransition&quot;) .replace(R.id.container, FragmentB) .addToBackStack(null) .commit(); 2. 对于fragment通过 add()&#x2F;show()&#x2F;hide() 的情况 12345678getSupportFragmentManager() .beginTransaction() .addSharedElement(holder.image, &quot;imgTransition&quot;) .add(R.id.container, FragmentB) .show(FragmentB) .hide(FragmentA) .setReorderingAllowed(true) // 必须设置，否则无效果 .commit(); 过渡动画分析页面进入和退出时，过渡动画执行顺序如图所示： 动画类型过渡时，可以设置一些动画效果（android.transition.Transition），一般默认是 Fade（淡入淡出）或 AutoTransition。系统还提供了其它一些动画，基本适用于大部分场景了。 Slide（滑动式，可以选择滑动方向） Explode（分解，类似Slide，但是会根据共享元素中心做方向计算，可以理解为周围发散） ChangeBounds（布局边界的变化 动画效果） ChangeClipBounds（裁剪边界的变化 动画效果） ChangeTransform（缩放和旋转方面的变化 动画效果） ChangeImageTransform (尺寸和缩放方面的变化 动画效果) AutoTransition（实际上包含了Fade-out，ChangeBounds和Fade-in的集合，对共享元素设置时包含的Fade无效果） TransitionSet（实现动画集合，AutoTransition 基于此类实现） 1234567891011121314// 页面跳转时，前一个页面非共享元素退出的动画getWindow().setExitTransition(new Slide());// 跳转返回时，前一个页面非共享元素进入的动画getWindow().setReenterTransition(null);// 页面跳转时，后一个页面非共享元素进入的动画getWindow().setEnterTransition(new Explode());// 跳转返回时，后一个页面非共享元素退出的动画getWindow().setReturnTransition(new Fade());// 前一个页面共享元素退出动画，一般不用设置，默认为move效果getWindow().setSharedElementExitTransition(new Fade().setDuration(1000));// 后一个页面共享元素进入动画getWindow().setSharedElementEnterTransition(new AutoTransition()); 也可以分别在两个 Activity 的 Theme 里面配置转场动画效果： 1234567891011121314&lt;style name=&quot;BaseAppTheme&quot; parent=&quot;android:Theme.Material&quot;&gt; &lt;!-- enable window content transitions --&gt; &lt;item name=&quot;android:windowActivityTransitions&quot;&gt;true&lt;/item&gt; &lt;!-- specify enter and exit transitions --&gt; &lt;item name=&quot;android:windowEnterTransition&quot;&gt;@transition/explode&lt;/item&gt; &lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/explode&lt;/item&gt; &lt;!-- specify shared element transitions --&gt; &lt;item name=&quot;android:windowSharedElementEnterTransition&quot;&gt; @transition/change_image_transform&lt;/item&gt; &lt;item name=&quot;android:windowSharedElementExitTransition&quot;&gt; @transition/change_image_transform&lt;/item&gt;&lt;/style&gt; 1234&lt;!-- res/transition/change_image_transform.xml --&gt;&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;changeImageTransform/&gt;&lt;/transitionSet&gt; 对于上述的各种 Transition，我们也可以设置其动画时长、插值器等。 123Transition.setDuration(300);Transition.setInterpolator(new FastOutSlowInInterpolator());Transition.setStartDelay(200); 自定义 Transition若系统提供的动画无法满足需求，也可以扩展 Visibility&#x2F;Transition 类实现自定义转场动画效果。例如自定义一个文字大小和颜色渐变的 Transition。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class ChangeTextTransition extends Transition &#123; protected static final String PROPNAME_TEXTSIZE = &quot;ChangeTextTransition::textSize&quot;; protected static final String PROPNAME_TEXTCOLOR = &quot;ChangeTextTransition::textColor&quot;; public ChangeTextTransition() &#123; addTarget(TextView.class); &#125; @Override public void captureStartValues(TransitionValues transitionValues) &#123; ShareElementInfo info = ShareElementInfo.getFromView(transitionValues.view); if (info == null || !(info.getViewStateSaver() instanceof TextViewStateSaver)) &#123; return; &#125; // 保存 Start TextView 的字体大小及颜色值 captureValues(transitionValues, (TextViewStateSaver) info.getViewStateSaver(), info.isEnter() ? info.getFromViewBundle() : info.getToViewBundle()); &#125; @Override public void captureEndValues(TransitionValues transitionValues) &#123; ShareElementInfo info = ShareElementInfo.getFromView(transitionValues.view); if (info == null || !(info.getViewStateSaver() instanceof TextViewStateSaver)) &#123; return; &#125; // 保存 End TextView 的字体大小及颜色值 captureValues(transitionValues, (TextViewStateSaver) info.getViewStateSaver(), info.isEnter() ? info.getToViewBundle() : info.getFromViewBundle()); &#125; protected void captureValues(TransitionValues value, TextViewStateSaver stateSaver, Bundle viewExtraInfo) &#123; value.values.put(PROPNAME_TEXTSIZE, stateSaver.getTextSize(viewExtraInfo)); value.values.put(PROPNAME_TEXTCOLOR, stateSaver.getTextColor(viewExtraInfo)); &#125; @Override public Animator createAnimator(ViewGroup sceneRoot, TransitionValues startValues, TransitionValues endValues) &#123; ShareElementInfo info = endValues==null?null:ShareElementInfo.getFromView(endValues.view); if (info == null || !(info.getViewStateSaver() instanceof TextViewStateSaver)) &#123; return null; &#125; final TextView view = (TextView) endValues.view; view.setPivotX(0f); view.setPivotY(0f); float startTextSize = (float) startValues.values.get(PROPNAME_TEXTSIZE); final float endTextSize = (float) endValues.values.get(PROPNAME_TEXTSIZE); ObjectAnimator textSizeAnimator = ObjectAnimator.ofFloat(view, new TextSizeProperty(), startTextSize, endTextSize); int startTextColor = (int) startValues.values.get(PROPNAME_TEXTCOLOR); int endTextColor = (int) endValues.values.get(PROPNAME_TEXTCOLOR); ObjectAnimator textColorAnimator = ObjectAnimator.ofArgb(view, new TextColorProperty(), startTextColor, endTextColor); // 根据之前保存的 Start&amp;End TextView 文字大小及颜色做渐变动画 AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playTogether(textSizeAnimator, textColorAnimator); return animatorSet; &#125; private class TextSizeProperty extends Property&lt;TextView, Float&gt; &#123; public TextSizeProperty() &#123; super(Float.class, &quot;textSize&quot;); &#125; @Override public void set(TextView object, Float value) &#123; object.setTextSize(TypedValue.COMPLEX_UNIT_PX, value); &#125; @Override public Float get(TextView object) &#123; return object.getTextSize(); &#125; &#125; private class TextColorProperty extends Property&lt;TextView, Integer&gt; &#123; public TextColorProperty() &#123; super(Integer.class, &quot;textColor&quot;); &#125; @Override public void set(TextView object, Integer value) &#123; object.setTextColor(value); &#125; @Override public Integer get(TextView object) &#123; return object.getCurrentTextColor(); &#125; &#125;&#125; Transition Overlap默认情况下，内容过渡动画的后一个页面的 Enter&#x2F;Return 转换会在 前一个页面的 Exit&#x2F;Reenter 转换结束前一点开始，产生一个小的重叠来让整体的效果更自然、更协调。默认 overlap 是 true，进入转换会退出转换开始后尽可能快地开始，如果设置为 false，进入转换只能在退出转换结束后开始，通常都为 true。 12getWindow().setAllowEnterTransitionOverlap(true);getWindow().setAllowReturnTransitionOverlap(true); Shared Element Overlay默认情况下，共享元素视图是绘制在整个视图结构之上的（的 ViewOverlay 层）。但是如果共享元素周围有点击效果，例如 ?attr/selectableItemBackground 波纹效果，那么如果共享元素视图绘制在整个视图结构之上，点击时在波纹效果还没消失的时候，会堆叠一个共享元素视图，比较影响协调性，可以把 sharedElementsUseOverlay 置为 false。 1getWindow().setSharedElementsUseOverlay(false) 更新共享元素 如上图所示，共享元素过渡跳转到预览页后，我们可以通过 ViewPager 切换到其他元素，那么返回时如果未更新共享元素对应关系，则返回时会出现找不到对应的共享元素，而无法执行过渡动画。理想情况如下图所示： 那么我们可以通过 SharedElementCallback 来更新共享元素对应关系。 对于列表页 ListActivity： 1234567891011121314151617181920212223setExitSharedElementCallback(new SharedElementCallback() &#123; private void removeOldViews(List&lt;String&gt; names, Map&lt;String, View&gt; sharedElements) &#123; if (!names.isEmpty()) &#123; for (String name : names) &#123; sharedElements.remove(name); &#125; names.removeAll(namesTobeRemoved); &#125; &#125; @Override public void onMapSharedElements(List&lt;String&gt; names, Map&lt;String, View&gt; sharedElements) &#123; // 清除旧的共享元素关系 removeOldViews(names, sharedElements); ViewHolder viewHolder = recyclerView.findViewHolderForPosition(currentPosition); View imageView = viewHolder.itemView.findViewById(R.id.image); // 更新共享元素对应关系 names.add(imageView.getTransitionName()); sharedElements.put(imageView.getTransitionName(), imageView); &#125;&#125;); 对于预览页 PreviewActivity: 1234567891011121314151617181920212223242526ActivityCompat.setExitSharedElementCallback(this, new SharedElementCallback() &#123; private void removeOldViews(List&lt;String&gt; names, Map&lt;String, View&gt; sharedElements) &#123; if (!names.isEmpty()) &#123; for (String name : names) &#123; sharedElements.remove(name); &#125; names.removeAll(namesTobeRemoved); &#125; &#125; @Override public void onMapSharedElements(List&lt;String&gt; names, Map&lt;String, View&gt; sharedElements) &#123; // 清除旧的共享元素关系 removeOldViews(names, sharedElements); Fragment fragment = getCurrentFragment(); if(fragment != null) &#123; View view = fragment.getView(); ImageView imageView = view.findViewById(R.id.image); // 更新共享元素关系 sharedElements.put(imageView.getTransitionName(), imageView); names.add(imageView.getTransitionName()); &#125; &#125;&#125;); Tips1、在PreviewActivity ViewPager 切换时，需要把当前的 position 通知给 ListActivity，RecyclerView 自动滚动到对应 position 位置，返回时才能获取到对应的 ViewHolder2、若不希望实时更新 position，也可以在预览页返回的时候的时候再更新，那么可能就需要延迟过渡动画，等待 RecyclerView 滚动到对应位置绘制完成，再执行过渡动画。对于 Activity 可以通过 postponeEnterTransition() 和 startPostponedEnterTransition() 来停止和恢复过渡动画，对于 Fragment 可以通过 getActivity().supportPostponeEnterTransition() 和 getActivity().supportStartPostponedEnterTransition() 来停止和恢复过渡动画 布局变化过渡动画布局变化自动监听1TransitionManager.beginDelayedTransition(viewGroup) 当我们调用 TransitionManager.beginDelayedTransition(viewGroup) 方法时，会立即记住当前 viewGroup 底下子节点的状态，然后在下一帧中再次记录 viewGroup 所有子节点的状态，根据状态差异执行过渡动画。默认动画是 AutoTransition。例如： 12345678910111213141516171819202122// CHANGE SIZETransitionManager.beginDelayedTransition(rootViewGroup);ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();if (sizeChanged) &#123; layoutParams.width = 200; layoutParams.height = 200;&#125; else &#123; layoutParams.width = 100; layoutParams.height = 100;&#125;imageView.setLayoutParams(layoutParams);// CHANGE POSITIONTransitionManager.beginDelayedTransition(rootViewGroup, new AutoTransition());LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) imageView.getLayoutParams();if (locationChanged) &#123; layoutParams.gravity = Gravity.CENTER;&#125; else &#123; layoutParams.gravity = Gravity.LEFT;&#125;imageView.setLayoutParams(layoutParams); animateLayoutChanges 属性123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; ... android:animateLayoutChanges=&quot;true&quot;&gt; &lt;ImageView android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; android:src=&quot;@mipmap/ic_launcher&quot;/&gt; &lt;TextView android:id=&quot;@+id/tvText&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;some text&quot; /&gt;&lt;/LinearLayout&gt; 通过布局属性 animateLayoutChanges，可以为子 View 变化自动执行过渡动画。如图所示： 场景过渡框架前文主要说明 Activity 之间跳转的过渡动画，那么如果在同一个 Activity 内的各个组件之间打造过渡动画效果，就可以通过场景过渡框架。场景过渡有两个关键概念：场景（Scene）和转换（Transition），简单的说就是每个 Scene 提供对应的UI布局组件，Transition 负责 Scene 执行两个 Scene 之间变换的过渡动画执行。对于两个场景之间添加过渡动画效果流程如下： 1、为起始布局和结束布局分别创建一个 Scene 对象。2、创建一个 Transition 对象以定义所需的动画类型。3、调用 TransitionManager.go()，然后系统会运行动画以交换布局。 布局变化场景动画为两个布局创建Scene。 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/scene_root&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;include layout=&quot;@layout/a_scene&quot; /&gt;&lt;/FrameLayout&gt; 第一个场景布局：res&#x2F;layout&#x2F;a_scene.xml 123456789101112131415161718&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/scene_container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/text_view1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Text Line 1&quot; /&gt; &lt;TextView android:id=&quot;@+id/text_view2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Text Line 2&quot; /&gt;&lt;/LinearLayout&gt; 第二个场景布局：res&#x2F;layout&#x2F;b_scene.xml，更改了布局方向和文本排列方式 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/scene_container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/text_view2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Text Line 2&quot; /&gt; &lt;TextView android:id=&quot;@+id/text_view1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Text Line 1&quot; /&gt;&lt;/LinearLayout&gt; 注意：两个场景布局需要做过渡动画的节点id需要保持一致！ 12345678910111213141516171819202122public class SceneTransitionActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_scene_transition); ViewGroup sceneRoot = (ViewGroup) findViewById(R.id.scene_root); Scene aScene = Scene.getSceneForLayout(sceneRoot, R.layout.a_scene, this); final Scene bScene = Scene.getSceneForLayout(sceneRoot, R.layout.b_scene, this); sceneRoot.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 执行场景动画 TransitionManager.go(bScene, new ChangeBounds()); &#125; &#125;); &#125;&#125; 执行场景动画效果如图所示：","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/tags/Android/"},{"name":"动画","slug":"动画","permalink":"http://smuyyh.top/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"Android 页面秒开优化总结","slug":"android-page-performance","date":"02/07/2020","updated":"30/10/2023","comments":true,"path":"2020/07/02/android-page-performance/","link":"","permalink":"http://smuyyh.top/2020/07/02/android-page-performance/","excerpt":"性能优化是一个长期的过程，并非一劳永逸，需要我们去抠细节，找到可以提升的地方。 针对Android平台自身特性的一些优化（例如xml布局优化、方法耗时之类）在这里就不展开了，主要还是从逻辑和业务出发~ 数据加载优化网络请求前置也许是因为时序的问题，通常情况下 Activity 启动之后有三个步骤： 加载布局及初始化View 再进行网络请求等待 请求结果json解析 最后再渲染到界面上。 而实际上 步骤1、2、3 这三步是可以并行去做的，假设说 加载布局及初始化View 需要 150ms，整个网络请求耗时 200ms，那么并行之后理想情况就可以节省 150ms 的启动时间。 这时候可能就有疑问了，假设网络请求时间比View初始化来得快，网络请求结束后要去更新UI，就很有可能引起空指针问题。所以针对这种情况，我们需要做一个等待View初始化完的操作。 其实因为 Android 基于消息机制，并且通常情况下View的更新都在主线程，实际上网络请求结束后，post到主线程后更新UI，onCreate 已经执行完了，所以不需要等待也可以。但如果是在子线程去调用非更新View的方法，比如获取一些状态之类的，那就需要做等待操作。","text":"性能优化是一个长期的过程，并非一劳永逸，需要我们去抠细节，找到可以提升的地方。 针对Android平台自身特性的一些优化（例如xml布局优化、方法耗时之类）在这里就不展开了，主要还是从逻辑和业务出发~ 数据加载优化网络请求前置也许是因为时序的问题，通常情况下 Activity 启动之后有三个步骤： 加载布局及初始化View 再进行网络请求等待 请求结果json解析 最后再渲染到界面上。 而实际上 步骤1、2、3 这三步是可以并行去做的，假设说 加载布局及初始化View 需要 150ms，整个网络请求耗时 200ms，那么并行之后理想情况就可以节省 150ms 的启动时间。 这时候可能就有疑问了，假设网络请求时间比View初始化来得快，网络请求结束后要去更新UI，就很有可能引起空指针问题。所以针对这种情况，我们需要做一个等待View初始化完的操作。 其实因为 Android 基于消息机制，并且通常情况下View的更新都在主线程，实际上网络请求结束后，post到主线程后更新UI，onCreate 已经执行完了，所以不需要等待也可以。但如果是在子线程去调用非更新View的方法，比如获取一些状态之类的，那就需要做等待操作。 Activity12345678910111213141516171819202122232425262728public abstract class BaseActivity extends AppCompatActivity &#123; private ReentrantLock mReentrantLock = new ReentrantLock(); protected void onCreate(Bundle savedInstanceState) &#123; try &#123; mReentrantLock.lock(); onInitData(savedInstanceState); &#125; catch (Exception ignored) &#123; &#125; finally &#123; super.onCreate(savedInstanceState); onCreateView(savedInstanceState); mReentrantLock.unlock(); &#125; &#125; protected void waitViewInitialized() &#123; try &#123; mReentrantLock.lock(); &#125; catch (Exception ignored) &#123; &#125; finally &#123; mReentrantLock.unlock(); &#125; &#125; protected abstract void onInitData(Bundle savedInstanceState); protected abstract void onInitView(Bundle savedInstanceState);&#125; Fragment1234567891011121314151617181920212223242526272829public abstract class BaseFragment extends Fragment &#123; private ReentrantLock mReentrantLock = new ReentrantLock(); protected View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View rootView; try &#123; mReentrantLock.lock(); onInitData(savedInstanceState); &#125; catch (Exception ignored) &#123; &#125; finally &#123; rootView = onInitView(inflater, container, savedInstanceState); mReentrantLock.unlock(); &#125; return rootView; &#125; protected void waitViewInitialized() &#123; try &#123; mReentrantLock.lock(); &#125; catch (Exception ignored) &#123; &#125; finally &#123; mReentrantLock.unlock(); &#125; &#125; protected abstract void onInitData(Bundle savedInstanceState); protected abstract View onInitView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState);&#125; json异步解析在上述步骤1和2并行的情况下，json在子线程解析效率理论上来讲要优于在主线程。View的初始化在主线程，假设网络请求比view初始化来得快，那么view初始化完成还需要等待json解析，那速度可能要更慢一些。我们统计了Android线上搜索结果的fastjson解析时间的平均数据，需要40ms左右。 json子线程解析在加载更多的场景下对滑动帧率也是有帮助的。 缓存&amp;预加载数据后带针对一些特殊场景，例如从 搜索结果列表页 跳 商品详情页，可以把商品主图、标题等信息带过去，提前展示，提升白屏体验。 数据预加载1、空间换时间方案 通过端智能及数据分析（可能需要算法的配合），对高频用户点击或展示的数据，可以在空闲线程做适当的预加载处理。 2、H5等资源内置、离线包或预加载 数据缓存结合业务场景，针对一些非实时更新但是复用性较高的接口，可以做一层网络数据缓存。 通过 LRUCache 做缓存限制缓存失效时间策略，降低数据出错的可能性 附：LRUCache 简单实现，可以做一些定制扩展 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class LRUCache&lt;K, V&gt; &#123; public static class Entry&lt;K, V&gt; &#123; public K key; public V value; public Entry&lt;K, V&gt; pre; public Entry&lt;K, V&gt; next; public Entry(K key, V value) &#123; this.key = key; this.value = value; &#125; &#125; private static final int DEFAULT_SIZE = 2; private int size = DEFAULT_SIZE; private Map&lt;K, Entry&lt;K, V&gt;&gt; values; private Entry&lt;K, V&gt; first; private Entry&lt;K, V&gt; last; public LRUCache(int size) &#123; if (size &gt; 0) &#123; this.size = size; &#125; // 设定初始容量*扩容因子 避免扩容 values = new HashMap&lt;&gt;((int)Math.ceil(size * 0.75f)); &#125; public final void put(@NotNull K key, V value) &#123; Entry&lt;K, V&gt; entry = values.get(key); if (entry == null) &#123; if (values.size() &gt;= size) &#123; removeLastEntry(); &#125; entry = new Entry&lt;&gt;(key, value); &#125; else &#123; entry.value = value; &#125; moveEntryToFirst(entry); &#125; public final V get(@NotNull K key) &#123; Entry&lt;K, V&gt; entry = values.get(key); if (entry == null) &#123; return null; &#125; moveEntryToFirst(entry); return entry.value; &#125; private void moveEntryToFirst(@NotNull Entry&lt;K, V&gt; entry) &#123; values.put(entry.key, entry); if (first == null || last == null) &#123; first = last = entry; return; &#125; if (entry == first) &#123; return; &#125; if (entry.pre != null) &#123; entry.pre.next = entry.next; &#125; if (entry.next != null) &#123; entry.next.pre = entry.pre; &#125; if (entry == last) &#123; last = last.pre; &#125; entry.next = first; first.pre = entry; first = entry; first.pre = null; &#125; private void removeLastEntry() &#123; if (last != null) &#123; values.remove(last.key); last = last.pre; if (last == null) &#123; first = null; &#125; else &#123; last.next = null; &#125; &#125; &#125;&#125; 数据&amp;View懒加载首屏不使用到的数据或者view，尽量采用懒加载的方式。 例如针对搜索结果页侧边栏筛选，可以在点击展开之后再添加筛选项。并且针对一些使用频率不高的功能，懒加载也能节约一定的运行内存空间。 布局加载优化提前异步Inflate布局 Inflate 过程慢主要有两个原因： 1、xml文件读取io过程2、反射创建View AsyncLayoutInflater：support v4包下面提供的类，用于在 work thread 加载布局，最后回调到主线程。 通常在网络请求的过程中，页面会处于一个空闲的状态，假设场景是搜索结果列表页，那么我们可以在数据请求前置的同时，去异步 inflate 一些 recyclerview 的 itemview，那么在渲染阶段就可以节约 recyclerview 的 createViewHolder 的时间。 并发优化客户端通常情况下需要并发处理的场景比较少，这里举个特殊场景。 搜索结果页采用 Mist 做动态化方案。需要再 view 渲染之前，异步去 build 每个数据对应的节点信息（主要是measure和layout过程），通过测试比较，针对某一款机型，单线程去build 30个数据节点需要300ms以上，多线程并发只需要100ms左右，并发线程数为 CPU核心数-1。 多线程并发对资源有抢占，但整体效果还是可以的。并且要做好任务分配，让并发的几个线程处理的任务数差不多，减少最后的等待时间。 日志治理大量的打印日志也会影响页面启动性能，需要相应治理。 交互优化 增强体感骨架图 假设说网络请求的时间要比view初始化慢得多，可以通过骨架图的形式，提前创建好一些itemview，来增强一些用户体感，同事也达到提前创建 view 的效果。 RPC 优化 推动服务端进行rt优化 数据冗余压缩策略，例如接口数据携带大量埋点信息，可以考虑做精简","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/tags/Android/"},{"name":"页面性能","slug":"页面性能","permalink":"http://smuyyh.top/tags/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/"}]},{"title":"关于 aar 接口参数被混淆问题","slug":"aar-params-proguard","date":"19/06/2020","updated":"19/06/2020","comments":true,"path":"2020/06/19/aar-params-proguard/","link":"","permalink":"http://smuyyh.top/2020/06/19/aar-params-proguard/","excerpt":"","text":"javac 编译过程中就已经对接口的参数进行混淆，所以在 gradle 配置 android 的混淆规则是不生效的。 解决办法： 1234567allprojects &#123; gradle.projectsEvaluated &#123; tasks.withType(JavaCompile) &#123; options.compilerArgs &lt;&lt; &quot;-g&quot; &lt;&lt; &quot;-parameters&quot; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[]},{"title":"RecyclerView 悬浮吸顶效果实现，支持数据绑定及Touch事件","slug":"sticky-header-recyclerview","date":"27/11/2019","updated":"30/10/2023","comments":true,"path":"2019/11/27/sticky-header-recyclerview/","link":"","permalink":"http://smuyyh.top/2019/11/27/sticky-header-recyclerview/","excerpt":"诸如联系人列表、分类页商品类表等分组场景，都可能需要悬浮吸顶的效果。Android 官方并未提供原生的组件来实现这个功能，因此需要我们自定义实现。 网上看到的基本实现思路都是通过 ItemDecoration ，在滑动过程中去根据当前滑动位置，绘制吸顶的视图。 如果只是需要简单的绘制，确实通过这个方式要简单的多。但是通过这种方式无法支持 Touch 事件。感兴趣的可以参考一下这个：https://gist.github.com/saber-solooki/edeb57be63d2a60ef551676067c66c71 （可能需要梯子才能访问）","text":"诸如联系人列表、分类页商品类表等分组场景，都可能需要悬浮吸顶的效果。Android 官方并未提供原生的组件来实现这个功能，因此需要我们自定义实现。 网上看到的基本实现思路都是通过 ItemDecoration ，在滑动过程中去根据当前滑动位置，绘制吸顶的视图。 如果只是需要简单的绘制，确实通过这个方式要简单的多。但是通过这种方式无法支持 Touch 事件。感兴趣的可以参考一下这个：https://gist.github.com/saber-solooki/edeb57be63d2a60ef551676067c66c71 （可能需要梯子才能访问） StickyHeader View 实现思路1、Adapter 的数据里面要能够区分对应 position 的数据是 Header 还是 Item2、通过 HeaderViewHolder 创建一个额外的悬浮HeaderView，当第一个分组的 Header 刚刚好贴边的时候，是无需展示这个悬浮HeaderView的。当第一个分组的 Header 往上滑了之后，那么就开始展示这个悬浮HeaderView。当第二个分组的 Header快要滑动到顶部的时候，悬浮HeaderView 要跟随逐渐往上退出。3、通过 HeaderViewHolder 把数据绑定到 悬浮HeaderView 上面4、处理点击事件或状态，应通过更改每个 Header 对应的 Model 的数据，在 onBindViewHolder 进行状态绑定。比如点击了悬浮HeaderView，需要做选中，那么，悬浮HeaderView 对应的真正的再列表中的View 也应该同步更新选选中状态。5、为了使 悬浮HeaderView 更加明显，可以通过 ViewPropertyAnimator 为其增加Z轴的阴影。 具体代码地址： https://github.com/smuyyh/StickyHeaderRecyclerView","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://smuyyh.top/tags/RecyclerView/"}]},{"title":"RecyclerView Adapter 实现自动多 ViewType","slug":"recyclerview-auto-viewtype","date":"26/11/2019","updated":"27/11/2019","comments":true,"path":"2019/11/26/recyclerview-auto-viewtype/","link":"","permalink":"http://smuyyh.top/2019/11/26/recyclerview-auto-viewtype/","excerpt":"前言多Type的列表在App中很常见，例如各种电商类App的首页，甚至是购物车、订单详情页面等。我们暂且将页面上每个ViewType对应的模块称之为楼层。那么，以电商订单详情举例，可能有以下楼层： 订单状态（交易成功、交易关闭等） 物流信息 收货地址 订单商品信息列表 价格相关信息 订单信息（订单号、交易流水号等） 其他一些展示信息 那么，我们可以通过不同的 ViewType 来区分这些模块，通常的做法是：","text":"前言多Type的列表在App中很常见，例如各种电商类App的首页，甚至是购物车、订单详情页面等。我们暂且将页面上每个ViewType对应的模块称之为楼层。那么，以电商订单详情举例，可能有以下楼层： 订单状态（交易成功、交易关闭等） 物流信息 收货地址 订单商品信息列表 价格相关信息 订单信息（订单号、交易流水号等） 其他一些展示信息 那么，我们可以通过不同的 ViewType 来区分这些模块，通常的做法是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class DetailAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; private static final int VIEW_TYPE_EMPTY = 0; private static final int VIEW_TYPE_HEADER = 1; private static final int VIEW_TYPE_ADDRESS = 2; private static final int VIEW_TYPE_GOODS = 3; private List&lt;Model&gt; mData = new ArrayList&lt;&gt;(); @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if(viewType == VIEW_TYPE_HEADER) &#123; return new HeaderViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.header, parent, false)); &#125; else if(viewType == VIEW_TYPE_ADDRESS) &#123; return new AddressViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.address, parent, false)); &#125; // ... return new EmptyViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.empty, parent, false)); &#125; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; // if(getItemViewType(position) == VIEW_TYPE_HEADER) &#123; // 绑定数据.... HeaderViewHolder headerViewHodlder = (HeaderViewHolder)holder; &#125; else if(getItemViewType(position) == VIEW_TYPE_ADDRESS) &#123; AddressViewHolder addressViewHolder = (AddressViewHolder)holder; // 绑定数据... &#125; // ... // 或者 if(holder instanceof HeaderViewHolder) &#123; // ... &#125; else if(holder instanceof AddressViewHolder) &#123; // ... &#125; // ... &#125; @Override public int getItemCount() &#123; return mData.size(); &#125; @Override public int getItemViewType(int position) &#123; Model model = mData.get(position); if(条件1) &#123; return VIEW_TYPE_HEADER; &#125; else if(条件2) &#123; return VIEW_TYPE_ADDRESS; &#125; else if(条件3) &#123; return VIEW_TYPE_GOODS; &#125; return VIEW_TYPE_EMPTY; &#125; class EmptyViewHolder extends RecyclerView.ViewHolder &#123; public EmptyViewHolder(View itemView) &#123; super(itemView); &#125; &#125; class HeaderViewHolder extends RecyclerView.ViewHolder &#123; public HeaderViewHolder(View itemView) &#123; super(itemView); &#125; &#125; class AddressViewHolder extends RecyclerView.ViewHolder &#123; public AddressViewHolder(View itemView) &#123; super(itemView); &#125; &#125; class GoodsViewHolder extends RecyclerView.ViewHolder &#123; public GoodsViewHolder(View itemView) &#123; super(itemView); &#125; &#125;&#125; 上面这种做法主要有以下几个弊端： 1、当 ViewType 种类特别多的情况下，Adapter里面的代码会过于臃肿，难以维护2、每当需要新增一个 ViewType 的时候，改动范围比较大，几乎涉及到了整个Adapter，多人协作容易代码冲突3、Adapter 的代码，复用性比较差。每个页面都需要自己重新写一个庞大的 Adapter4、局部刷新操作实现比较麻烦。比如不通过Model，要动态更改某一个楼层View的展示，就需要查找到对应楼层的 ViewHolder，代码实现要复杂得多5、如果不同的 ViewType 对应的 Model 类型不一样，那么Adapter里面的复杂度又会相应的上升6、RecyclerView.ViewHolder 的构造函数，需要把View带进来，这个对于ViewHolder实现来说是不合理的。 为什么这么说呢？因为每个 ViewHolder 对应的是什么样的View，其实应该 ViewHolder 自身最清楚，不应该在 onCreateViewHolder 的时候根据 viewType 来判断要 inflate 什么布局。所以为了实现解耦，这个问题必须优化掉。 逻辑实现为了解决上述问题，我们可以换个思路来实现。 通常情况下，服务端返回的List里面的Model，可以区分出对应的ViewType，然后对应的创建不同的 ViewHolder。那么，我们为了避免在 Adapter 里面来识别每个 Model 对象所对应的 ViewType，我们可以在组装数据的时候做一层预处理。封装的思路核心就在于以下三点： 1、BaseData, 用于对服务端数据预处理做一层包装，每个 BaseData 对应 Adapter 的一条数据，并且每个 BaseData 应该要知道自己对应 ViewHolder 类。2、BaseViewHolder, 所有的 ViewHolder 继承的抽象基类，由子类来返回对应的布局、数据绑定等等3、BaseAdapter, 数据类型是List&lt;BaseData&gt;，根据每个 BaseData对应的 ViewHolderClass，来自动生成对应的 ViewType。ViewHolderClass 与 ViewType 是一对一的关系。 onCreateViewHolder时，通过 ViewType 来找到对应的 ViewHolderClass，通过反射创建对应的 ViewHolder。在onBindViewHolder时，调用 BaseViewHolder 的 onBindViewHolder 方法。 BaseData的实现如下： 123456789101112public abstract class BaseData &#123; public BaseViewHolder lastViewHolder; public void setLastViewHolder(BaseViewHolder lastViewHolder) &#123; // 当数据需要刷新时，可以通过这个找到对应的ViewHolder this.lastViewHolder = lastViewHolder; &#125; // 每一个包装数据，需要知道对应的 ViewHolder 类是什么 public abstract Class&lt;? extends BaseViewHolder&gt; getViewHolderClass();&#125; BaseViewHolder 的实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class BaseViewHolder&lt;T extends BaseData&gt; extends RecyclerView.ViewHolder &#123; private static FrameLayout createRootLayout(Context context) &#123; FrameLayout layout = new FrameLayout(context); layout.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); return layout; &#125; protected Context mContext; protected View mRootView; public BaseViewHolder(@NonNull Context context) &#123; // 每个楼层最外围会包一个 FrameLayout，主要是为了避免 BaseViewHolder 创建之前就要先创建好View（懒加载思路） super(createRootLayout(context)); this.mContext = context; initView(); &#125; private void initView() &#123; mRootView = LayoutInflater.from(mContext).inflate(getLayoutId(), (ViewGroup) itemView, false); ((ViewGroup) itemView).addView(mRootView); onViewCreated(); &#125; // 每个 ViewHolder 对应的 Layout，子类实现 @LayoutRes protected abstract int getLayoutId(); protected abstract void onViewCreated(); @CallSuper public void onBindViewHolder(T data) &#123; data.setLastViewHolder(this); bindData(data); &#125; // 绑定数据，子类实现 protected abstract void bindData(T data);&#125; BaseAdapter 的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public abstract class BaseAdapter extends RecyclerView.Adapter&lt;BaseViewHolder&gt; &#123; protected Context mContext; // 记录 ViewHolderClass 与 ViewType 映射关系，两个Map主要是为了反向查找更方便 private ArrayMap&lt;Class&lt;? extends BaseViewHolder&gt;, Integer&gt; mItemTypeMap = new ArrayMap&lt;&gt;(); private ArrayMap&lt;Integer, Class&lt;? extends BaseViewHolder&gt;&gt; mViewHolderMap = new ArrayMap&lt;&gt;(); protected List&lt;BaseData&gt; mData = new ArrayList&lt;&gt;(); private int itemViewType = 0; public BaseAdapter(Context context) &#123; this.mContext = context; &#125; public void setData(List&lt;BaseData&gt; data) &#123; mData.clear(); if (data != null) &#123; genItemType(data); mData.addAll(data); &#125; notifyDataSetChanged(); &#125; public void appendData(List&lt;BaseData&gt; data) &#123; if (CollectionUtil.isEmpty(data)) &#123; return; &#125; genItemType(data); int start = mData.size(); mData.addAll(data); notifyItemRangeInserted(start, data.size()); &#125; // 自动生成自增长的ViewType private void genItemType(List&lt;BaseData&gt; data) &#123; if (data == null) &#123; return; &#125; for (BaseData item : data) &#123; Class&lt;? extends BaseViewHolder&gt; clazz = item.getViewHolderClass(); if (!mItemTypeMap.containsKey(item.getViewHolderClass())) &#123; mItemTypeMap.put(clazz, itemViewType); mViewHolderMap.put(itemViewType, clazz); itemViewType++; &#125; &#125; &#125; @Override public BaseViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; // 通过 ViewType 找到对应的 ViewHolderClass Class&lt;? extends BaseViewHolder&gt; clazz = mViewHolderMap.get(viewType); BaseViewHolder viewHolder = null; try &#123; // 反射创建ViewHolder，解耦 Constructor&lt;? extends BaseViewHolder&gt; ct = clazz.getDeclaredConstructor(Context.class); ct.setAccessible(true); viewHolder = ct.newInstance(mContext); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return viewHolder; &#125; @Override public void onBindViewHolder(BaseViewHolder holder, int position) &#123; //noinspection unchecked holder.onBindViewHolder(getItem(position)); &#125; @Override public int getItemCount() &#123; return mData.size(); &#125; @Override public int getItemViewType(int position) &#123; int type = 0; if (position &gt;= 0 &amp;&amp; position &lt; mData.size()) &#123; // 通过 ViewHolderClass 找到对应的 ViewType type = mItemTypeMap.get(getItem(position).getViewHolderClass()); &#125; return type; &#125; public BaseData getItem(int position) &#123; return mData.get(position); &#125;&#125; 用法每一种楼层，我们需要实现 BaseData和 BaseViewHolder, 以简单的文本展示做一个例子： 12345678910111213public class NormalTextData extends BaseData &#123; public String content; public NormalTextData(String content) &#123; this.content = content; &#125; @Override public Class&lt;? extends BaseViewHolder&gt; getViewHolderClass() &#123; return NormalTextViewHolder.class; &#125;&#125; 1234567891011121314151617181920212223public class NormalTextViewHolder extends BaseViewHolder&lt;NormalTextData&gt; &#123; private TextView contentView; public NormalTextViewHolder(Context context) &#123; super(context); &#125; @Override protected int getLayoutId() &#123; return R.layout.hm_order_cell_text; &#125; @Override protected void onViewCreated() &#123; contentView = findViewById(R.id.text_content); &#125; @Override public void bindData(NormalTextData data) &#123; contentView.setText(data.content); &#125;&#125; 1234567List&lt;BaseData&gt; data = new ArrayList&lt;&gt;();data.add(new NormalTextData(&quot;展示一行文本&quot;));BaseAdapter adapter = new BaseAdapter(context);adapter.setData(data);recyclerview.setAdapter(adapter); 以后，每当新增一个楼层，只需要新增两个类，分别实现 BaseData 和 BaseViewHolder，然后adapter插入对应的 BaseData 数据即可。实现极大程度的解耦。 感谢阅读。","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://smuyyh.top/tags/RecyclerView/"}]},{"title":"简析 Volatile 关键字","slug":"java-volatile","date":"11/10/2018","updated":"29/05/2019","comments":true,"path":"2018/10/11/java-volatile/","link":"","permalink":"http://smuyyh.top/2018/10/11/java-volatile/","excerpt":"Volatile 简介volatile作为java关键字之一，其主要作用为在并发场景下，当某个线程更新了使用volatile修饰的变量后，会立即将修改后的值写入主存，其他线程读取的时候可以保证读到的值是最新的，而不是缓存。非volatile修饰的变量在线程并发的情况下不具备这种特性。","text":"Volatile 简介volatile作为java关键字之一，其主要作用为在并发场景下，当某个线程更新了使用volatile修饰的变量后，会立即将修改后的值写入主存，其他线程读取的时候可以保证读到的值是最新的，而不是缓存。非volatile修饰的变量在线程并发的情况下不具备这种特性。 Volatile 特性1、可见性这里的可见性是指，当某个线程修改了这个变量的值后，其他线程立即可见。需要注意的一点是，java运算并非原子操作，所以无法保证原子性。 举个经典例子： 1234567891011121314151617181920212223242526272829public class Main &#123; private static volatile int count = 0; private static final int times = 10000; private static void add() &#123; for (int i = 0; i &lt; times; ++i) &#123; count++; &#125; &#125; public static void main(String[] args) &#123; Thread[] threads = new Thread[10]; for (int i = 0; i &lt; 10; ++i) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; add(); System.out.println(count); &#125; &#125;); &#125; for (Thread r : threads) &#123; r.start(); &#125; &#125;&#125; 最后输出： 1234567891018522214712164416865208072042135868387904024042493 可以发现，最后一个线程执行结束的时候值并非预想的10000。原因是因为 count++ 表达式是非原子操作，运行时会做拆解： 获取count的值，复制到寄存器 把前面获取到的count的值+1然后写到内存中 把上面的例子做个改造，也能印证问题： 1234567891011121314151617181920212223242526272829public class Main &#123; private static AtomicInteger count = new AtomicInteger(0); private static final int times = 10000; private static void add() &#123; for (int i = 0; i &lt; times; ++i) &#123; count.addAndGet(1); &#125; &#125; public static void main(String[] args) &#123; Thread[] threads = new Thread[10]; for (int i = 0; i &lt; 10; ++i) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; add(); System.out.println(count); &#125; &#125;); &#125; for (Thread r : threads) &#123; r.start(); &#125; &#125;&#125; 输出： 12345678910450605000047612478144596067128792348743990350100000 无论执行多少次，最后一个线程结束时，count的值总是100000。 2、有序性 有序性是指禁止指令重排优化，即程序执行的顺序按照代码的先后顺序执行。指令重排序是编译器和处理器为了高效对程序进行优化的手段，在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。重排序在多线程环境下出现的概率还是挺高的，在关键字上有volatile和synchronized会禁用重排序。 在JVM层，volatile 是采用“内存屏障”来实现的，那么指令重排序时不能把后面的指令重排序到内存屏障之前的位置，所以在执行到内存屏障这句指令时，在它前面的操作已经全部完成。同时，内存屏障会强制将缓存的修改操作立即写入主存，以确保其他线程立即可见。 Volatile 适用场景 适用于对变量的写操作不依赖于当前值，对变量的读取操作不依赖于非volatile变量。 适用于读多写少的场景。 应用场景 1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 为什么要使用volatile 修饰instance？? 主要在于 instance = new Singleton() 这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情: 1.给 instance 分配内存2.调用 Singleton 的构造函数来初始化成员变量3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。","categories":[{"name":"Java","slug":"Java","permalink":"http://smuyyh.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://smuyyh.top/tags/Java/"},{"name":"Volatile","slug":"Volatile","permalink":"http://smuyyh.top/tags/Volatile/"},{"name":"多线程","slug":"多线程","permalink":"http://smuyyh.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"RecyclerView 性能优化","slug":"recyclerview-performance","date":"11/07/2018","updated":"11/07/2018","comments":true,"path":"2018/07/11/recyclerview-performance/","link":"","permalink":"http://smuyyh.top/2018/07/11/recyclerview-performance/","excerpt":"RecyclerView 几乎已经取代了 ListView &amp; GridView，但为了达到更好的性能体验，还是需要做一些适当的优化的。 布局优化 取消默认动画 Item 等高 RecycledViewPool 避免创建过多对象 局部刷新","text":"RecyclerView 几乎已经取代了 ListView &amp; GridView，但为了达到更好的性能体验，还是需要做一些适当的优化的。 布局优化 取消默认动画 Item 等高 RecycledViewPool 避免创建过多对象 局部刷新 布局优化首当其冲，减少层次结构、减少过渡绘制，可以提高item的解析测量与绘制的效率。另外，应该尽量避免多次measure &amp; layout 次数。 1、 View 的三大过程从ViewRoot的 performTraversals() 方法开始，依次经过 measure() ， layout() 和 draw() 三个过程才最终将一个View绘制出来。 2、ViewGroup 性能相比之下，FrameLayout &amp; LinearLayout 的 measure 要远优于 RelativeLayout，因为 RelativeLayout 对子View做了两次measure，才能确定宽高，因为子View之间有彼此依赖的关系。但是LinearLayout 的子View如果加上了 layout_weight 的属性，也需要进行两次测量。 取消默认动画取消RecyclerView的默认动画，也可改善一些。 1mRecyclerView.setItemAnimator(null); Item 等高如果可以的话，把所有的 Item 的高度固定大小，这样可以减少测量次数，尤其是对于 GridLayoutManager。 1mRecyclerView.setHasFixedSize(true); RecycledViewPool可以给RecyclerView设置一个ViewHolder的对象池，这个池称为RecycledViewPool，这个对象池可以节省你创建ViewHolder的开销，更能避免GC。默认会自动创建一个。 1RecycledViewPool mPool = mRecyclerView.getRecycledViewPool(); RecycledViewPool可以自主控制需要缓存的ViewHolder数量： 1mPool.setMaxRecycledViews(itemViewType, number); RecyclerView可以设置自己所需要的ViewHolder数量： 1mRecyclerView.setItemViewCacheSize(10); 那么，可以按需调整draw缓存 123mRecyclerView.setItemViewCacheSize(20);mRecyclerView.setDrawingCacheEnabled(true);mRecyclerView.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH); 避免创建过多对象onCreateViewHolder 和 onBindViewHolder 对时间都比较敏感，尽量避免繁琐的操作和循环创建对象。例如创建 OnClickListener，可以全局创建一个，然后数据通过 itemView.setTag 携带。 局部刷新可以用一下一些方法，替代notifyDataSetChanged，已达到局部刷新的目的。 1234567notifyItemChanged(int position)notifyItemInserted(int position)notifyItemRemoved(int position)notifyItemMoved(int fromPosition, int toPosition) notifyItemRangeChanged(int positionStart, int itemCount)notifyItemRangeInserted(int positionStart, int itemCount) notifyItemRangeRemoved(int positionStart, int itemCount) 如果必须用 notifyDataSetChanged()，那么最好设置 mAdapter.setHasStableIds(true)","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"recyclerview","slug":"recyclerview","permalink":"http://smuyyh.top/tags/recyclerview/"}]},{"title":"滴滴开源Android插件化框架VirtualAPK原理分析","slug":"android-virtualapk-source","date":"08/07/2017","updated":"30/10/2023","comments":true,"path":"2017/07/08/android-virtualapk-source/","link":"","permalink":"http://smuyyh.top/2017/07/08/android-virtualapk-source/","excerpt":"概述滴滴出行公司的首个对外开源项目 - VirtualAPK。地址：https://github.com/didi/VirtualAPK 滴滴自行研发了这款插件化框架，功能全面、兼容性好，还能够适用于有耦合的业务插件，这就是VirtualAPK存在的意义。业内认为，在加载耦合插件方面，VirtualAPK可以说是开源方案的首选。据说滴滴打车里面已经用上了，所以还是有必要一探究竟的~~","text":"概述滴滴出行公司的首个对外开源项目 - VirtualAPK。地址：https://github.com/didi/VirtualAPK 滴滴自行研发了这款插件化框架，功能全面、兼容性好，还能够适用于有耦合的业务插件，这就是VirtualAPK存在的意义。业内认为，在加载耦合插件方面，VirtualAPK可以说是开源方案的首选。据说滴滴打车里面已经用上了，所以还是有必要一探究竟的~~ VirtualAPK 的工作流程如图所示： VirtualAPK 对于插件没有额外的约束，原生的 apk 即可作为一个插件。插件工程编译生成 apk 后，通过宿主 App 加载，每个插件 apk 被加载后，都会在宿主中创建一个单独的 LoadedPlugin 对象。如上图所示，通过这些 LoadedPlugin 对象，VirtualAPK 就可以管理插件并赋予插件新的意义，使其可以像手机中安装过的App一样运行。 Activity 支持Hook ActivityManagerService插件化支持首先要解决的一点就是插件里的Activity并未在宿主程序的 AndroidMainfest.xml 注册，常规方法肯定无法直接启动插件的Activity，这个时候就需要去了解Activity的启动流程，关于启动过程主要的几个步骤请参考：浅析Android Activity的启动过程 从上文中可知，Activity 启动实际上是调用了 Instrumentation.execStartActivity 这个方法。源码如下： 123456789101112131415161718192021222324252627282930public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; //先查找一遍看是否存在这个activity final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); //这里才是真正打开activity的地方，其核心功能在whoThread中完成。 int result = ActivityManagerNative.getDefault().startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()),token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); // 处理各种异常，如ActivityNotFound &#125; catch (RemoteException e) &#123; &#125; return null; &#125; 可见， startActivity 最终通过 ActivityManagerNative.getDefault() 远程调用了AMS的startActivity方法， ActivityManagerNative 实际上就是 ActivityManagerService 这个远程对象的 Binder 代理对象，每次需要与AMS交互时，需要通过这个 Binder 对象完成远程IPC调用。 还不了解Binder的童鞋，可以看看老罗的Android进程间通信（IPC）机制Binder简要介绍和学习计划 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// ActivityManagerNative.getDefault()static public IActivityManager getDefault() &#123; return gDefault.get();&#125;private static final Singleton&lt;iactivitymanager&gt; gDefault = new Singleton&lt;iactivitymanager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) &#123; Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); &#125; return am; &#125;&#125;;从这我们可以知道，ActivityManagerNative.getDefault() 实际上是返回了一个 IActivityManager 的单例对象。那么，VirtualApk 所要做的第一件事，就是把这个 AMS 代理对象保存起来。首先，我们可以看一下 VirtualApk 核心库里面 com.didi.virtualapk.PluginManager 这个类的初始化：```java// 构造方法private PluginManager(Context context) &#123; Context app = context.getApplicationContext(); if (app == null) &#123; this.mContext = context; &#125; else &#123; this.mContext = ((Application)app).getBaseContext(); &#125; prepare();&#125;// 初始化private void prepare() &#123; Systems.sHostContext = getHostContext(); this.hookInstrumentationAndHandler(); this.hookSystemServices();&#125;/** * Hook 出一个IActivityManager，也就是 AMS 的代理对象 */private void hookSystemServices() &#123; try &#123; // 反射调用 ActivityManagerNative.getDefault()，实际上这在6.0中是公开的静态方法，反射可能是考虑到版本兼容性吧？ Singleton&lt;IActivityManager&gt; defaultSingleton = (Singleton&lt;IActivityManager&gt;) ReflectUtil.getField(ActivityManagerNative.class, null, &quot;gDefault&quot;); // 通过动态代理的方式去创建代理对象，之后所有ActivityManagerNative中的方法被调用的时候都会经过这个代理 IActivityManager activityManagerProxy = ActivityManagerProxy.newInstance(this, defaultSingleton.get()); // Hook IActivityManager from ActivityManagerNative，实际上就是把 ActivityManagerNative 替换为刚创建的 activityManagerProxy ReflectUtil.setField(defaultSingleton.getClass().getSuperclass(), defaultSingleton, &quot;mInstance&quot;, activityManagerProxy); if (defaultSingleton.get() == activityManagerProxy) &#123; // 两者一样，保存下来 this.mActivityManager = activityManagerProxy; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 实际上除了 startActivity 是调用 AMS 的方法以外，startService， bindService 等方法，最终调用到AMS的里的方法，这个我们在动态代理类 com.didi.virtualapk.delegate.ActivityManagerProxy 也可以找到： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (&quot;startService&quot;.equals(method.getName())) &#123; try &#123; // 执行自定义的 startService 过程，后面会提到 return startService(proxy, method, args); &#125; catch (Throwable e) &#123; Log.e(TAG, &quot;Start service error&quot;, e); &#125; &#125; else if (&quot;stopService&quot;.equals(method.getName())) &#123; try &#123; return stopService(proxy, method, args); &#125; catch (Throwable e) &#123; Log.e(TAG, &quot;Stop Service error&quot;, e); &#125; &#125; else if (&quot;stopServiceToken&quot;.equals(method.getName())) &#123; try &#123; return stopServiceToken(proxy, method, args); &#125; catch (Throwable e) &#123; Log.e(TAG, &quot;Stop service token error&quot;, e); &#125; &#125; else if (&quot;bindService&quot;.equals(method.getName())) &#123; try &#123; return bindService(proxy, method, args); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; &#125; else if (&quot;unbindService&quot;.equals(method.getName())) &#123; try &#123; return unbindService(proxy, method, args); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; &#125; else if (&quot;getIntentSender&quot;.equals(method.getName())) &#123; try &#123; getIntentSender(method, args); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; else if (&quot;overridePendingTransition&quot;.equals(method.getName()))&#123; try &#123; overridePendingTransition(method, args); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; try &#123; // sometimes system binder has problems. return method.invoke(this.mActivityManager, args); &#125; catch (Throwable th) &#123; Throwable c = th.getCause(); if (c != null &amp;&amp; c instanceof DeadObjectException) &#123; // retry connect to system binder IBinder ams = ServiceManager.getService(Context.ACTIVITY_SERVICE); if (ams != null) &#123; IActivityManager am = ActivityManagerNative.asInterface(ams); mActivityManager = am; &#125; &#125; Throwable cause = th; do &#123; if (cause instanceof RemoteException) &#123; throw cause; &#125; &#125; while ((cause = cause.getCause()) != null); throw c != null ? c : th; &#125;&#125; 所以实际上就等同于我们重写了一些 Activity、Service 的相关操作。具体做些什么，后面会提到~ Hook Instrumentation回过头去看看 Instrumentation.execStartActivity 这个方法，在最后有这么一句代码： 1checkStartActivityResult(result, intent); // 处理各种异常，如ActivityNotFound 1234567891011121314151617181920212223242526272829static void checkStartActivityResult(int res, Object intent) &#123; if (res &gt;= ActivityManager.START_SUCCESS) &#123; return; &#125; switch (res) &#123; case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) throw new ActivityNotFoundException( &quot;Unable to find explicit activity class &quot; + ((Intent)intent).getComponent().toShortString() + &quot;; have you declared this activity in your AndroidManifest.xml?&quot;); throw new ActivityNotFoundException( &quot;No Activity found to handle &quot; + intent); case ActivityManager.START_PERMISSION_DENIED: throw new SecurityException(&quot;Not allowed to start activity &quot; + intent); case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: throw new AndroidRuntimeException( &quot;FORWARD_RESULT_FLAG used while also requesting a result&quot;); case ActivityManager.START_NOT_ACTIVITY: throw new IllegalArgumentException( &quot;PendingIntent is not an activity&quot;); default: throw new AndroidRuntimeException(&quot;Unknown error code &quot; + res + &quot; when starting &quot; + intent); &#125; &#125; 相信大家对上面的这些异常信息不陌生吧，其中最熟悉的非 Unable to find explicit activity class 莫属了，如果 Activity 没有在 AndroidMainfest.xml 注册，将会抛出此异常。 那么就得思考一个问题了，插件的 Activity 并未在宿主程序的 AndroidMainfest.xml 注册，要如何才能绕过这一层检测？ 前文中提到，com.didi.virtualapk.PluginManager 这个类的初始化的时候，除了 Hook 出一个 AMS 代理对象以外，还 Hook 出一个 Instrumentation 对象。代码如下： 1234567891011121314151617181920212223private void hookInstrumentationAndHandler() &#123; try &#123; Instrumentation baseInstrumentation = ReflectUtil.getInstrumentation(this.mContext); if (baseInstrumentation.getClass().getName().contains(&quot;lbe&quot;)) &#123; // reject executing in paralell space, for example, lbe. System.exit(0); &#125; // 创建自定义的 instrumentation，重写了 newActivity() 等一些方法 // baseInstrumentation 后面还会用到，也保存下来 final VAInstrumentation instrumentation = new VAInstrumentation(this, baseInstrumentation); // 获取 ActivityThread 的实例 Object activityThread = ReflectUtil.getActivityThread(this.mContext); // 用自定义的 instrumentation 替换掉 ActivityThread 里面的 instrumentation ReflectUtil.setInstrumentation(activityThread, instrumentation); ReflectUtil.setHandlerCallback(this.mContext, instrumentation); this.mInstrumentation = instrumentation; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 既然 Activity 的启动，中间走了 Instrumentation.execStartActivity 这个方法，那么我们大概可以知道，Hook 出一个 Instrumentation 对象用来做什么了，实际上就是用来帮助启动插件的 Activity。 启动插件Activity我们 Hook 了一个 VAInstrumentation 以替代系统的 Instrumentation，这样当系统通过 ActivityThread 调用 它的的成员变量 mInstrumentation 的 newActivity() 等方法的时候，实际是调用我们 VAInstrumentation 的 newActivity()。 实际上对于插件 Activity 启动，采用的是宿主 manifest 中占坑的方式来绕过系统校验，然后再加载真正的activity。 什么是占坑？就是构造一系列假的 Activity 替身，在 AndroidMainfest.xml 里面进行注册，以绕过检测，然后到了真正启动 Activity 的时候，再把它变回，去启动真正的目标 Activity。那么这一步是怎么做的呢？ 我们可以打开核心库里面的 AndroidMainfest.xml 看看： 12345678910111213141516171819202122232425262728293031323334353637&lt;application&gt; &lt;!-- Stub Activities --&gt; &lt;activity android:name=&quot;.A$1&quot; android:launchMode=&quot;standard&quot;/&gt; &lt;activity android:name=&quot;.A$2&quot; android:launchMode=&quot;standard&quot; android:theme=&quot;@android:style/Theme.Translucent&quot; /&gt; &lt;!-- Stub Activities --&gt; &lt;activity android:name=&quot;.B$1&quot; android:launchMode=&quot;singleTop&quot;/&gt; &lt;activity android:name=&quot;.B$2&quot; android:launchMode=&quot;singleTop&quot;/&gt; &lt;activity android:name=&quot;.B$3&quot; android:launchMode=&quot;singleTop&quot;/&gt; &lt;activity android:name=&quot;.B$4&quot; android:launchMode=&quot;singleTop&quot;/&gt; &lt;activity android:name=&quot;.B$5&quot; android:launchMode=&quot;singleTop&quot;/&gt; &lt;activity android:name=&quot;.B$6&quot; android:launchMode=&quot;singleTop&quot;/&gt; &lt;activity android:name=&quot;.B$7&quot; android:launchMode=&quot;singleTop&quot;/&gt; &lt;activity android:name=&quot;.B$8&quot; android:launchMode=&quot;singleTop&quot;/&gt; &lt;!-- Stub Activities --&gt; &lt;activity android:name=&quot;.C$1&quot; android:launchMode=&quot;singleTask&quot;/&gt; &lt;activity android:name=&quot;.C$2&quot; android:launchMode=&quot;singleTask&quot;/&gt; &lt;activity android:name=&quot;.C$3&quot; android:launchMode=&quot;singleTask&quot;/&gt; &lt;activity android:name=&quot;.C$4&quot; android:launchMode=&quot;singleTask&quot;/&gt; &lt;activity android:name=&quot;.C$5&quot; android:launchMode=&quot;singleTask&quot;/&gt; &lt;activity android:name=&quot;.C$6&quot; android:launchMode=&quot;singleTask&quot;/&gt; &lt;activity android:name=&quot;.C$7&quot; android:launchMode=&quot;singleTask&quot;/&gt; &lt;activity android:name=&quot;.C$8&quot; android:launchMode=&quot;singleTask&quot;/&gt; &lt;!-- Stub Activities --&gt; &lt;activity android:name=&quot;.D$1&quot; android:launchMode=&quot;singleInstance&quot;/&gt; &lt;activity android:name=&quot;.D$2&quot; android:launchMode=&quot;singleInstance&quot;/&gt; &lt;activity android:name=&quot;.D$3&quot; android:launchMode=&quot;singleInstance&quot;/&gt; &lt;activity android:name=&quot;.D$4&quot; android:launchMode=&quot;singleInstance&quot;/&gt; &lt;activity android:name=&quot;.D$5&quot; android:launchMode=&quot;singleInstance&quot;/&gt; &lt;activity android:name=&quot;.D$6&quot; android:launchMode=&quot;singleInstance&quot;/&gt; &lt;activity android:name=&quot;.D$7&quot; android:launchMode=&quot;singleInstance&quot;/&gt; &lt;activity android:name=&quot;.D$8&quot; android:launchMode=&quot;singleInstance&quot;/&gt;&lt;/application&gt; 可以发现，在清单里面注册了一堆假的 StubActivity。 ABCD分别对应不同的启动模式，那么，我们启动插件的 Activity 的时候，是如何把它改为清单里面已注册的这些假的 Activity 名呢？ 在 VAInstrumentation 里面，重写了 startActivity 的必经之路，就是 execStartActivity() 方法： 12345678910111213141516171819202122232425262728293031323334353637public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; // 这里面做了一系列操作，实际上就是查找插件里面第一个符合隐式条件的第一个ResolveInfo，并设置进intent mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent); // null component is an implicitly intent if (intent.getComponent() != null) &#123; Log.i(TAG, String.format(&quot;execStartActivity[%s : %s]&quot;, intent.getComponent().getPackageName(), intent.getComponent().getClassName())); // ！！！ 重头戏在这里，用那些注册的假的StubActivity来替换真实的Activity，以绕过检测 ！！！ this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent); &#125; ActivityResult result = realExecStartActivity(who, contextThread, token, target, intent, requestCode, options); return result;&#125;private ActivityResult realExecStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; ActivityResult result = null; try &#123; Class[] parameterTypes = &#123;Context.class, IBinder.class, IBinder.class, Activity.class, Intent.class, int.class, Bundle.class&#125;; result = (ActivityResult)ReflectUtil.invoke(Instrumentation.class, mBase, &quot;execStartActivity&quot;, parameterTypes, who, contextThread, token, target, intent, requestCode, options); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result;&#125; 那么，是如何替换 StubActivity 的呢？ 跟进代码： 123456789101112131415161718192021222324252627282930313233343536373839public void markIntentIfNeeded(Intent intent) &#123; if (intent.getComponent() == null) &#123; return; &#125; String targetPackageName = intent.getComponent().getPackageName(); String targetClassName = intent.getComponent().getClassName(); // 判断是否是启动插件的Activity if (!targetPackageName.equals(mContext.getPackageName()) &amp;&amp; mPluginManager.getLoadedPlugin(targetPackageName) != null) &#123; // 做标记 intent.putExtra(Constants.KEY_IS_PLUGIN, true); // 保存真实的意图 intent.putExtra(Constants.KEY_TARGET_PACKAGE, targetPackageName); intent.putExtra(Constants.KEY_TARGET_ACTIVITY, targetClassName); dispatchStubActivity(intent); &#125;&#125;/** * 真正的转换就在这里。根据启动模式，转换对应的 StubActivity */private void dispatchStubActivity(Intent intent) &#123; ComponentName component = intent.getComponent(); String targetClassName = intent.getComponent().getClassName(); LoadedPlugin loadedPlugin = mPluginManager.getLoadedPlugin(intent); ActivityInfo info = loadedPlugin.getActivityInfo(component); if (info == null) &#123; throw new RuntimeException(&quot;can not find &quot; + component); &#125; int launchMode = info.launchMode; // 临时替换主题 Resources.Theme themeObj = loadedPlugin.getResources().newTheme(); themeObj.applyStyle(info.theme, true); // 实际上就是这一句，完成转换 String stubActivity = mStubActivityInfo.getStubActivity(targetClassName, launchMode, themeObj); Log.i(TAG, String.format(&quot;dispatchStubActivity,[%s -&gt; %s]&quot;, targetClassName, stubActivity)); intent.setClassName(mContext, stubActivity);&#125; 继续跟进代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class StubActivityInfo &#123; public static final int MAX_COUNT_STANDARD = 1; public static final int MAX_COUNT_SINGLETOP = 8; public static final int MAX_COUNT_SINGLETASK = 8; public static final int MAX_COUNT_SINGLEINSTANCE = 8; public static final String corePackage = &quot;com.didi.virtualapk.core&quot;; // 这个格式，就是那些假的Activity的名字 public static final String STUB_ACTIVITY_STANDARD = &quot;%s.A$%d&quot;; public static final String STUB_ACTIVITY_SINGLETOP = &quot;%s.B$%d&quot;; public static final String STUB_ACTIVITY_SINGLETASK = &quot;%s.C$%d&quot;; public static final String STUB_ACTIVITY_SINGLEINSTANCE = &quot;%s.D$%d&quot;; public final int usedStandardStubActivity = 1; public int usedSingleTopStubActivity = 0; public int usedSingleTaskStubActivity = 0; public int usedSingleInstanceStubActivity = 0; private HashMap&lt;String, String&gt; mCachedStubActivity = new HashMap&lt;&gt;(); /** * 在这里根据启动模式及主题构造 StubActivity */ public String getStubActivity(String className, int launchMode, Theme theme) &#123; String stubActivity= mCachedStubActivity.get(className); if (stubActivity != null) &#123; return stubActivity; &#125; TypedArray array = theme.obtainStyledAttributes(new int[]&#123; android.R.attr.windowIsTranslucent, android.R.attr.windowBackground &#125;); boolean windowIsTranslucent = array.getBoolean(0, false); array.recycle(); if (Constants.DEBUG) &#123; Log.d(&quot;StubActivityInfo&quot;, &quot;getStubActivity, is transparent theme ? &quot; + windowIsTranslucent); &#125; stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity); switch (launchMode) &#123; case ActivityInfo.LAUNCH_MULTIPLE: &#123; stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity); if (windowIsTranslucent) &#123; stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, 2); &#125; break; &#125; case ActivityInfo.LAUNCH_SINGLE_TOP: &#123; usedSingleTopStubActivity = usedSingleTopStubActivity % MAX_COUNT_SINGLETOP + 1; stubActivity = String.format(STUB_ACTIVITY_SINGLETOP, corePackage, usedSingleTopStubActivity); break; &#125; case ActivityInfo.LAUNCH_SINGLE_TASK: &#123; usedSingleTaskStubActivity = usedSingleTaskStubActivity % MAX_COUNT_SINGLETASK + 1; stubActivity = String.format(STUB_ACTIVITY_SINGLETASK, corePackage, usedSingleTaskStubActivity); break; &#125; case ActivityInfo.LAUNCH_SINGLE_INSTANCE: &#123; usedSingleInstanceStubActivity = usedSingleInstanceStubActivity % MAX_COUNT_SINGLEINSTANCE + 1; stubActivity = String.format(STUB_ACTIVITY_SINGLEINSTANCE, corePackage, usedSingleInstanceStubActivity); break; &#125; default:break; &#125; mCachedStubActivity.put(className, stubActivity); return stubActivity; &#125;&#125; 到这一步，就基本清晰了。同样的，既然变为了 StubActivity，那么真正启动的时候还得变回来才行。来看一下重写后的 newActivity() 方法： 12345678910111213141516171819202122232425262728293031@Overridepublic Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; try &#123; cl.loadClass(className); &#125; catch (ClassNotFoundException e) &#123; // 根据 intent 类型，去获取相应的插件 LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent); // 这里就是从Intent中取出我们刚才保存的真正的意图 String targetClassName = PluginUtil.getTargetActivity(intent); Log.i(TAG, String.format(&quot;newActivity[%s : %s]&quot;, className, targetClassName)); if (targetClassName != null) &#123; // mBase 是未替换之前的 Instrumentation 对象，所以这个实际上是交给系统原先的 Instrumentation 对象去执行，所以这个模式其实也可以理解为与动态代理等同 // plugin.getClassLoader() 是自己构造的一个 DexClassLoader，专门用于加载对应的apk里面的类 Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent); activity.setIntent(intent); try &#123; // for 4.1+ ReflectUtil.setField(ContextThemeWrapper.class, activity, &quot;mResources&quot;, plugin.getResources()); &#125; catch (Exception ignored) &#123; // ignored. &#125; return activity; &#125; &#125; return mBase.newActivity(cl, className, intent);&#125; 到这里，插件的 Activity 启动流程分析，就基本结束了。细节方面，没法一步到位，还需要大家边看源码边理解，这样才能看得更透彻。 Service 支持对于 Service 的支持，采用动态代理AMS，拦截 Service 相关的请求，将其中转给Service Runtime去处理，Service Runtime会接管系统的所有操作。 对于我们动态代理AMS，在上一节 Activity支持 中已经介绍过了，那么，简单的来看一下 ActivityManagerProxy 是如何启动一个Service的。 在执行 startService 等方法的时候，AMS 代理对象会相应的来执行以下这些方法： 123456789101112131415161718192021222324252627282930313233343536373839private Object startService(Object proxy, Method method, Object[] args) throws Throwable &#123; IApplicationThread appThread = (IApplicationThread) args[0]; Intent target = (Intent) args[1]; ResolveInfo resolveInfo = this.mPluginManager.resolveService(target, 0); if (null == resolveInfo || null == resolveInfo.serviceInfo) &#123; // is host service return method.invoke(this.mActivityManager, args); &#125; return startDelegateServiceForTarget(target, resolveInfo.serviceInfo, null, RemoteService.EXTRA_COMMAND_START_SERVICE);&#125;private ComponentName startDelegateServiceForTarget(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) &#123; Intent wrapperIntent = wrapperTargetIntent(target, serviceInfo, extras, command); return mPluginManager.getHostContext().startService(wrapperIntent);&#125;private Intent wrapperTargetIntent(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) &#123; // fill in service with ComponentName target.setComponent(new ComponentName(serviceInfo.packageName, serviceInfo.name)); String pluginLocation = mPluginManager.getLoadedPlugin(target.getComponent()).getLocation(); // 这里进行判断，看是交给 LocalService，还是 RemoteService 处理 // LocalService 和 RemoteService 分别对应是否在新的进程中启动Activity boolean local = PluginUtil.isLocalService(serviceInfo); Class&lt;? extends Service&gt; delegate = local ? LocalService.class : RemoteService.class; Intent intent = new Intent(); intent.setClass(mPluginManager.getHostContext(), delegate); intent.putExtra(RemoteService.EXTRA_TARGET, target); // 保存一下这个的Command,对应执行不同操作 intent.putExtra(RemoteService.EXTRA_COMMAND, command); intent.putExtra(RemoteService.EXTRA_PLUGIN_LOCATION, pluginLocation); if (extras != null) &#123; intent.putExtras(extras); &#125; return intent;&#125; 实际上包括我们调用 stopService()，AMS 代理对象最后变换后的意图，同样也是上面代码的最后两个个方法 startDelegateServiceForTarget 和 wrapperTargetIntent()，只不过 command 不一样。 所以本质上 AMS 作为代理，不管你执行启动或者关闭插件里面的 Service，他都是调用 LocalService 或者 RemoteService 的 startService 方法，在 LocalService 或者 RemoteService 的 onStartCommand() 下，根据 command 进行相应的操作。那么我们来看一下 LocalService 的 onStartCommand() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; if (null == intent || !intent.hasExtra(EXTRA_TARGET) || !intent.hasExtra(EXTRA_COMMAND)) &#123; return START_STICKY; &#125; Intent target = intent.getParcelableExtra(EXTRA_TARGET); int command = intent.getIntExtra(EXTRA_COMMAND, 0); if (null == target || command &lt;= 0) &#123; return START_STICKY; &#125; ComponentName component = target.getComponent(); LoadedPlugin plugin = mPluginManager.getLoadedPlugin(component); switch (command) &#123; case EXTRA_COMMAND_START_SERVICE: &#123; ActivityThread mainThread = (ActivityThread)ReflectUtil.getActivityThread(getBaseContext()); IApplicationThread appThread = mainThread.getApplicationThread(); Service service; if (this.mPluginManager.getComponentsHandler().isServiceAvailable(component)) &#123; service = this.mPluginManager.getComponentsHandler().getService(component); &#125; else &#123; try &#123; service = (Service) plugin.getClassLoader().loadClass(component.getClassName()).newInstance(); Application app = plugin.getApplication(); IBinder token = appThread.asBinder(); Method attach = service.getClass().getMethod(&quot;attach&quot;, Context.class, ActivityThread.class, String.class, IBinder.class, Application.class, Object.class); IActivityManager am = mPluginManager.getActivityManager(); attach.invoke(service, plugin.getPluginContext(), mainThread, component.getClassName(), token, app, am); service.onCreate(); this.mPluginManager.getComponentsHandler().rememberService(component, service); &#125; catch (Throwable t) &#123; return START_STICKY; &#125; &#125; service.onStartCommand(target, 0, this.mPluginManager.getComponentsHandler().getServiceCounter(service).getAndIncrement()); break; &#125; case EXTRA_COMMAND_BIND_SERVICE: &#123; ActivityThread mainThread = (ActivityThread)ReflectUtil.getActivityThread(getBaseContext()); IApplicationThread appThread = mainThread.getApplicationThread(); Service service = null; if (this.mPluginManager.getComponentsHandler().isServiceAvailable(component)) &#123; service = this.mPluginManager.getComponentsHandler().getService(component); &#125; else &#123; try &#123; service = (Service) plugin.getClassLoader().loadClass(component.getClassName()).newInstance(); Application app = plugin.getApplication(); IBinder token = appThread.asBinder(); Method attach = service.getClass().getMethod(&quot;attach&quot;, Context.class, ActivityThread.class, String.class, IBinder.class, Application.class, Object.class); IActivityManager am = mPluginManager.getActivityManager(); attach.invoke(service, plugin.getPluginContext(), mainThread, component.getClassName(), token, app, am); service.onCreate(); this.mPluginManager.getComponentsHandler().rememberService(component, service); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; try &#123; IBinder binder = service.onBind(target); IBinder serviceConnection = PluginUtil.getBinder(intent.getExtras(), &quot;sc&quot;); IServiceConnection iServiceConnection = IServiceConnection.Stub.asInterface(serviceConnection); iServiceConnection.connected(component, binder); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; break; &#125; case EXTRA_COMMAND_STOP_SERVICE: &#123; Service service = this.mPluginManager.getComponentsHandler().forgetService(component); if (null != service) &#123; try &#123; service.onDestroy(); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;Unable to stop service &quot; + service + &quot;: &quot; + e.toString()); &#125; &#125; else &#123; Log.i(TAG, component + &quot; not found&quot;); &#125; break; &#125; case EXTRA_COMMAND_UNBIND_SERVICE: &#123; Service service = this.mPluginManager.getComponentsHandler().forgetService(component); if (null != service) &#123; try &#123; service.onUnbind(target); service.onDestroy(); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;Unable to unbind service &quot; + service + &quot;: &quot; + e.toString()); &#125; &#125; else &#123; Log.i(TAG, component + &quot; not found&quot;); &#125; break; &#125; &#125; return START_STICKY;&#125; 很显然，在这里面才对应去控制了插件Service的生命周期。具体代码就留给大家分析吧~~ ContentProvider 支持动态代理 IContentProvider，拦截provider相关的请求，将其中转给Provider Runtime去处理，Provider Runtime会接管系统的所有操作。 我们来看一下 com.didi.virtualapk.internal.PluginContentResolver 这个类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class PluginContentResolver extends ContentResolver &#123; private ContentResolver mBase; private PluginManager mPluginManager; private static Method sAcquireProvider; private static Method sAcquireExistingProvider; private static Method sAcquireUnstableProvider; static &#123; try &#123; sAcquireProvider = ContentResolver.class.getDeclaredMethod(&quot;acquireProvider&quot;, new Class[]&#123;Context.class, String.class&#125;); sAcquireProvider.setAccessible(true); sAcquireExistingProvider = ContentResolver.class.getDeclaredMethod(&quot;acquireExistingProvider&quot;, new Class[]&#123;Context.class, String.class&#125;); sAcquireExistingProvider.setAccessible(true); sAcquireUnstableProvider = ContentResolver.class.getDeclaredMethod(&quot;acquireUnstableProvider&quot;, new Class[]&#123;Context.class, String.class&#125;); sAcquireUnstableProvider.setAccessible(true); &#125; catch (Exception e) &#123; //ignored &#125; &#125; public PluginContentResolver(Context context) &#123; super(context); mBase = context.getContentResolver(); mPluginManager = PluginManager.getInstance(context); &#125; protected IContentProvider acquireProvider(Context context, String auth) &#123; try &#123; if (mPluginManager.resolveContentProvider(auth, 0) != null) &#123; // 在这里，去 hook 一个 IContentProvider 代理对象 return mPluginManager.getIContentProvider(); &#125; return (IContentProvider) sAcquireProvider.invoke(mBase, context, auth); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; // ...&#125; 这个类是在构造 LoadedPlugin 的时候创建的 PluginContext 对象里面的 getContentResolver() 里面创建的。 123456789101112131415class PluginContext extends ContextWrapper &#123; private final LoadedPlugin mPlugin; public PluginContext(LoadedPlugin plugin) &#123; super(plugin.getPluginManager().getHostContext()); this.mPlugin = plugin; &#125; @Override public ContentResolver getContentResolver() &#123; // 创建代理支持 return new PluginContentResolver(getHostContext()); &#125;&#125; 那么，上面Hook 的 IContentProvider 代理对象，实际上是在 PluginManager 做的。 123456789101112131415161718192021222324252627282930313233343536373839private void hookIContentProviderAsNeeded() &#123; Uri uri = Uri.parse(PluginContentResolver.getUri(mContext)); mContext.getContentResolver().call(uri, &quot;wakeup&quot;, null, null); try &#123; Field authority = null; Field mProvider = null; ActivityThread activityThread = (ActivityThread) ReflectUtil.getActivityThread(mContext); Map mProviderMap = (Map) ReflectUtil.getField(activityThread.getClass(), activityThread, &quot;mProviderMap&quot;); Iterator iter = mProviderMap.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue(); String auth; if (key instanceof String) &#123; auth = (String) key; &#125; else &#123; if (authority == null) &#123; authority = key.getClass().getDeclaredField(&quot;authority&quot;); authority.setAccessible(true); &#125; auth = (String) authority.get(key); &#125; if (auth.equals(PluginContentResolver.getAuthority(mContext))) &#123; if (mProvider == null) &#123; mProvider = val.getClass().getDeclaredField(&quot;mProvider&quot;); mProvider.setAccessible(true); &#125; IContentProvider rawProvider = (IContentProvider) mProvider.get(val); IContentProvider proxy = IContentProviderProxy.newInstance(mContext, rawProvider); mIContentProvider = proxy; Log.d(TAG, &quot;hookIContentProvider succeed : &quot; + mIContentProvider); break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 这一块的内容，最好根据滴滴提供的Demo，再来看，比较容易理解。 1234Uri bookUri = Uri.parse(&quot;content://com.ryg.chapter_2.book.provider/book&quot;);ContentValues values = new ContentValues();values.put(&quot;_id&quot;, 6);values.put(&quot;name&quot;, &quot;程序设计的艺术&quot;); Receiver 支持官方解释是将插件中静态注册的receiver重新注册一遍。在代码里貌似没找到相应的支持，Demo 里也没有，或许这部分还没完成吧？？ 小结本文重点在于分析插件的 Activity 启动流程，其他包括主题、资源，并没有详细分析，因为说细了内容还是有点多了，主要是让大伙儿在阅读代码时，有个大致的方向。有疑问欢迎一起探讨哟~~ 感谢阅读！","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/tags/Android/"},{"name":"VirtualAPK","slug":"VirtualAPK","permalink":"http://smuyyh.top/tags/VirtualAPK/"}]},{"title":"从源码的角度解析Handler、Looper、Message和MessageQueue","slug":"android-handler-message-looper","date":"04/07/2017","updated":"30/10/2023","comments":true,"path":"2017/07/04/android-handler-message-looper/","link":"","permalink":"http://smuyyh.top/2017/07/04/android-handler-message-looper/","excerpt":"导语虽然很基础的一个东西，然是最近面试中还是常常最被问到，而且都是到源码层，因此决定再造一次轮子！","text":"导语虽然很基础的一个东西，然是最近面试中还是常常最被问到，而且都是到源码层，因此决定再造一次轮子！ 作为一名Android程序猿，想必在最开始都碰到这么一个问题，就是在子线程中弹出一个 Toast，会抛出以下的异常： 1234567java.lang.RuntimeException: Can&#x27;t create handler inside thread that has not called Looper.prepare() at android.os.Handler.&lt;init&gt;(Handler.java:121) at android.widget.Toast$TN.&lt;init&gt;(Toast.java:322) at android.widget.Toast.&lt;init&gt;(Toast.java:91) at android.widget.Toast.makeText(Toast.java:238) at com.example.testapp.MyActivity$MyAsyncTask.doInBackground(MyActivity.java:25) at com.example.testapp.MyActivity$MyAsyncTask.doInBackground(MyActivity.java:21) 按传统的说法就是 Toast 只能在UI线程中显示，实际上不是的，应该是 Toast 只能在带有 Looper 的线程中显示。 另一个常见的场景，就是在子线程创建一个 Handler 也会抛出与上述一样的异常： 12Java.lang.RuntimeException: Can&#x27;t create handler inside thread that has not called Looper.prepare() at android.os.Handler.&lt;init&gt;(Handler.java:121) 而在主线程为什么不会有该异常呢？这就是源码的东西了，在程序入口方法已经调用过以下代码，来创建一个主线程了： 123456Looper.prepareMainLooper();ActivityThread thread = new ActivityThread();thread.attach(false);Looper.loop(); 这个时候疑问就来了，什么是 Looper? 先来看一张图，初步了解一下 Handler、Looper、Message、MessageQueue 之间的关系 对于一个线程来说，Handler 允许发送和处理与该线程的 MessageQueue 相关联的 Message 或 Runnable 对象。每一个 Handler 实例与单个线程的 MessageQueue 相关联。 当我们创建一个 Handler 实例的时候，它将会绑定到当前所处的线程及其对应的消息队列，然后就是往消息队列里面传递消息或者 Runabble 对象，并在消息队列中取出消息来处理，或者取出 Runnable 对象进行执行！ HandlerHandler 作用从本质上来讲，Handler 主要有以下两个作用 调度消息和runnable对象去被执行，换句话说，就是在同一个线程中处理一些消息 使得某个消息动作在不同线程中执行，也就是往其他线程的消息队列里插入消息 消息的调度主要有以下几种方式： post（Runnable） postAtTime（Runnable，long） postDelayed（Runnable，long） sendMessage（Message） sendMessageAtTime（Message，long） sendMessageDelayed（Message，long） sendEmptyMessage（int） sendEmptyMessageAtTime(int, long) sendEmptyMessageDelayed（int, long） 最后实际上都是调用 sendEmptyMessageAtTime(Message，long) 方法 从上面的这些方法中可以看出： post开头的几个方法，允许将 Runnable 对象插入到消息队列以便调用。 sendMessage 对应的几个方法，可以将 Message 插入到 MessageQueue，然后通过 Handler 的 handleMessage 方法来处理相应的消息。 MessageMessage 结构Message 类主要包含以下几个参数 123456789public int what; // sendEmptyMessage 里面的 what，在 handleMessage 方法可以对不同的 Message.what 值做相应处理。public Object obj; // Message 可以携带一个对象Handler target; // 处理该消息的HandlerMessage next;Runnable callback; // 消息处理动作 1、从next参数可知，消息队列实际上是一个链表结构； 2、来看一下 Handler 的 dispatchMessage 方法： 123456789101112131415/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 从中我们可以知道，如果 Message 有定义 callback，那么消息处理会交由callback 去执行，否则，交由 Handler 的 handleMessage 去执行。 Message 创建及发送一般发送一条消息，我们会调用一下代码： 1handler.obtainMessage(int what, Object obj).sendToTarget(); 那么，我们就简单分析一下消息创建的流程 1、Handler.obtainMessage 1234public final Message obtainMessage(int what, Object obj)&#123; return Message.obtain(this, what, obj);&#125; 2、 Message.obtain 创建消息 12345678public static Message obtain(Handler h, int what, Object obj) &#123; Message m = obtain(); m.target = h; // 指定了处理消息的Handler m.what = what; m.obj = obj; return m;&#125; 3、 Message.sendToTarget 发送消息 123public void sendToTarget() &#123; target.sendMessage(this); // 调用 Handler的sendMessage&#125; 4、Handler.sendMessage(Message) 发送消息，最后实际上是调用sendMessageAtTime方法，往MessageQueue里面插入一条消息 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 至此，消息就发送完毕，也就是插入到了消息队列里面，接下来就是由消息队列处理了。 MessageQueueMessageQueue 结构123456789private final boolean mQuitAllowed; // 是否允许MessageQueue退出；private long mPtr; // MessageQueue 是通过调用 C++ native MessageQueue 实现的，这个 mPtr 就是指向 native MessageQueue；Message mMessages; // 表示存储消息链表的 Headprivate boolean mQuitting; // 当前MessageQueue是否正在终止；private boolean mBlocked; // 表示next()方法调用是否被block在timeout不为0的pollOnce上； MessageQueue 主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别是 enqueueMessage() 和 next()。 插入消息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; // 插入到链表的头部，条件：链表为null或者当前消息的对应的触发时间比链表头的触发时间小，也就是比链表头早执行 if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // 通过触发时间，将消息插入到队列中合适的位置 // 如果需要唤醒线程处理则调用C++中的nativeWake()函数. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; // 执行链表插入 msg.next = p; prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 读取消息消息循环读取，是在 Looper.loop() 方法调用之后，最后来执行 MessageQueue.next() 方法，我们来看一下该方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; // 无限循环，往消息队列里面取消息 for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // 过滤掉同步消息 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 还未达到下一条消息的触发时间，为下一条待处理的消息设置就绪时间 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 通过上面源码可知： 首先会去判断handler是否为null，是的话就跳过所有的同步消息，查找到需要最先处理的异步消息。如果第一个待处理的消息还没有到要触发时间，则设置激活等待时间；否则这个消息就是需要处理的消息，将该消息设置为 inuse状态，并将队列设置为非 blocked 状态，然后返回该消息。 next() 方法是一个无限循环的方法，如果消息队列中没有消息，那么 next() 方法会一直阻塞，当有新消息到来时，next() 会将这条消息返回同时也将这条消息从链表中移除。 Looper首先，在理解 Looper 之前，我们需要稍微了解一下 ThreadLocal 这个类。 ThreadLocal 是用于为每个线程创建一个单独的变量副本，提供了保持对象的方法和避免参数传递的复杂性。ThreadLocal 类有一个泛型参数，设置了保存到 ThreadLocal 容器中的数据类型。 实际上在 ThreadLocal 类中有一个静态内部类 ThreadLocalMap (其类似于Map)，用键值对的形式存储每一个线程的变量副本，ThreadLocalMap 中元素的key为当前 ThreadLocal 对象，而value对应线程的变量副本，每个线程可能存在多个 ThreadLocal。 那么，在 Looper 中，也存储该着为每个线程单独创建的 ThreadLocal，里面保存着该线程对应的 Looper。 Looper 创建我们来看一下 Looper.prepare() 方法： 1234567891011121314static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; // 这也就意味着 prepare 方法，创建了当前线程的一个 Looper，并且每个线程 只能创建一次 throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; Looper 开启循环来看一下 Looper.loop() 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; // 进入当前线程的消息循环 final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; // 从队列中取出一条消息 Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; // 分发消息给 Handler 处理 msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // 回收释放 msg.recycleUnchecked(); &#125;&#125; 线程阻塞问题细心的童鞋就会有个疑问，主线程对应的这个 Looper，在调用 Looper.loop() 方法之后，开启了无限死循环，那么为什么不会造成线程阻塞，导致 UI 动不了？ 这个问题实际上就需要了解一下 Activity 的启动过程了。这里就不细说了，主要先了解一下 ActivityThread.H 这个类，它是继承于 Handler，我们可以看一下他的消息处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128private final class H extends Handler &#123; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + msg.what); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; ActivityClientRecord r = (ActivityClientRecord)msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo); handleLaunchActivity(r, null); &#125; break; case RELAUNCH_ACTIVITY: &#123; ActivityClientRecord r = (ActivityClientRecord)msg.obj; handleRelaunchActivity(r, msg.arg1); &#125; break; case PAUSE_ACTIVITY: handlePauseActivity((IBinder)msg.obj, false, msg.arg1 != 0, msg.arg2); maybeSnapshot(); break; case PAUSE_ACTIVITY_FINISHING: handlePauseActivity((IBinder)msg.obj, true, msg.arg1 != 0, msg.arg2); break; case STOP_ACTIVITY_SHOW: handleStopActivity((IBinder)msg.obj, true, msg.arg2); break; case STOP_ACTIVITY_HIDE: handleStopActivity((IBinder)msg.obj, false, msg.arg2); break; case SHOW_WINDOW: handleWindowVisibility((IBinder)msg.obj, true); break; case HIDE_WINDOW: handleWindowVisibility((IBinder)msg.obj, false); break; case RESUME_ACTIVITY: handleResumeActivity((IBinder)msg.obj, true, msg.arg1 != 0); break; case SEND_RESULT: handleSendResult((ResultData)msg.obj); break; case DESTROY_ACTIVITY: handleDestroyActivity((IBinder)msg.obj, msg.arg1 != 0, msg.arg2, false); break; case BIND_APPLICATION: AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); break; case EXIT_APPLICATION: if (mInitialApplication != null) &#123; mInitialApplication.onTerminate(); &#125; Looper.myLooper().quit(); break; case NEW_INTENT: handleNewIntent((NewIntentData)msg.obj); break; case RECEIVER: handleReceiver((ReceiverData)msg.obj); maybeSnapshot(); break; case CREATE_SERVICE: handleCreateService((CreateServiceData)msg.obj); break; case BIND_SERVICE: handleBindService((BindServiceData)msg.obj); break; case UNBIND_SERVICE: handleUnbindService((BindServiceData)msg.obj); break; case SERVICE_ARGS: handleServiceArgs((ServiceArgsData)msg.obj); break; case STOP_SERVICE: handleStopService((IBinder)msg.obj); maybeSnapshot(); break; case REQUEST_THUMBNAIL: handleRequestThumbnail((IBinder)msg.obj); break; case CONFIGURATION_CHANGED: handleConfigurationChanged((Configuration)msg.obj); break; case CLEAN_UP_CONTEXT: ContextCleanupInfo cci = (ContextCleanupInfo)msg.obj; cci.context.performFinalCleanup(cci.who, cci.what); break; case GC_WHEN_IDLE: scheduleGcIdler(); break; case DUMP_SERVICE: handleDumpService((DumpServiceInfo)msg.obj); break; case LOW_MEMORY: handleLowMemory(); break; case ACTIVITY_CONFIGURATION_CHANGED: handleActivityConfigurationChanged((IBinder)msg.obj); break; case PROFILER_CONTROL: handleProfilerControl(msg.arg1 != 0, (ProfilerControlData)msg.obj); break; case CREATE_BACKUP_AGENT: handleCreateBackupAgent((CreateBackupAgentData)msg.obj); break; case DESTROY_BACKUP_AGENT: handleDestroyBackupAgent((CreateBackupAgentData)msg.obj); break; case SUICIDE: Process.killProcess(Process.myPid()); break; case REMOVE_PROVIDER: completeRemoveProvider((IContentProvider)msg.obj); break; case ENABLE_JIT: ensureJitEnabled(); break; case DISPATCH_PACKAGE_BROADCAST: handleDispatchPackageBroadcast(msg.arg1, (String[])msg.obj); break; case SCHEDULE_CRASH: throw new RemoteServiceException((String)msg.obj); &#125; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&lt;&lt;&lt; done: &quot; + msg.what); &#125;&#125; 那么，对于创建一个Service来说，我们看一下 ApplicationThread 的调度： 1234567891011public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; // 发送创建 Service 的消息 sendMessage(H.CREATE_SERVICE, s);&#125; 不难看出，实际上创建 &#96;&#96;&#96;Service、包括执行其生命周期，最后都是交由 ActivityThread.H 处理，包括 Activity 的生命周期，也是一样，所以 Looper 虽然死循环，但是本质上我们UI的展示、更新，也是通过 Handler 来处理了，所以并不会造成真正的UI阻塞。 所以，简单来讲，ActivityThread 实际上就是开启了一个消息循环，来执行 Activity、Service 等等的相关操作，一旦这个消息循环停止了，则意味着App进程也结束了。 但是，如果 handlerMessage 是在主线程执行，其处理尽可能不要执行耗时操作，避免UI卡顿或发生 ANR。 结语最后，再回过头去看看前文中的那张图，相信你就能基本理解了！ 感谢阅读！","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"Handler","slug":"Handler","permalink":"http://smuyyh.top/tags/Handler/"},{"name":"Message","slug":"Message","permalink":"http://smuyyh.top/tags/Message/"},{"name":"Looper","slug":"Looper","permalink":"http://smuyyh.top/tags/Looper/"}]},{"title":"HashMap 内部原理","slug":"java-hashmap-source","date":"06/04/2017","updated":"30/10/2023","comments":true,"path":"2017/04/06/java-hashmap-source/","link":"","permalink":"http://smuyyh.top/2017/04/06/java-hashmap-source/","excerpt":"HashMap 内部实现通过名字便可知道的是，HashMap 的原理就是散列。HashMap内部维护一个 Buckets 数组，每个 Bucket 封装为一个 Entry&lt;K, V&gt; 键值对形式的链表结构，这个 Buckets 数组也称为表。表的索引是 密钥K 的散列值（散列码）。如下图所示：","text":"HashMap 内部实现通过名字便可知道的是，HashMap 的原理就是散列。HashMap内部维护一个 Buckets 数组，每个 Bucket 封装为一个 Entry&lt;K, V&gt; 键值对形式的链表结构，这个 Buckets 数组也称为表。表的索引是 密钥K 的散列值（散列码）。如下图所示： 链表的每个节点是一个名为 Entry&lt;K，V&gt; 的类的实例。 Entry 类实现了 Map.Entry 接口，下面是Entry类的代码： 123456private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; final int hash; V value; Entry&lt;K,V&gt; next;&#125; 注： 每个 Entry 对象仅与一个特定 key 相关联，但其 value 是可以改变的（如果相同的 key 之后被重新插入不同的 value） - 因此键是最终的，而值不是。 每个Entry对象都有一个名为 next 的字段，它指向下一个Entry，所以实际上为单链表结构。hash 字段存储了 Entry 对象在 Buckets 数组索引，也就是 key 的散列值。 如果发生Hash碰撞，也就是两个key的hash值相同，或者如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最早加入的放在链尾。 影响 HashMap 性能的两个因素是初始容量和负载因子。容量是表数组的长度，初始容量只是创建哈希表时的容量。负载因子是衡量哈希表在容量自动增加之前是否允许获取的量度（比例）。 当散列表中的 Entry 数量超过负载因子和当前容量的乘积时，将会重新散列该表（也就是重建内部数据结构），使得散列表具有大约两倍的容量（这个其实和ArrayList类似）。 理解 put() 方法123456789101112131415161718192021222324public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); // 计算hash值 int i = indexFor(hash, table.length); // 计算在数组中的索引 // 遍历链表 for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // hash值相同并且key相等，就直接替换 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); // 否则就添加到链表 return null;&#125; 注：这个计算出来的hash值被传递给内部哈希函数，哈希函数将返回密钥的散列值。这个值就是 bucket/数组 的索i引。 1234static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;; return h &amp; (length-1); &#125; 这里就有个疑问了，我们如何计算对应存储数组索引，首先想到的就是把hashcode对数组长度取模运算，也就是h%length,这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那中？ 首先算得key得hashcode值，然后跟数组的长度-1做一次“与”运算（&amp;）。看上去很简单，其实比较有玄机。比如数组的长度是2的4次方，那么hashcode就会和2的4次方-1做“与”运算。很多人都有这个疑问，为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高，我以2的4次方举例，来解释一下为什么数组大小为2的幂时hashmap访问的性能最高。 如下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ 上图参考自：http://blog.csdn.net/oqqYeYi/article/details/39831029 理解 get() 方法12345678910111213141516171819202122232425public V get(Object key) &#123; if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue(); &#125; final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key); // 计算hash值 // 根据索引遍历链表，找出相等的key for (HashMapEntry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; get 与 put 总结下面总结了 put() 和 get() 发生的三个重要步骤： 通过调用 计算 Hash Code 方法计算密钥的哈希码。 将计算的散列码传递到内部散列函数indexFor()以获取表的索引。 迭代通过在索引处出现的链表，并调用 equals() 方法来查找匹配键。 所以在这之前要先理解 equals() 和 hashCode() 这两个方法。 在 Java8 中的改善在Java 8中，对HashMap有一个性能上的改进。当密钥中存在许多哈希冲突（不同的密钥最终具有相同的哈希值或索引）时，平衡树将用于存储 Entry 对象，而不是链表。做法是，一旦 bucket 中的 Entry 数量增长超过某一阈值，则 bucket 将从 Entry 链表切换到平衡树。","categories":[{"name":"Java","slug":"Java","permalink":"http://smuyyh.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://smuyyh.top/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"http://smuyyh.top/tags/HashMap/"}]},{"title":"Android 7.1.1 之实现 3D Touch","slug":"android-26-3d-touch","date":"03/04/2017","updated":"06/09/2017","comments":true,"path":"2017/04/03/android-26-3d-touch/","link":"","permalink":"http://smuyyh.top/2017/04/03/android-26-3d-touch/","excerpt":"Shortcut概念Shortcut 是Android-25（Android 7.1）新增的一项类似iOS的 3D Touch 功能的快捷方式组件，但是有着不同的表现形式，因为Android在硬件上不支持触摸压力感应，所以表现形式为长按，而iOS须用力长按。","text":"Shortcut概念Shortcut 是Android-25（Android 7.1）新增的一项类似iOS的 3D Touch 功能的快捷方式组件，但是有着不同的表现形式，因为Android在硬件上不支持触摸压力感应，所以表现形式为长按，而iOS须用力长按。 首先，来个效果图 &nbsp;&nbsp;&nbsp; 在 Launcher 或 应用程序列表 里面，长按应用图标，弹出一个快捷方式列表， 并且，可以把单个快捷方式拖动出来作为一个桌面图标，拖出来的图标会随着清除应用数据或卸载应用而消失，须重新创建。 具体实现BuildConfig 配置在主module下，修改 build.grade，使其使用 android-25 的 API 编译，当然，未下载的，就需要打开Android SDK Manager下载一下。 12345678android &#123; compileSdkVersion 25 buildToolsVersion &quot;25.0.0&quot; // 或以上 defaultConfig &#123; targetSdkVersion 25 &#125;&#125; 静态配置类似BroadCastReceiver，Shortcut注册也分为静态注册和动态注册，首先介绍静态注册，动态注册后面继续~~ 在 res&#x2F;xml 文件夹底下创建一个xml，举个栗子：shortcut.xml 1234567891011121314151617181920212223242526272829 &lt;shortcuts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;shortcut android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/ic_bar_detail_write&quot; android:shortcutDisabledMessage=&quot;@string/shortcut_publish&quot; android:shortcutId=&quot;publish&quot; android:shortcutLongLabel=&quot;@string/shortcut_publish&quot; android:shortcutShortLabel=&quot;@string/shortcut_publish&quot;&gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:targetClass=&quot;com.yanshi.writing.ui.bar.PublishPostActivity&quot; android:targetPackage=&quot;com.yanshi.writing&quot; /&gt; &lt;categories android:name=&quot;android.shortcut.conversation&quot; /&gt; &lt;/shortcut&gt; &lt;shortcut android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/logo&quot; android:shortcutDisabledMessage=&quot;@string/shortcut_write&quot; android:shortcutId=&quot;write&quot; android:shortcutLongLabel=&quot;@string/shortcut_write&quot; android:shortcutShortLabel=&quot;@string/shortcut_write&quot;&gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:targetClass=&quot;com.yanshi.writing.ui.write.WriteActivity&quot; android:targetPackage=&quot;com.yanshi.writing&quot; /&gt; &lt;categories android:name=&quot;android.shortcut.conversation&quot; /&gt; &lt;/shortcut&gt;&lt;/shortcuts&gt; 1、enabled：表示当前快捷方式是否可使用 2、 icon： 快捷方式图标 3、 shortcutDisabledMessage： 快捷方式不可使用时显示的名字 4、 shortcutId：快捷方式标识 5、 shortcutLongLabel：长按下图标弹出来列表框中每个快捷名 6、 shortcutShortLabel：快捷是可以单独显示在桌面上的，显示名为shortcutShortLabel 7、 targetClass：点击快捷方式进入的Activity 8、categories 默认写死即可 清单文件注册 在 AndroidMainfest.xml 的默认启动页里添加 meta-data 标签配置 123456789101112131415&lt;activity android:name=&quot;.ui.MainActivity&quot; android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoneTranslucent&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.app.shortcuts&quot; android:resource=&quot;@xml/shortcut&quot; /&gt; &lt;/activity&gt; 完毕！ 可以到桌面查看效果了~~ 动态配置动态创建增加了菜单配置的灵活性，比如可以从服务端拉取快捷方式列表，再进行展示。具体配置方法如下： 创建在需要注册的地方添加如下代码： 1234567891011121314151617181920212223242526272829/** * 动态创建 */ public void register() &#123; ShortcutManager mShortcutManager = getSystemService(ShortcutManager.class); List&lt;ShortcutInfo&gt; infos = new ArrayList&lt;&gt;(); // 按下返回按钮跳转的activity Intent intent1 = new Intent(this, MainActivity.class); intent1.setAction(Intent.ACTION_VIEW); // 目标activity Intent intent2 = new Intent(this, PublishPostActivity.class); intent2.setAction(&quot;com.yuyh.xxx.BACK&quot;); Intent[] intents = new Intent[2]; intents[0] = intent1; intents[1] = intent2; ShortcutInfo info = new ShortcutInfo.Builder(this, &quot;publish-2&quot;) .setShortLabel(&quot;动态创建-发布帖子&quot;) .setLongLabel(&quot;动态创建-发布帖子&quot;) .setIcon(Icon.createWithResource(this, R.mipmap.ic_bar_detail_write)) .setIntents(intents) .build(); infos.add(info); mShortcutManager.setDynamicShortcuts(infos); &#125; 重新运行app，再次长按，效果如下： 删除或禁用动态删除可以删除动态配置的快捷方式。 1234567891011121314151617181920212223242526272829303132/** * 动态删除 */public void delete() &#123; ShortcutManager mShortcutManager = getSystemService(ShortcutManager.class); /********* 移除弹出列表图标 **********/ // 所有动态创建图标 List&lt;ShortcutInfo&gt; infos1 = mShortcutManager.getDynamicShortcuts(); List&lt;String&gt; ids1 = new ArrayList&lt;&gt;(); for (ShortcutInfo info : infos1 ) &#123; ids1.add(info.getId()); &#125; // 禁用所有的快捷方式 mShortcutManager.disableShortcuts(ids1, &quot;已禁用&quot;); mShortcutManager.removeDynamicShortcuts(ids1); /********* 移除拖出来的桌面快捷图标 **********/ // 放在桌面的图标 List&lt;ShortcutInfo&gt; infos2 = mShortcutManager.getPinnedShortcuts(); List&lt;String&gt; ids2 = new ArrayList&lt;&gt;(); for (ShortcutInfo info : infos2 ) &#123; ids2.add(info.getId()); &#125; mShortcutManager.disableShortcuts(ids2, &quot;已禁用&quot;); mShortcutManager.removeAllDynamicShortcuts();&#125; 代码比较简单，就不多做叙述了。 须注意一下 getPinnedShortcuts 方法与 getDynamicShortcuts 方法的区别！ 禁用后的效果如图所示，图标变成灰色： 更新快捷方式的唯一性，由前面提到的 shortcutId 这个标识符决定，所以更新快捷方式与创建快捷方式一样， shortcutId 如果相同， 则会覆盖之前创建的快捷方式！ 返回栈问题当通过快捷方式打开时，现有的Activity都会被销毁，然后重新创建一个Activity栈。因为清单方式设置的快捷键的Intent不能自定义Intent的Flag,其默认的Flag是 FLAG_ACTIVITY_NEW_TASK 和 FLAG_ACTIVITY_CLEAR_TASK。 通过动态注册的方式，可发现，我们可以配置返回目标activity。当然，静态配置也可以实现，修改shortcut标签： 123456789101112131415161718192021&lt;shortcut android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/ic_bar_detail_write&quot; android:shortcutDisabledMessage=&quot;@string/shortcut_publish&quot; android:shortcutId=&quot;publish&quot; android:shortcutLongLabel=&quot;@string/shortcut_publish&quot; android:shortcutShortLabel=&quot;@string/shortcut_publish&quot;&gt; &lt;!-- 返回目标activity --&gt; &lt;intent android:action=&quot;com.yuyh.xxx.BACK&quot; android:targetClass=&quot;com.yanshi.writing.ui.MainActivity&quot; android:targetPackage=&quot;com.yanshi.writing&quot; /&gt; &lt;!-- 目标activity --&gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:targetClass=&quot;com.yanshi.writing.ui.bar.PublishPostActivity&quot; android:targetPackage=&quot;com.yanshi.writing&quot; /&gt; &lt;categories android:name=&quot;android.shortcut.conversation&quot; /&gt; &lt;/shortcut&gt; 感谢阅读！","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"3D Touch","slug":"3D-Touch","permalink":"http://smuyyh.top/tags/3D-Touch/"}]},{"title":"JVM 基础知识","slug":"java-jvm-basic-knowledge","date":"06/03/2017","updated":"30/10/2023","comments":true,"path":"2017/03/06/java-jvm-basic-knowledge/","link":"","permalink":"http://smuyyh.top/2017/03/06/java-jvm-basic-knowledge/","excerpt":"JVM 概念JVM（Java Virtual Mechine，Java虚拟机），是 Java 应用程序的运行时引擎。JVM 是 JRE（Java Runtime，Java运行环境）的一部分，它实际上就是去执行 Java 程序的 main 方法。 为什么说 Java 是一个平台无关的语言？ Java 号称是 Write Once，Run Anywhere，能实现这个的核心，就是 JVM 。当我们通过编译器编译 .java 文件时，会生成一个同名的 .class 文件（包含字节码），当我们运行 Java 程序时，流程如图所示：","text":"JVM 概念JVM（Java Virtual Mechine，Java虚拟机），是 Java 应用程序的运行时引擎。JVM 是 JRE（Java Runtime，Java运行环境）的一部分，它实际上就是去执行 Java 程序的 main 方法。 为什么说 Java 是一个平台无关的语言？ Java 号称是 Write Once，Run Anywhere，能实现这个的核心，就是 JVM 。当我们通过编译器编译 .java 文件时，会生成一个同名的 .class 文件（包含字节码），当我们运行 Java 程序时，流程如图所示： 类加载器子系统类加载器子系统主要负责以下三部分： 装载 链接 初始化 装载类加载器读取 .class 文件，生成相应的二进制数据并将其保存在方法区域中。对于每个 .class 文件，JVM 在方法区域中存储以下信息： 已加载类及其直接父类的全名（含包名） .class 文件是否与类或接口或 Enum 相关 修饰符，变量和方法信息等 加载完 .class 文件后，JVM 会创建一个类型为 Class 的对象，以便在堆内存中表示此文件。这里需要注意的是，该 Class 对象的类型是在java.lang包中预定义的类。这个Class对象可以被程序员用于获取类名，类名，方法和变量信息等类级别信息。我们可以通过 Object#getClass 方法来获取该对象。这也是 Java 反射的基础，关于反射可参见这篇文章。 java&#x2F;** java获取Class对象的三种方式 *&#x2F;public static Class getClassObj() { // 根据类名获取Class对象 Class clazz1 &#x3D; People.class; &#x2F;&#x2F; 根据对象获取Class对象 People people &#x3D; new People(); Class&lt;?&gt; clazz2 &#x3D; people.getClass(); &#x2F;&#x2F; 根据完整类名获取Class对象 try { Class&lt;?&gt; clazz3 &#x3D; Class.forName(“com.yuyh.reflection.java.People”); } catch (ClassNotFoundException e) { Log.e(TAG, e.toString()); } Log.i(TAG, “clazz1 &#x3D; “ + clazz1); return clazz1; &#x2F;&#x2F; clazz2 clazz3 } 链接链接过程负责对二进制字节码的格式进行： 校验、初始化装载类中的静态变量、解析类中调用的接口、类。在完成了校验后，JVM初始化类中的静态变量，并将其值赋为默认值。 校验： 确保 .class 文件的正确性，检查此文件是否正确格式化并由有效编译器生成。如果验证失败，将会抛出运行时异常：java.lang.VerifyError ； 初始化： JVM为类变量分配内存并将内存初始化为默认值。例如 public static int CODE &#x3D; 1; 实际上，是将CODE初始化为0； 解析： 通过搜索方法区域来定位被引用的实体。对类中的所有属性、方法进行解析，以确保其需要调用的属性、方法存在，以及具备应的权限，若方法或属性不存在，将会抛出 NoSuchMethodError 、NoSuchFieldError 等异常。 初始化在这个阶段，所有静态变量都会分配他们在代码和静态块（如果有）中定义的值，也就是赋值。执行顺序是在类中从上到下执行，在类层次中从父类到子类执行。 通常有三个类加载器： 引导类加载器： 每个 JVM 实现都必须有一个引导类加载器，用于加载加载 JAVA_HOME&#x2F;jre&#x2F;lib 目录中存在的核心 Java API 类。这个路径通常称为引导路径。该加载器通过 C，C ++ 等语言实现。 扩展类加载器：用于加载扩展目录 JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext（扩展路径）或 java.ext.dirs 系统属性指定的任何其他目录中存在的类。该加载器通过 sun.misc.Launcher$ExtClassLoader 类实现。 系统&#x2F;应用程序类加载器：是扩展类加载器的子类，用来加载启动参数中指定的Classpath中的jar包以及目录。它也通过 sun.misc.Launcher$ExtClassLoader 类实现，对应的类名为 AppClassLoader 。 举个栗子： 1234567public class Test&#123; public static void main(String[] args) &#123; System.out.println(String.class.getClassLoader()); System.out.println(Test.class.getClassLoader()); &#125;&#125; 输出： 12nullsun.misc.Launcher$AppClassLoader@73d16e03 因为 String 类是通过引导类加载器加载的，而引导类加载器是通过 C&#x2F;C++ 实现的，并非 Java 对象，所以为null；而我们自定义的类是通过应用程序类加载器加载的。 注：JVM遵循委托 - 层次原理来加载类。 1. 系统类加载器 委托加载请求到 扩展类加载器 2. 扩展类加载器 委托加载请求到 引导类加载器 3. 如果类在引导路径中找到，类被加载，否则请求再次传递到扩展类加载器，然后到系统类加载器。最后如果系统类加载器无法加载类，那么我们得到运行时异常java.lang.ClassNotFoundException。如图所示： JVM 内存模型方法区（Method Area）在方法区域中，存储类名称、直接父类名称、方法和变量信息等所有类级信息，包括静态变量。每个 JVM 只有一个方法区，它是一个线程共享资源。 对于每一个加载的类，会在方法区中保存以下信息： 类型信息 类及其直接父类的全限定名（java.lang.Object没有父类） 类的类型 类的访问修饰符 实现的接口的全限定名的列表 字段与方法信息 常量池 除常量外的静态变量 类的Class及ClassLoader引用 字段信息 字段名 字段类型 字段的修饰符(public, private , protected, static, final, volatile, transient) 方法信息 方法名 方法返回类型 方法参数的数量和类型（按照顺序） 方法的修饰符(public, private, protected , static, final, synchronized, native, abstract) 堆区（Heap Area）所有对象（包括数组）的信息存储在堆区域中。每个 JVM 也有一个堆区域，并且它也是一个线程共享资源。堆区可能会抛出 OutOfMemoryError 异常。 栈区（Stack Area）对于每个线程，JVM 会创建一个存储在此处的运行时堆栈。每调用一个方法，就会生成一个栈帧（Stack Frame）用于存储方法的本地变量表、操作栈、方法出口等信息，当这个方法执行完后，就会弹出相应的栈帧。如果请求的栈的深度过大，虚拟机可能会抛出 StackOverflowError 异常，如果虚拟机的实现中允许虚拟机栈动态扩展，当内存不足以扩展栈的时候，会抛出 OutOfMemoryError 异常。在线程终止后，它的运行时栈将被 JVM 销毁。它不是共享资源。 程序计数器（Program Counter Register）存储线程当前执行指令的地址。由于多线程间切换时要恢复每一个线程的当前执行位置，显然每个线程都会有独立的PC寄存器。 本地方法栈（Native Method Stacks）对于每个线程，会创建单独的本地堆栈。它存储本地方法信息。与 Stack Area 类似。 执行引擎执行引擎执行 .class（字节码）。它逐行读取字节代码，读取各类存储区中存在的数据和信息并执行指令。它可以分为三个部分： 解释： 它逐行解释字节码，然后执行。主要缺点是当一个方法被多次调用时，每次都需要解释。（第一代JVM） 即时编译（Just-In-Time Compiler，JIT）： 用于提高解释器的效率。它编译整个字节码并将其更改为本机代码，因此每当解释器查看重复的方法调用时，JIT为该部分提供直接本地代码，因此不需要重新解释，从而提高效率。（第二代JVM） 垃圾收集器：它会销毁未引用的对象。关于垃圾收集，暂不叙述。 Java Native Interface (JNI)它是与本地方法库交互并提供执行所需的本机库（C，C ++）的接口，使JVM 可以调用C &#x2F; C ++库。 本地方法库它是执行引擎所需的本机库（C，C ++）的集合。","categories":[{"name":"Java","slug":"Java","permalink":"http://smuyyh.top/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://smuyyh.top/tags/JVM/"}]},{"title":"Android 7.0 之拍照与图片裁剪适配","slug":"android-24-camera-crop","date":"07/02/2017","updated":"06/09/2017","comments":true,"path":"2017/02/07/android-24-camera-crop/","link":"","permalink":"http://smuyyh.top/2017/02/07/android-24-camera-crop/","excerpt":"在Android 7.0以上，在相机拍照和图片裁剪上，可能会碰到以下一些错误： 12345678Process: com.yuyh.imgsel, PID: 22995// 错误1android.os.FileUriExposedException: file:///storage/emulated/0/Android/data/com.yuyh.imgsel/cache/1486438962645.jpg exposed beyond app through ClipData.Item.getUri()// 错误2android.os.FileUriExposedException: file:///storage/emulated/0/DCIM/RxGalleryFinal/IMG_20161018180127.jpg exposed beyond app through Intent.getData()","text":"在Android 7.0以上，在相机拍照和图片裁剪上，可能会碰到以下一些错误： 12345678Process: com.yuyh.imgsel, PID: 22995// 错误1android.os.FileUriExposedException: file:///storage/emulated/0/Android/data/com.yuyh.imgsel/cache/1486438962645.jpg exposed beyond app through ClipData.Item.getUri()// 错误2android.os.FileUriExposedException: file:///storage/emulated/0/DCIM/RxGalleryFinal/IMG_20161018180127.jpg exposed beyond app through Intent.getData() 主要是由于在Android 7.0以后，用了Content Uri 替换了原本的File Uri，故在targetSdkVersion&#x3D;24的时候，部分 Uri.fromFile() 方法就不适用了。 File Uri 与 Content Uri 的区别 File Uri 对应的是文件本身的存储路径 Content Uri 对应的是文件在Content Provider的路径 所以在android 7.0 以上，我们就需要将File Uri转换为 Content Uri。具体转换方法如下： 123456789101112131415161718192021222324252627282930/** * 转换 content:// uri * * @param imageFile * @return */public Uri getImageContentUri(File imageFile) &#123; String filePath = imageFile.getAbsolutePath(); Cursor cursor = getContentResolver().query( MediaStore.Images.Media.EXTERNAL_CONTENT_URI, new String[] &#123; MediaStore.Images.Media._ID &#125;, MediaStore.Images.Media.DATA + &quot;=? &quot;, new String[] &#123; filePath &#125;, null); if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123; int id = cursor.getInt(cursor .getColumnIndex(MediaStore.MediaColumns._ID)); Uri baseUri = Uri.parse(&quot;content://media/external/images/media&quot;); return Uri.withAppendedPath(baseUri, &quot;&quot; + id); &#125; else &#123; if (imageFile.exists()) &#123; ContentValues values = new ContentValues(); values.put(MediaStore.Images.Media.DATA, filePath); return getContentResolver().insert( MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values); &#125; else &#123; return null; &#125; &#125;&#125; 那么，我们在裁剪的时候，应该如下调用： 123456789101112131415161718private void crop(String imagePath) &#123; File file = new File(&quot;xxx.jpg&quot;); cropImagePath = file.getAbsolutePath(); Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.setDataAndType(getImageContentUri(new File(imagePath)), &quot;image/*&quot;); intent.putExtra(&quot;crop&quot;, &quot;true&quot;); intent.putExtra(&quot;aspectX&quot;, config.aspectX); intent.putExtra(&quot;aspectY&quot;, config.aspectY); intent.putExtra(&quot;outputX&quot;, config.outputX); intent.putExtra(&quot;outputY&quot;, config.outputY); intent.putExtra(&quot;scale&quot;, true); intent.putExtra(&quot;return-data&quot;, false); intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file)); intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString()); intent.putExtra(&quot;noFaceDetection&quot;, true); startActivityForResult(intent, IMAGE_CROP_CODE);&#125; 这样就解决了裁剪的问题，但是！！拍照的时候就会出现以下错误： 12345678Intent cameraIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);if (cameraIntent.resolveActivity(getActivity().getPackageManager()) != null) &#123; tempFile = new File(FileUtils.createRootPath(getActivity()) + &quot;/&quot; + System.currentTimeMillis() + &quot;.jpg&quot;); LogUtils.e(tempFile.getAbsolutePath()); FileUtils.createFile(tempFile); cameraIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(tempFile)); startActivityForResult(cameraIntent, REQUEST_CAMERA);&#125; 1android.os.FileUriExposedException: file:///storage/emulated/0/Android/data/com.yuyh.imgsel/cache/1486438962645.jpg exposed beyond app through ClipData.Item.getUri() 这是因为拍照存储的文件，也需要以Content Uri的形式，故采用以下办法解决： Step.1 修改AndroidManifest.xml 12345678910111213&lt;application ...&gt; &lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;&#123;替换为你的包名&#125;.provider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/provider_paths&quot;/&gt; &lt;/provider&gt;&lt;/application&gt; Step.2 在res&#x2F;xml&#x2F;下新建provider_paths.xml文件 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;external-path name=&quot;external_files&quot; path=&quot;.&quot;/&gt;&lt;/paths&gt; Step.3 修改拍照时的参数 1cameraIntent.putExtra(MediaStore.EXTRA_OUTPUT, FileProvider.getUriForFile(getActivity(),BuildConfig.APPLICATION_ID + &quot;.provider&quot;, tempFile)); //Uri.fromFile(tempFile) 搞定！","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"Camera","slug":"Camera","permalink":"http://smuyyh.top/tags/Camera/"}]},{"title":"【转】Android View 绘制流程","slug":"android-view-draw","date":"07/02/2017","updated":"06/09/2017","comments":true,"path":"2017/02/07/android-view-draw/","link":"","permalink":"http://smuyyh.top/2017/02/07/android-view-draw/","excerpt":"Android View 绘制流程","text":"Android View 绘制流程 View 绘制机制一、 View 树的绘图流程当 Activity 接收到焦点的时候，它会被请求绘制布局,该请求由 Android framework 处理.绘制是从根节点开始，对布局树进行 measure 和 draw。整个 View 树的绘图流程在ViewRoot.java类的performTraversals()函数展开，该函数所做 的工作可简单概况为是否需要重新计算视图大小(measure)、是否需要重新安置视图的位置(layout)、以及是否需要重绘(draw)，流程图如下： View 绘制流程函数调用链 需要说明的是，用户主动调用 request，只会出发 measure 和 layout 过程，而不会执行 draw 过程 二、 概念1. measure 和 layout 从整体上来看 Measure 和 Layout 两个步骤的执行： 树的遍历是有序的，由父视图到子视图，每一个 ViewGroup 负责测绘它所有的子视图，而最底层的 View 会负责测绘自身。 2. 具体分析measure 过程由measure(int, int)方法发起，从上到下有序的测量 View，在 measure 过程的最后，每个视图存储了自己的尺寸大小和测量规格。layout 过程由layout(int, int, int, int)方法发起，也是自上而下进行遍历。在该过程中，每个父视图会根据 measure 过程得到的尺寸来摆放自己的子视图。 measure 过程会为一个 View 及所有子节点的 mMeasuredWidth 和 mMeasuredHeight 变量赋值，该值可以通过 getMeasuredWidth()和getMeasuredHeight()方法获得。而且这两个值必须在父视图约束范围之内，这样才可以保证所有的父视图都接收所有子视图的测量。如果子视图对于 Measure 得到的大小不满意的时候，父视图会介入并设置测量规则进行第二次 measure。比如，父视图可以先根据未给定的 dimension 去测量每一个子视图，如果最终子视图的未约束尺寸太大或者太小的时候，父视图就会使用一个确切的大小再次对子视图进行 measure。 3. measure 过程传递尺寸的两个类 ViewGroup.LayoutParams （View 自身的布局参数） MeasureSpecs 类（父视图对子视图的测量要求） ViewGroup.LayoutParams这个类我们很常见，就是用来指定视图的高度和宽度等参数。对于每个视图的 height 和 width，你有以下选择： 具体值 MATCH_PARENT 表示子视图希望和父视图一样大(不包含 padding 值) WRAP_CONTENT 表示视图为正好能包裹其内容大小(包含 padding 值) ViewGroup 的子类有其对应的 ViewGroup.LayoutParams 的子类。比如 RelativeLayout 拥有的 ViewGroup.LayoutParams 的子类 RelativeLayoutParams。有时我们需要使用 view.getLayoutParams() 方法获取一个视图 LayoutParams，然后进行强转，但由于不知道其具体类型，可能会导致强转错误。其实该方法得到的就是其所在父视图类型的 LayoutParams，比如 View 的父控件为 RelativeLayout，那么得到的 LayoutParams 类型就为 RelativeLayoutParams。 MeasureSpecs测量规格，包含测量要求和尺寸的信息，有三种模式: UNSPECIFIED父视图不对子视图有任何约束，它可以达到所期望的任意尺寸。比如 ListView、ScrollView，一般自定义 View 中用不到， EXACTLY父视图为子视图指定一个确切的尺寸，而且无论子视图期望多大，它都必须在该指定大小的边界内，对应的属性为 match_parent 或具体值，比如 100dp，父控件可以通过MeasureSpec.getSize(measureSpec)直接得到子控件的尺寸。 AT_MOST父视图为子视图指定一个最大尺寸。子视图必须确保它自己所有子视图可以适应在该尺寸范围内，对应的属性为 wrap_content，这种模式下，父控件无法确定子 View 的尺寸，只能由子控件自己根据需求去计算自己的尺寸，这种模式就是我们自定义视图需要实现测量逻辑的情况。 3、 measure 核心方法 measure(int widthMeasureSpec, int heightMeasureSpec)该方法定义在View.java类中，为 final 类型，不可被复写，但 measure 调用链最终会回调 View&#x2F;ViewGroup 对象的 onMeasure()方法，因此自定义视图时，只需要复写 onMeasure() 方法即可。 onMeasure(int widthMeasureSpec, int heightMeasureSpec)该方法就是我们自定义视图中实现测量逻辑的方法，该方法的参数是父视图对子视图的 width 和 height 的测量要求。在我们自身的自定义视图中，要做的就是根据该 widthMeasureSpec 和 heightMeasureSpec 计算视图的 width 和 height，不同的模式处理方式不同。 setMeasuredDimension()测量阶段终极方法，在 onMeasure(int widthMeasureSpec, int heightMeasureSpec) 方法中调用，将计算得到的尺寸，传递给该方法，测量阶段即结束。该方法也是必须要调用的方法，否则会报异常。在我们在自定义视图的时候，不需要关心系统复杂的 Measure 过程的，只需调用setMeasuredDimension()设置根据 MeasureSpec 计算得到的尺寸即可，你可以参考 ViewPagerIndicator 的 onMeasure 方法。 下面我们取 ViewGroup 的 measureChildren（int widthMeasureSpec, int heightMeasureSpec) 方法对复合 View 的 Measure 流程做一个分析：MeasureChild 的方法调用流程图： 源码分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 /** * 请求所有子 View 去 measure 自己，要考虑的部分有对子 View 的测绘要求 MeasureSpec 以及其自身的 padding * 这里跳过所有为 GONE 状态的子 View，最繁重的工作是在 getChildMeasureSpec 方法中处理的 * * @param widthMeasureSpec 对该 View 的 width 测绘要求 * @param heightMeasureSpec 对该 View 的 height 测绘要求 */ protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams();//获取 Child 的 LayoutParams final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,// 获取 ChildView 的 widthMeasureSpec mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,// 获取 ChildView 的 heightMeasureSpec mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125;/** * 该方法是 measureChildren 中最繁重的部分，为每一个 ChildView 计算出自己的 MeasureSpec。 * 目标是将 ChildView 的 MeasureSpec 和 LayoutParams 结合起来去得到一个最合适的结果。 * * @param spec 对该 View 的测绘要求 * @param padding 当前 View 在当前唯独上的 paddingand，也有可能含有 margins * * @param childDimension 在当前维度上（height 或 width）的具体指 * @return 子视图的 MeasureSpec */ public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; ......... // 根据获取到的子视图的测量要求和大小创建子视图的 MeasureSpec return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; /** * * 用于获取 View 最终的大小，父视图提供了宽、高的约束信息 * 一个 View 的真正的测量工作是在 onMeasure(int, int) 中，由该方法调用。 * 因此，只有 onMeasure(int, int) 可以而且必须被子类复写 * * @param widthMeasureSpec 在水平方向上，父视图指定的的 Measure 要求 * @param heightMeasureSpec 在竖直方向上，控件上父视图指定的 Measure 要求 * */ public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... onMeasure(widthMeasureSpec, heightMeasureSpec); ... &#125; protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 4、 layout 相关概念及核心方法首先要明确的是，子视图的具体位置都是相对于父视图而言的。View 的 onLayout 方法为空实现，而 ViewGroup 的 onLayout 为 abstract 的，因此，如果自定义的 View 要继承 ViewGroup 时，必须实现 onLayout 函数。 在 layout 过程中，子视图会调用getMeasuredWidth()和getMeasuredHeight()方法获取到 measure 过程得到的 mMeasuredWidth 和 mMeasuredHeight，作为自己的 width 和 height。然后调用每一个子视图的layout(l, t, r, b)函数，来确定每个子视图在父视图中的位置。 LinearLayout 的 onLayout 源码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125; &#125; /** * 遍历所有的子 View，为其设置相对父视图的坐标 */ void layoutVertical(int left, int top, int right, int bottom) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123;//不需要立即展示的 View 设置为 GONE 可加快绘制 final int childWidth = child.getMeasuredWidth();//measure 过程确定的 Width final int childHeight = child.getMeasuredHeight();//measure 过程确定的 height ...确定 childLeft、childTop 的值 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); &#125; &#125; &#125; private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height); &#125; View.java public void layout(int l, int t, int r, int b) &#123; ... setFrame(l, t, r, b) &#125; /** * 为该子 View 设置相对其父视图上的坐标 */ protected boolean setFrame(int left, int top, int right, int bottom) &#123; ... &#125; 5、 绘制流程相关概念及核心方法先来看下与 draw 过程相关的函数： View.draw(Canvas canvas)：由于 ViewGroup 并没有复写此方法，因此，所有的视图最终都是调用 View 的 draw 方法进行绘制的。在自定义的视图中，也不应该复写该方法，而是复写 onDraw(Canvas) 方法进行绘制，如果自定义的视图确实要复写该方法，那么请先调用 super.draw(canvas)完成系统的绘制，然后再进行自定义的绘制。 View.onDraw()：View 的onDraw（Canvas）默认是空实现，自定义绘制过程需要复写的方法，绘制自身的内容。 dispatchDraw()发起对子视图的绘制。View 中默认是空实现，ViewGroup 复写了dispatchDraw()来对其子视图进行绘制。该方法我们不用去管，自定义的 ViewGroup 不应该对dispatchDraw()进行复写。 绘制流程图 View.draw(Canvas) 源码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Manually render this view (and all of its children) to the given Canvas. * The view must have already done a full layout before this function is * called. When implementing a view, implement * &#123;@link #onDraw(android.graphics.Canvas)&#125; instead of overriding this method. * If you do need to override this method, call the superclass version. * * @param canvas The Canvas to which the View is rendered. * * 根据给定的 Canvas 自动渲染 View（包括其所有子 View）。在调用该方法之前必须要完成 layout。当你自定义 view 的时候， * 应该去是实现 onDraw(Canvas) 方法，而不是 draw(canvas) 方法。如果你确实需要复写该方法，请记得先调用父类的方法。 */ public void draw(Canvas canvas) &#123; / * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background if need * 2. If necessary, save the canvas&#x27; layers to prepare for fading * 3. Draw view&#x27;s content * 4. Draw children (dispatchDraw) * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // we&#x27;re done... return; &#125; // Step 2, save the canvas&#x27; layers ... // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); &#125; 由上面的处理过程，我们也可以得出一些优化的小技巧：当不需要绘制 Layer 的时候第二步和第五步会跳过。因此在绘制的时候，能省的 layer 尽可省，可以提高绘制效率 ViewGroup.dispatchDraw() 源码分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556dispatchDraw(Canvas canvas)&#123;... if ((flags &amp; FLAG_RUN_ANIMATION) != 0 &amp;&amp; canAnimate()) &#123;//处理 ChildView 的动画 final boolean buildCache = !isHardwareAccelerated(); for (int i = 0; i &lt; childrenCount; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;//只绘制 Visible 状态的布局，因此可以通过延时加载来提高效率 final LayoutParams params = child.getLayoutParams(); attachLayoutAnimationParameters(child, params, i, childrenCount);// 添加布局变化的动画 bindLayoutAnimation(child);//为 Child 绑定动画 if (cache) &#123; child.setDrawingCacheEnabled(true); if (buildCache) &#123; child.buildDrawingCache(true); &#125; &#125; &#125; &#125; final LayoutAnimationController controller = mLayoutAnimationController; if (controller.willOverlap()) &#123; mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE; &#125; controller.start();// 启动 View 的动画&#125; // 绘制 ChildView for (int i = 0; i &lt; childrenCount; i++) &#123; int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125;...&#125;protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125;/** * This method is called by ViewGroup.drawChild() to have each child view draw itself. * This draw() method is an implementation detail and is not intended to be overridden or * to be called from anywhere else other than ViewGroup.drawChild(). */ boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; ... &#125; drawChild(canvas, this, drawingTime)直接调用了 View 的child.draw(canvas, this,drawingTime)方法，文档中也说明了，除了被ViewGroup.drawChild()方法外，你不应该在其它任何地方去复写或调用该方法，它属于 ViewGroup。而View.draw(Canvas) 方法是我们自定义控件中可以复写的方法，具体可以参考上述对view.draw(Canvas)的说明。从参数中可以看到，child.draw(canvas, this, drawingTime) 肯定是处理了和父视图相关的逻辑，但 View 的最终绘制，还是 View.draw(Canvas)方法。 invalidate()请求重绘 View 树，即 draw 过程，假如视图发生大小没有变化就不会调用layout()过程，并且只绘制那些调用了invalidate()方法的 View。 requestLayout()当布局变化的时候，比如方向变化，尺寸的变化，会调用该方法，在自定义的视图中，如果某些情况下希望重新测量尺寸大小，应该手动去调用该方法，它会触发measure()和layout()过程，但不会进行 draw。 原文：公共技术点之 View 绘制流程","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/tags/Android/"},{"name":"View","slug":"View","permalink":"http://smuyyh.top/tags/View/"}]},{"title":"RxJava 从入门到出轨","slug":"rxjava-1.0-source","date":"23/11/2016","updated":"06/09/2017","comments":true,"path":"2016/11/23/rxjava-1.0-source/","link":"","permalink":"http://smuyyh.top/2016/11/23/rxjava-1.0-source/","excerpt":"前言使用了RxJava有一段时间了，深深感受到了其“牛逼”之处。下面，就从RxJava的基础开始，一步一步与大家分享一下这个强大的异步库的用法！ RxJava 概念初步RxJava 在Github Repo上给的解释是： 123“RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.” 大概就是说RxJava是Java VM上一个灵活的、使用可观测序列来组成的一个异步的、基于事件的库。咋一看好像不知道是啥东西… … 没事，往下看~","text":"前言使用了RxJava有一段时间了，深深感受到了其“牛逼”之处。下面，就从RxJava的基础开始，一步一步与大家分享一下这个强大的异步库的用法！ RxJava 概念初步RxJava 在Github Repo上给的解释是： 123“RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.” 大概就是说RxJava是Java VM上一个灵活的、使用可观测序列来组成的一个异步的、基于事件的库。咋一看好像不知道是啥东西… … 没事，往下看~ 作用 - 异步上面 这段解释，重点就在于异步！但是它又不像 AsyncTask 这样用法简单，所以刚接触RxJava的童鞋，可能会觉得特别难，无从下手，没事，相信通过这篇文章，大伙儿可以有一个比较深刻的理解！ RxJava精华可以浓缩为异步两个字，其核心的东西不外乎两个： 1. Observable（被观察者） 2. Observer/Subscriber（观察者） Observables可以发出一系列的 事件，这里的事件可以是任何东西，例如网络请求、复杂计算处理、数据库操作、文件操作等等，事件执行结束后交给 Observer&#x2F;Subscriber 的回调处理。 模式 - 观察者模式观察者模式是一种对象的行为模式，是 Java 设计模式中很常用的一个模式。观察者模式也常称为: 发布-订阅模式(Publish/Subscribe) 模型-视图模式(Model/View) 源-监听器模式(Source/Listener) 从属者模式(Dependents) 例如用过事件总线 EventBus 库的童鞋就知道，EventBus 属于发布-订阅模式(Publish&#x2F;Subscribe)。 12345678// 事件订阅@Subscribe(threadMode = ThreadMode.MAIN)public void showDownProgress(MyEvent event) &#123; // TODO&#125;// 事件发布EventBus.getDefault().post(new MyEvent()); 实际上，使用 RxJava 也可以设计出一套事件总线的库，这个称为 RxBus。有兴趣的话可以在学完 RxJava 之后，可以尝试写一个。这里就不细说了~ 为啥说这个呢？因为，RxJava 也是一种扩展的观察者模式！ 举个栗子，Android 中 View 的点击监听器的实现，View 是被观察者，OnClickListener 对象是观察者，Activity 要如何知道 View 被点击了？那就是构造一个 OnClickListener 对象，通过 setOnClickListener 与View达成一个订阅关系，一旦 View 被点击了，就通过OnClickListener对象的 OnClick 方法传达给 Activity 。采用观察者模式可以避免去轮询检查，节约有限的cpu资源。 结构 - 响应式编程响应式？顾名思义，就是“你变化，我响应”。举个栗子，a &#x3D; b + c; 这句代码将b+c的值赋给a，而之后如果b和c的值改变了不会影响到a，然而，对于响应式编程，之后b和c的值的改变也动态影响着a，意味着a会随着b和c的变化而变化。 响应式编程的组成为Observable&#x2F;Operator&#x2F;Subscriber，RxJava在响应式编程中的基本流程如下： 1Observable -&gt; Operator 1 -&gt; Operator 2 -&gt; Operator 3 -&gt; Subscriber 这个流程，可以简单的理解为： Observable 发出一系列事件，他是事件的产生者； Subscriber 负责处理事件，他是事件的消费者； Operator 是对 Observable 发出的事件进行修改和变换； 若事件从产生到消费不需要其他处理，则可以省略掉中间的 Operator，从而流程变为 Obsevable -&gt; Subscriber； Subscriber 通常在主线程执行，所以原则上不要去处理太多的事务，而这些复杂的事务处理则交给 Operator； 优势 - 逻辑简洁Rx 优势可以概括为四个字，那就是 逻辑简洁。然而，逻辑简洁并不意味着代码简洁，但是，由于链式结构，一条龙，你可以从头到尾，从上到下，很清楚的看到这个连式结构的执行顺序。对于开发人员来说，代码质量并不在于代码量，而在于逻辑是否清晰简洁，可维护性如何，代码是否健壮！ 另外，熟悉lambda的，还可以进一步提高代码的简洁性。举个简单栗子对比一下，暂时不需要过多理解，后面会一一道来： 12345678910111213141516171819202122232425// 不使用lambdaObservable.just(&quot;Hello World!&quot;) .map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s + &quot;I am kyrie!&quot;; &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125; &#125;); // 使用lambdaObservable.just(&quot;Hello World!&quot;) .map(s -&gt; s + &quot;I am kyrie!&quot;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(s -&gt; &#123; Log.i(TAG, s); &#125;); RxJava 依赖在 Android Studio 项目下，为 module 增加 Gradle 依赖。 1234// Android 平台下须引入的一个依赖，主要用于线程控制compile &#x27;io.reactivex:rxandroid:1.1.0&#x27;// RxJavacompile &#x27;io.reactivex:rxjava:1.1.5&#x27; 这是我项目里面用的版本，也可以到Maven&#x2F;RxJava下获取最新版本。 RxJava 入门前面讲了那么多，大家在概念上对RxJava有一个初步的认识就好，接下来，将为您解开RxJava神秘的面纱~~ 无需过分纠结于“事件”这个词，暂时可以简单的把“事件”看成是一个值，或者一个对象。 事件产生，就是构造要传递的对象； 事件处理变换，就是改变传递的对象，可以改变对象的值，或是干脆创建个新对象，新对象类型也可以与源对象不一样； 事件处理，就是接收到对象后要做的事； 事件产生RxJava创建一个事件比较简单，由 Observable 通过 create 操作符来创建。举个栗子，还是经典的 HelloWorld~~ 123456789101112// 创建一个ObservableObservable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; // 发送一个 Hello World 事件 subscriber.onNext(&quot;Hello World!&quot;); // 事件发送完成 subscriber.onCompleted(); &#125;&#125;); 这段代码可以理解为， Observable 发出了一个类型为 String ，值为 “Hello World!” 的事件，仅此而已。 对于 Subscriber 来说，通常onNext()可以多次调用，最后调用onCompleted()表示事件发送完成。 上面这段代码，也可以通过just操作符进行简化。RxJava常用操作符后面会详细介绍，这里先有个了解。 12// 创建对象,just里面的每一个参数，相当于调用一次Subscriber#OnNext()Observable&lt;String&gt; observable = Observable.just(&quot;Hello World!&quot;); 这样，是不是简单了许多？ 事件消费有事件产生，自然也要有事件消费。RxJava 可以通过 subscribe 操作符，对上述事件进行消费。首先，先创建一个观察者。 1234567891011121314151617// 创建一个ObserverObserver&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.i(TAG, &quot;complete&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(TAG, s); &#125;&#125;; 或者 1234567891011121314151617// 创建一个SubscriberSubscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.i(TAG, &quot;complete&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(TAG, s); &#125;&#125;; Observer 是观察者， Subscriber 也是观察者，Subscriber 是一个实现了Observer接口的抽象类，对 Observer 进行了部分扩展，在使用上基本没有区别； Subscriber 多了发送之前调用的 onStart() 和解除订阅关系的 unsubscribe() 方法。 并且，在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用。所以在这之后的示例代码，都使用 Subscriber 来作为观察者。 事件订阅最后，我们可以调用 subscribe 操作符， 进行事件订阅。 12// 订阅事件observable.subscribe(subscriber); 在 Subscriber 实现的三个方法中，顾名思义，对应三种不同状态： onComplete(): 事件全部处理完成后回调 onError(Throwable t): 事件处理异常回调 onNext(T t): 每接收到一个事件，回调一次 区分回调动作对于事件消费与事件订阅来说，好像为了打印一个“Hello World！”要费好大的劲… 其实，RxJava 自身提供了精简回调方式，我们可以为 Subscriber 中的三种状态根据自身需要分别创建一个回调动作 Action： 1234567891011121314151617181920212223// onComplete()Action0 onCompleteAction = new Action0() &#123; @Override public void call() &#123; Log.i(TAG, &quot;complete&quot;); &#125;&#125;;// onNext(T t)Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125;&#125;;// onError(Throwable t)Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; &#125;&#125;; 那么，RxJava 的事件订阅支持以下三种不完整定义的回调。 12345observable.subscribe(onNextAction);observable.subscribe(onNextAction, onErrorAction);observable.subscribe(onNextAction, onErrorAction, onCompleteAction); 我们可以根据当前需要，传入对应的 Action， RxJava 会相应的自动创建 Subscriber。 Action0 表示一个无回调参数的Action； Action1 表示一个含有一个回调参数的Action； 当然，还有Action2 ~ Action9，分别对应2~9个参数的Action； 每个Action，都有一个 call() 方法，通过泛型T，来指定对应参数的类型； 入门示例前面讲解了事件的产生到消费、订阅的过程，下面就举个完整的例子。从res&#x2F;mipmap中取出一张图片，显示在ImageView上。 1234567891011121314151617181920212223242526272829303132final ImageView ivLogo = (ImageView) findViewById(R.id.ivLogo);Observable.create(new Observable.OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; // 从mipmap取出一张图片作为Drawable对象 Drawable drawable = ContextCompat.getDrawable(mContext, R.mipmap.ic_launcher); // 把Drawable对象发送出去 subscriber.onNext(drawable); subscriber.onCompleted(); &#125; &#125;) .subscribe(new Subscriber&lt;Drawable&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Log.i(TAG, e.toString()); &#125; @Override public void onNext(Drawable drawable) &#123; // 接收到Drawable对象，显示在ImageView上 ivLogo.setImageDrawable(drawable); &#125; &#125;); 上面示例是RxJava最基本的一个用法。稍微消化一下，继续~~ RxJava 进阶Scheduler线程控制默认情况下，RxJava事件产生和消费均在同一个线程中，例如在主线程中调用，那么事件的产生和消费都在主线程。 那么问题来了，假如事件产生的过程是耗时操作，比如网络请求，结果显示在UI中，这个时候在主线程执行对于网络请求就不合适了，而在子线程执行，显示结果需要进行UI操作，同样不合适~~ 所以，RxJava 的第一个牛逼之处在于可以自由切换线程！那么，如何做？ 在 RxJava 中，提供了一个名为 Scheduler 的线程调度器，RxJava 内部提供了4个调度器，分别是： Schedulers.io(): I&#x2F;O 操作（读写文件、数据库、网络请求等），与newThread()差不多，区别在于io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 效率比 newThread() 更高。值得注意的是，在 io() 下，不要进行大量的计算，以免产生不必要的线程； Schedulers.newThread(): 开启新线程操作； Schedulers.immediate(): 默认指定的线程，也就是当前线程； Schedulers.computation():计算所使用的调度器。这个计算指的是 CPU 密集型计算，即不会被 I&#x2F;O等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。值得注意的是，不要把 I&#x2F;O 操作放在 computation() 中，否则 I&#x2F;O 操作的等待时间会浪费 CPU； AndroidSchedulers.mainThread(): RxJava 扩展的 Android 主线程； 我们可以通过 subscribeOn() 和 observeOn() 这两个方法来进行线程调度。举个栗子： 依然还是显示一张图片，不同的是，这次是从网络上加载图片 12345678910111213141516171819202122232425262728293031323334final ImageView ivLogo = (ImageView) findViewById(R.id.ivLogo);Observable.create(new Observable.OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; try &#123; Drawable drawable = Drawable.createFromStream(new URL(&quot;https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2502144641,437990411&amp;fm=80&amp;w=179&amp;h=119&amp;img.JPEG&quot;).openStream(), &quot;src&quot;); subscriber.onNext(drawable); &#125; catch (IOException e) &#123; subscriber.onError(e); &#125; &#125;&#125;) // 指定 subscribe() 所在的线程，也就是上面call()方法调用的线程 .subscribeOn(Schedulers.io()) // 指定 Subscriber 回调方法所在的线程，也就是onCompleted, onError, onNext回调的线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Drawable&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Log.e(TAG, e.toString()); &#125; @Override public void onNext(Drawable drawable) &#123; ivLogo.setImageDrawable(drawable); &#125; &#125;); 所以，这段代码就做一件事，在 io 线程加载一张网络图片，加载完毕之后在主线程中显示到ImageView上。 变换RxJava的又一牛逼之处，在于 变换。啥意思呢？ 就是将发送的事件或事件序列，加工后转换成不同的事件或事件序列。 map操作符变换的概念不好理解吧？举个简单的栗子，我们对上述示例 进行改写。 123456789101112131415161718192021222324252627282930313233343536373839404142final ImageView ivLogo = (ImageView) findViewById(R.id.ivLogo);Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;https://ss2.baidu.com/-vo3dSag_xI4khGko9WTAnF6hhy/image/h%3D200/sign=4db5130a073b5bb5a1d727fe06d2d523/cf1b9d16fdfaaf51965f931e885494eef11f7ad6.jpg&quot;); &#125;&#125;).map(new Func1&lt;String, Drawable&gt;() &#123; @Override public Drawable call(String url) &#123; try &#123; Drawable drawable = Drawable.createFromStream(new URL(url).openStream(), &quot;src&quot;); return drawable; &#125; catch (IOException e) &#123; &#125; return null; &#125;&#125;) // 指定 subscribe() 所在的线程，也就是call()方法调用的线程 .subscribeOn(Schedulers.io()) // 指定 Subscriber 回调方法所在的线程，也就是onCompleted, onError, onNext回调的线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Drawable&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Log.e(TAG, e.toString()); &#125; @Override public void onNext(Drawable drawable) &#123; if (drawable != null) &#123; ivLogo.setImageDrawable(drawable); &#125; &#125; &#125;); 经过改写代码后，有什么变化呢？ Observable 创建了一个 String 事件，也就是产生一个url，通过 map 操作符进行变换，返回Drawable对象，这个变换指的就是通过url进行网络图片请求，返回一个Drawable。所以简单的来说就是把String事件，转换为Drawable事件。逻辑表示就是： Observable –&gt; map变换 –&gt; Observable 那么，Func1 是什么呢？与 Action1 类似,不同的是 FuncX 有返回值，而 ActionX 没有。为什么需要返回值呢？目的就在于对象的变换，由String对象转换为Drawable对象。同样，也有Func0 ~ Func9，对应不同的参数个数。 当然了，RxJava 的变换，可不止于map这么简单，继续往下！ flatMap操作符不难发现，上述的 map 操作符，是一对一的变换，并且返回的是变换后的对象。而 flatMap 操作符可以适应一对多，并且返回的是一个 Observable 。应用场景举例：例如一个员工负责多个任务，现在要打印所有员工的所有任务。 1234567891011121314151617181920212223242526272829final List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;() &#123; &#123; add(new Employee(&quot;jackson&quot;, mission_list1)); add(new Employee(&quot;sunny&quot;, mission_list2)); &#125;&#125;;Observable.from(list) .flatMap(new Func1&lt;Employee, Observable&lt;Employee.Mission&gt;&gt;() &#123; @Override public Observable&lt;Employee.Mission&gt; call(Employee employee) &#123; return Observable.from(employee.missions); &#125; &#125;) .subscribe(new Subscriber&lt;Employee.Mission&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Employee.Mission mission) &#123; Log.i(TAG, mission.desc); &#125; &#125;); 执行结果为顺序打印出两位员工的所有任务列表。 通过上面的代码可以看出，map 与 flatMap 这两个操作符的共同点在于，他们都是把一个对象转换为另一个对象，但须注意以下这些特点: flatMap 返回的是一个Observable对象，而 map 返回的是一个普通转换后的对象; flatMap 返回的Observable对象并不是直接发送到Subscriber的回调中，而是重新创建一个Observable对象，并激活这个Observable对象，使之开始发送事件；而 map 变换后返回的对象直接发到Subscriber回调中； flatMap 变换后产生的每一个Observable对象发送的事件，最后都汇入同一个Observable，进而发送给Subscriber回调； map返回类型 与 flatMap 返回的Observable事件类型，可以与原来的事件类型一样； 可以对一个Observable多次使用 map 和 flatMap； 鉴于 flatMap 自身强大的功能，这常常被用于 嵌套的异步操作，例如嵌套网络请求。传统的嵌套请求，一般都是在前一个请求的 onSuccess() 回调里面发起新的请求，这样一旦嵌套多个的话，缩进就是大问题了，而且严重的影响代码的可读性。而RxJava嵌套网络请求仍然通过链式结构，保持代码逻辑的清晰！举个栗子： Github上的 README.md 文件，通常是 MarkDown 语法。我们要获取 README.md 内容并按 MarkDown 风格显示在UI上，就可以通过以下方式（Retrofit2 + RxJava，稍后会介绍）： 12345678910111213141516171819202122232425262728293031new ReadmeContentClient() // 获取md语法的Readme内容, 返回的是一个Observable&lt;String&gt;对象 .getReadme() .flatMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(String md) &#123; // 由于Readme的内容是md语法，需要转成html字符串通过WebView显示到UI // 返回的也是Observable&lt;String&gt;对象 return new MarkDownStyleClient(md) .formatMarkStyle(); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Log.e(TAG, &quot;readme:&quot; + e.toString()); &#125; @Override public void onNext(String html) &#123; // html就是根据readme md格式内容，生成的html代码 view.showReadme(html); &#125; &#125;); RxJava 其他常用操作符 from接收一个集合作为输入，然后每次输出一个元素给subscriber。 12345678// Observable.from(T[] params)Observable.from(new Integer[]&#123;1, 2, 3, 4, 5&#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.i(TAG, &quot;number:&quot; + number); &#125; &#125;); 注意：如果from()里面执行了耗时操作，即使使用了subscribeOn(Schedulers.io())，仍然是在主线程执行，可能会造成界面卡顿甚至崩溃，所以耗时操作还是使用Observable.create(…); just接收一个可变参数作为输入，最终也是生成数组，调用from()，然后每次输出一个元素给subscriber。 12345678// Observable.just(T... params)，params的个数为1 ~ 10Observable.just(1, 2, 3, 4, 5) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.i(TAG, &quot;number:&quot; + number); &#125; &#125;); filter条件过滤，去除不符合某些条件的事件。举个栗子: 1234567891011121314Observable.from(new Integer[]&#123;1, 2, 3, 4, 5&#125;) .filter(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer number) &#123; // 偶数返回true，则表示剔除奇数，留下偶数 return number % 2 == 0; &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.i(TAG, &quot;number:&quot; + number); &#125; &#125;); take最多保留的事件数。 doOnNext在处理下一个事件之前要做的事。 1234567891011121314151617181920212223Observable.from(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;) .filter(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer number) &#123; // 偶数返回true，则表示剔除奇数 return number % 2 == 0; &#125; &#125;) // 最多保留三个，也就是最后剩三个偶数 .take(3) .doOnNext(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; // 在输出偶数之前输出它的hashCode Log.i(TAG, &quot;hahcode = &quot; + number.hashCode() + &quot;&quot;); &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.i(TAG, &quot;number = &quot; + number); &#125; &#125;); 输出如下： 123456hahcode = 2number = 2hahcode = 4number = 4hahcode = 6number = 6 debounce通俗点讲，就是N个事件发生的时间间隔太近，就过滤掉前N-1个事件，保留最后一个事件。debounce可以指定这个时间间隔！可以用在SearchEditText请求关键词的地方，SearchEditText的内容变化太快，可以抵制频繁请求关键词，后面第15条15.Subject会介绍这个。为了演示效果，先举个简单栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344Observable .create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; int i = 0; int[] times = new int[]&#123;100, 1000&#125;; while (true) &#123; i++; if (i &gt;= 100) break; subscriber.onNext(i); try &#123; // 注意！！！！ // 当i为奇数时，休眠1000ms，然后才发送i+1，这时i不会被过滤掉 // 当i为偶数时，只休眠100ms，便发送i+1，这时i会被过滤掉 Thread.sleep(times[i % 2]); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; subscriber.onCompleted(); &#125; &#125;) // 间隔400ms以内的事件将被丢弃 .debounce(400, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; Log.i(TAG, &quot;complete&quot;); &#125; @Override public void onError(Throwable e) &#123; Log.e(TAG, e.toString()); &#125; @Override public void onNext(Integer integer) &#123; Log.i(TAG, &quot;integer = &quot; + integer); &#125; &#125;); 输出结果： 1234567891011-23 10:44:45.167 MainActivity: integer = 111-23 10:44:46.270 MainActivity: integer = 311-23 10:44:47.373 MainActivity: integer = 511-23 10:44:48.470 MainActivity: integer = 711-23 10:44:49.570 MainActivity: integer = 911-23 10:44:50.671 MainActivity: integer = 1111-23 10:44:51.772 MainActivity: integer = 1311-23 10:44:52.872 MainActivity: integer = 1511-23 10:44:53.973 MainActivity: integer = 17... 我们设置过滤条件为400ms，可以发现，奇数正常输出，因为在它的下一个事件事件隔了1000ms，所以它不会被过滤掉；偶数被过滤掉，是因为它距离下一个事件（奇数）只隔了100ms。并且，输出的两个事件相隔大约为 100ms + 1000ms &#x3D; 1100ms。 merge用于合并两个Observable为一个Observable。较为简单。 12Observable.merge(Observable1, Observable2) .subscribe(subscriber); concat顺序执行多个Observable，个数为1 ~ 9。例子稍后与first操作符一起~~ compose 与 flatMap 类似，都是进行变换，返回Observable对象，激活并发送事件。 compose 是唯一一个能够从数据流中得到原始Observable的操作符，所以，那些需要对整个数据流产生作用的操作（比如，subscribeOn()和observeOn()）需要使用 compose 来实现。相较而言，如果在flatMap()中使用subscribeOn()或者observeOn()，那么它仅仅对在 flatMap 中创建的Observable起作用，而不会对剩下的流产生影响。这样就可以简化subscribeOn()以及observeOn()的调用次数了。 compose 是对 Observable 整体的变换，换句话说， flatMap 转换Observable里的每一个事件，而 compose 转换的是整个Observable数据流。 flatMap 每发送一个事件都创建一个 Observable，所以效率较低。而 compose 操作符只在主干数据流上执行操作。 建议使用 compose 代替 flatMap。 first只发送符合条件的第一个事件。可以与前面的contact操作符，做网络缓存。举个栗子：依次检查Disk与Network，如果Disk存在缓存，则不做网络请求，否则进行网络请求。12345678910111213141516171819202122232425262728293031323334353637// 从缓存获取Observable&lt;BookList&gt; fromDisk = Observable.create(new Observable.OnSubscribe&lt;BookList&gt;() &#123; @Override public void call(Subscriber&lt;? super BookList&gt; subscriber) &#123; BookList list = getFromDisk(); if (list != null) &#123; subscriber.onNext(list); &#125; else &#123; subscriber.onCompleted(); &#125; &#125;&#125;);// 从网络获取Observable&lt;BookList&gt; fromNetWork = bookApi.getBookDetailDisscussionList();Observable.concat(fromDisk, fromNetWork) // 如果缓存不为null，则不再进行网络请求。反之 .first() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;BookList&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(BookList discussionList) &#123; &#125; &#125;); 网络缓存用法，具体可参见我的项目：[https://github.com/JustWayward/BookReader](https://github.com/JustWayward/BookReader) timer可以做定时操作，换句话讲，就是延迟执行。事件间隔由timer控制。举个栗子：两秒后输出“Hello World！”1234567891011121314151617Observable.timer(2, TimeUnit.SECONDS) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Long aLong) &#123; Log.i(TAG, &quot;Hello World!&quot;); &#125; &#125;); interval定时的周期性操作，与timer的区别就在于它可以重复操作。事件间隔由interval控制。举个栗子：每隔两秒输出“Hello World！”1234567891011121314151617Observable.interval(2, TimeUnit.SECONDS) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Long aLong) &#123; Log.i(TAG, &quot;Hello World!&quot;); &#125; &#125;); throttleFirst与debounce类似，也是时间间隔太短，就丢弃事件。可以用于防抖操作，比如防止双击。123456789101112131415161718RxView.clicks(button) .throttleFirst(1, TimeUnit.SECONDS) .subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Object o) &#123; Log.i(TAG, &quot;do clicked!&quot;); &#125; &#125;);上面这个RxView详见：https://github.com/JakeWharton/RxBinding， 主要与RxJava结合用于一些View的事件绑定，JakeWharton大神的项目，厉害。 SingleSingle与Observable类似，相当于是他的精简版。订阅者回调的不是OnNext&#x2F;OnError&#x2F;onCompleted，而是回调OnSuccess&#x2F;OnError。 12345678910111213141516Single.create(new Single.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(SingleSubscriber&lt;? super Object&gt; subscriber) &#123; subscriber.onSuccess(&quot;Hello&quot;); &#125;&#125;).subscribe(new SingleSubscriber&lt;Object&gt;() &#123; @Override public void onSuccess(Object value) &#123; Log.i(TAG, value.toString()); &#125; @Override public void onError(Throwable error) &#123; &#125;&#125;); SubjectSubject这个类，既是Observable又是Observer，啥意思呢？就是它自身既是事件的生产者，又是事件的消费者，相当于自身是一条管道，从一端进，又从另一端出。举个栗子：PublishSubject 12345678910111213141516171819202122Subject subject = PublishSubject.create();// 1.由于Subject是Observable，所以进行订阅subject.subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Object o) &#123; Log.i(TAG, o.toString()); &#125;&#125;);// 2.由于Subject同时也是Observer，所以可以调用onNext发送数据subject.onNext(&quot;world&quot;); 这个好像有点厉害的样子，哈哈。可以配合debounce，避免SearchEditText频繁请求。 12345678910111213141516171819202122232425262728293031323334Subject subject = PublishSubject.create();subject.debounce(400, TimeUnit.MILLISECONDS) .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Object o) &#123; // request &#125; &#125;);edittext.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; subject.onNext(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); RxJava 应用RxJava+Retrofit 的网络请求方式 Retrofit是一个非常适合RestAPI的网络请求库。没用过的童鞋，还是推荐学一学的。 使用Callback的请求方式： 1234567891011121314151617181920212223242526272829303132// 1. 定义一个请求接口@GET(&quot;/match/stat&quot;)Call&lt;String&gt; getMatchStat(@Query(&quot;mid&quot;) String mid, @Query(&quot;tabType&quot;) String tabType);// 2. 创建Service对象Retrofit retrofit = new Retrofit.Builder() .baseUrl(BuildConfig.TENCENT_SERVER) // 加入RxJava支持 .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(ScalarsConverterFactory.create()) .client(OkHttpHelper.getTecentClient()).build();TencentApi api = retrofit.create(TencentApi.class);// 3. 调用Call&lt;String&gt; call = api.getMatchStat(mid, tabType);call.enqueue(new Callback&lt;String&gt;() &#123; @Override public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) &#123; if(response != null &amp;&amp; response.body()!=null) // 成功 &#125; else &#123; // 无数据 &#125; &#125; @Override public void onFailure(Call&lt;String&gt; call, Throwable t) &#123; // 失败 &#125;&#125;); 与 RxJava 结合的方式，则是 123456789101112131415161718192021222324252627// 1. 定义请求接口，返回的是Observable对象@GET(&quot;/user/followers&quot;)Observable&lt;List&lt;User&gt;&gt; followers();// 2. 同样是创建api对象...// 3. 请求api.followers() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; // 请求出错。可能发生网络异常、Json解析异常等等 &#125; @Override public void onNext(List&lt;User&gt; list) &#123; // 请求成功 view.showMyFollowers(list); &#125; &#125;); 若需嵌套请求，比如先获取Token再进行才能进行登录，可参考flatMap操作符最后的获取Readme内容显示在WebView上的例子。 Retrofit2 + RxJava + Dagger2: 具体可参见我的项目，里面有比较详细的用法。https://github.com/JustWayward/BookReader 不难发现，Retrofit 把请求封装进 Observable ，在请求结束后调用 onNext() 以及 OnCompleted() 或在请求失败后调用 onError()。 注：RxJava形式的请求，并不能减少代码量，但是逻辑非常清晰。假如请求到数据之后需要对数据进行处理，并且是耗时操作，难道要再开一个线程，或者用AsyncTask再做一次异步？很显然，RxJava的变换很好的解决了这个问题，依然会使逻辑结构清晰。 RxBus准确的来说，是一种基于RxJava实现事件总线的一种思想。可以替代EventBus&#x2F;Otto，因为他们都依赖于观察者模式。可以参考https://github.com/AndroidKnife/RxBus这个库。 RxBinding前面介绍过了，JakeWharton大神的项目，https://github.com/JakeWharton/RxBinding， 主要与RxJava结合用于一些View的事件绑定。 RxJava 的一些坑未取消订阅而引起的内存泄漏举个栗子，对于前面常用操作符12.interval做周期性操作的例子，并没有使之停下来的，没有去控制订阅的生命周期，这样，就有可能引发内存泄漏。所以，在Activity#onDestroy()的时候或者不需要继续执行的时候应该取消订阅。 12345678910111213141516171819Subscription subscription = Observable.interval(2, TimeUnit.SECONDS) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Long aLong) &#123; Log.i(TAG, &quot;Hello World!&quot;); &#125; &#125;);// 调用unsubscribe();方法进行取消订阅subscription.unsubscribe(); 但是，如果有很多个数据源，那岂不是要取消很多次？当然不是的，可以利用 CompositeSubscription， 相当于一个 Subscription 集合。 1234567CompositeSubscription list = new CompositeSubscription();list.add(subscription1);list.add(subscription2);list.add(subscription3);// 统一调用一次unsubscribe，就可以把所有的订阅都取消list.unsubscribe(); 总结相信到了这里，大家对RxJava应该有了一个比较清晰的理解。当然，实践出真知，还是要去尝试，才能更深层次的体会到其强大之处。 最后，总结一下RxJava的基本使用过程。 首先是创建事件源源，也就是被观察者，可以用Observable的create&#x2F;just&#x2F;from等方法来创建; 通过filter&#x2F;debounce等操作符，进行自定义事件过滤； 通过Schedules进行事件发送和订阅的线程控制，也就是subscribeOn() 和 observeOn(); 通过map&#x2F;flatMap&#x2F;compose等操作符，进行事件的变换； 调用subscribe进行事件订阅； 最后，不要忘了对订阅者生命周期的控制，不用的时候，记得调用unsubscribe()，以免引发内存泄漏。 感谢阅读！ 参考文章：给 Android 开发者的 RxJava 详解","categories":[{"name":"Java","slug":"Java","permalink":"http://smuyyh.top/categories/Java/"}],"tags":[{"name":"异步","slug":"异步","permalink":"http://smuyyh.top/tags/%E5%BC%82%E6%AD%A5/"},{"name":"RxJava","slug":"RxJava","permalink":"http://smuyyh.top/tags/RxJava/"}]},{"title":"Android 如何应用ttf图标字体库","slug":"android-icon-font","date":"10/11/2016","updated":"06/09/2017","comments":true,"path":"2016/11/10/android-icon-font/","link":"","permalink":"http://smuyyh.top/2016/11/10/android-icon-font/","excerpt":"作为一个Android开发者，自己想做一个app练手，有个比较头疼的问题就是没有UI图标资源~~ 其实很容易搞定的，下面就来聊聊如何在Android中应用图标字体库，找图标不再纠结！","text":"作为一个Android开发者，自己想做一个app练手，有个比较头疼的问题就是没有UI图标资源~~ 其实很容易搞定的，下面就来聊聊如何在Android中应用图标字体库，找图标不再纠结！ 图标库传送门：https://icomoon.io/app/#/select 1、点击左上角菜单 -&gt; Manager Projects 进入管理页面。 2、点击New Project, 创建一个工程，如First App并点击Load&gt; 3、点击Add Icon From Libray，去选择自己喜欢的Library，点击**+Add**添加到工程里面。Library有收费的，也有免费的，视情况而定。 4、转到资源页面。选择自己想要下载的图标，怎么都是灰色的？安啦，后面有惊喜！ 5、点击右下角Generate Font，生成ttf字体库。 上面四个图标就是我前面选中的，下面的诸如e911文字就是图标对应的unicode符号，中文字体也是这么一个道理。点击download下载字体库。 6、下载完成，解压。拷贝fonts&#x2F;icomoon.ttf 到 android-assets&#x2F;fonts 下面。 7、应用字体。首先建一个字体“映射”类，反正官方不太推荐用枚举方式，暂且就用注解吧~~ 打开刚才解压包里面的demo.html，对应来创建字体映射。 12345678910111213141516171819202122import android.support.annotation.StringDef;/** * @author yuyh. * @date 2016/11/10. */@StringDef(&#123; MDFonts.HOME, MDFonts.NEWSPAPER, MDFonts.MUSIC, MDFonts.PLAY&#125;)public @interface MDFonts &#123; String HOME = &quot;\\ue902&quot;; String NEWSPAPER = &quot;\\ue904&quot;; String MUSIC = &quot;\\ue911&quot;; String PLAY = &quot;\\ue912&quot;;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import android.content.Context;import android.graphics.Typeface;import android.widget.TextView;/** * @author yuyh. * @date 2016/11/10. */public class MDFontsUtils &#123; public static Typeface OCTICONS; /** * Get octicons typeface * * @param context * @return octicons typeface */ public static Typeface getOcticons(final Context context) &#123; if (OCTICONS == null) OCTICONS = getTypeface(context, &quot;fonts/icomoon.ttf&quot;); return OCTICONS; &#125; /** * Set octicons typeface on given text view(s) * * @param textViews */ public static void setOcticons(final TextView... textViews) &#123; if (textViews == null || textViews.length == 0) return; Typeface typeface = getOcticons(textViews[0].getContext()); for (TextView textView : textViews) textView.setTypeface(typeface); &#125; /** * Get typeface with name * * @param context * @param name * @return typeface */ public static Typeface getTypeface(final Context context, final String name) &#123; return Typeface.createFromAsset(context.getAssets(), name); &#125;&#125; 9、图标对应是用TextView表示，而不是ImageView。如下： 12345678910111213&lt;TextView android:id=&quot;@+id/tvMusic&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; android:textSize=&quot;16dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/tvHome&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; android:textSize=&quot;16dp&quot; /&gt; 在Java中应用字体。如下： 12345678tvMusic = (TextView) findViewById(R.id.tvMusic);tvMusic.setText(MDFonts.MUSIC);tvHome = (TextView) findViewById(R.id.tvHome);tvHome.setText(MDFonts.HOME);// 应用字体MDFontsUtils.setOcticons(tvMusic, tvHome); run起来，大功告成！ 10、你会发现，run起来图标颜色全是Android默认的灰色，那么怎么更改图标颜色呢？刚才说了，图标字体用的是TextView，实际上他跟中文英文字体没什么两样，他本质上还是文字。所以，TextView怎么设置字体大小、字体颜色，这里就对应怎么设置。如下： 12tvHome.setTextColor(Color.RED);tvHome.setTextSize(50); 哈哈，没毛病！ 当然，也可以把字体符号配置在string.xml 1&lt;string name=&quot;icon_home&quot; translatable=&quot;false&quot;&gt;\\ue902&lt;/string&gt; 12345678&lt;TextView android:id=&quot;@+id/tvHome&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; android:textSize=&quot;16dp&quot; android:text=&quot;@string/icon_home&quot; /&gt; 12// 当然，还需要下面这步来应用设置MDFontsUtils.setOcticons(tvHome); 更多用法大家就自行扩展吧！比如可以自定义一个TextView，直接应用字体，就不需要MDFontsUtils.setOcticons(tvHome); 这步操作了，自己用就可以啦！ 感谢阅读！","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[]},{"title":"关于Retrofit2+Okhttp3实现统一添加请求参数和重定向","slug":"retrofit-okhttp-param-redirection","date":"08/11/2016","updated":"06/09/2017","comments":true,"path":"2016/11/08/retrofit-okhttp-param-redirection/","link":"","permalink":"http://smuyyh.top/2016/11/08/retrofit-okhttp-param-redirection/","excerpt":"Android开发中难免会遇到一些比较“不友好”的服务端接口。比如以前遇到的json数据中，某个字段偶尔为Object，偶尔为List… 最近遇到的一个问题就是：所有请求接口都要增加一个token参数… 并且token参数有可能过期，比如请求某一条接口，如果token失效则在该请求的响应中把新的token带回来，客户端就得用新的token再次发送该请求，类似重定向。","text":"Android开发中难免会遇到一些比较“不友好”的服务端接口。比如以前遇到的json数据中，某个字段偶尔为Object，偶尔为List… 最近遇到的一个问题就是：所有请求接口都要增加一个token参数… 并且token参数有可能过期，比如请求某一条接口，如果token失效则在该请求的响应中把新的token带回来，客户端就得用新的token再次发送该请求，类似重定向。 token失效的stateCode为3，新的token在data字段中返回。如下： 12345&#123; &quot;stateCode&quot;:3, &quot;data&quot;:&quot;E78kH6&quot;, &quot;errorMsg&quot;:null&#125; 庆幸的是，Okhttp提供了强大的拦截器功能，是一种能够监控，重写，重试调用的强大机制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class TokenInterceptord implements Interceptor &#123; private final String TAG = &quot;respond&quot;; @Override public Response intercept(Chain chain) throws IOException &#123; Request oldRequest = chain.request(); String url = oldRequest.url().toString(); Response response = null; // 新的请求,添加参数 Request newRequest = addParam(oldRequest); response = chain.proceed(newRequest); ResponseBody value = response.body(); byte[] resp = value.bytes(); String json = new String(resp, &quot;UTF-8&quot;); // 判断stateCode值 try &#123; JSONObject jsonObject = new JSONObject(json); int stateCode = jsonObject.optInt(&quot;stateCode&quot;); if (stateCode == 3) &#123; String data = jsonObject.optString(&quot;data&quot;); Log.d(TAG, &quot;token失效，新的token：&quot; + data); DataStorageUtils.saveToken(data); // token失效，重新执行请求 Request newTokenRequest = addParam(oldRequest); response = chain.proceed(newTokenRequest); &#125; else &#123; // 这里值得注意。由于前面value.bytes()把响应流读完并关闭了，所以这里需要重新生成一个response，否则数据就无法正常解析了 response = response.newBuilder() .body(ResponseBody.create(null, resp)) .build(); &#125; &#125; catch (Exception e) &#123; &#125; return response; &#125; /** * 添加公共参数 * * @param oldRequest * @return */ private Request addParam(Request oldRequest) &#123; HttpUrl.Builder builder = oldRequest.url() .newBuilder() .setEncodedQueryParameter(&quot;lversion&quot;, PackagesUtils.getAppVersionName()) .setEncodedQueryParameter(&quot;token&quot;, DataStorageUtils.getToken()); Request newRequest = oldRequest.newBuilder() .method(oldRequest.method(), oldRequest.body()) .url(builder.build()) .build(); return newRequest; &#125; &#125; 当然，也可以为请求或响应添加Header。 1234567Request request = oldRequest.newBuilder() .header(&quot;Content-Encoding&quot;, &quot;gzip&quot;) .build();Response response = response.newBuilder() .header(&quot;Content-Encoding&quot;, &quot;gzip&quot;) .build(); 然后为OkHttp配置一个拦截器。 12345678910public static OkHttpClient getOkHttpClient() &#123; Interceptor interceptor = new TokenInterceptor(); OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(30 * 1000, TimeUnit.MILLISECONDS) .readTimeout(30 * 1000, TimeUnit.MILLISECONDS) .addInterceptor(interceptor) .addInterceptor(new HttpLoggingInterceptor(new MyLog()).setLevel(HttpLoggingInterceptor.Level.BODY)) .build(); return client; &#125; Retrofit 使用 Okhttp作为client 12345678Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(ScalarsConverterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .baseUrl(baseUrl) .client(getOkHttpClient()) .build();Api api = retrofit.create(Api.class);","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"http://smuyyh.top/tags/Retrofit/"},{"name":"OkHttp","slug":"OkHttp","permalink":"http://smuyyh.top/tags/OkHttp/"}]},{"title":"一个 2 年 Android 开发者的 18 条忠告","slug":"android-18-advice","date":"08/11/2016","updated":"06/09/2017","comments":true,"path":"2016/11/08/android-18-advice/","link":"","permalink":"http://smuyyh.top/2016/11/08/android-18-advice/","excerpt":"原文：What 2 Years of Android Development Have Taught Me the Hard Way 前言 我仍记得2014年我决定做Android开发的那天，这是我一生中做出的最好决定之一。到现在已经有2年半了。 最初的时候，并没有人告诉我如何做才是正确的。我犯了很多错误，也浪费了很多得时间。 一年半之后，我有机会和一个真正有才而且经验丰富的Android开发者一起工作，他指导我，并教我正确的做事方式。这期间我学到了很多东西，学会了该做什么不该做什么。 我直接或者间接帮助其它开发者也有很长一段时间了。这里是我的StackOverflow和Github的简介。 本文我将分享这几年所收集的精华。也许可以帮助大家更快上手Android，避免重复我犯的错误。","text":"原文：What 2 Years of Android Development Have Taught Me the Hard Way 前言 我仍记得2014年我决定做Android开发的那天，这是我一生中做出的最好决定之一。到现在已经有2年半了。 最初的时候，并没有人告诉我如何做才是正确的。我犯了很多错误，也浪费了很多得时间。 一年半之后，我有机会和一个真正有才而且经验丰富的Android开发者一起工作，他指导我，并教我正确的做事方式。这期间我学到了很多东西，学会了该做什么不该做什么。 我直接或者间接帮助其它开发者也有很长一段时间了。这里是我的StackOverflow和Github的简介。 本文我将分享这几年所收集的精华。也许可以帮助大家更快上手Android，避免重复我犯的错误。 1.不要重复造轮子 最初，我有一种不愿使用开源库的思想。不管需要什么，我总想自己去实现，这是一种非常可怕的思想。 如果在开发app的时候遇到一个问题，而这个问题已经被别人很好的解决了，为什么不去使用它呢？这样你可以节省大量时间啊！ 把更多的精力花在app的业务逻辑上吧。如果你想在app中发起一个网络调用，是不需要自己去造一个Retrofit的。 2. 不要盲目的选择library 在Github上有许多免费使用的开源库，但是别因太激动而盲目的使用。 检查library的star数目，越多越好。看看作者是否还创建了其它的一些受欢迎的库。查看issues（打开和关闭的都看），这可以让你对这个library的健壮性和稳定性有更好的了解。 如果你时间充足，你应该深入这个库的代码看看它到底是都真的值得使用。 你只需要确保它的代码是可靠的，bug不多的，高质量的。 小贴士：使用Dryrun的命令行尝试任何library。 3. 坐下来，喝杯咖啡，阅读更多的代码 我们在阅读别人代码上花的时间比自己写代码的时间多得多，如果你不是的话，从今天就开始做吧。 不管你现在能写出什么样的代码，总是因为在某年某月你阅读和学习到了什么东西。它只是你已有知识的反映。 安卓的伟大之处就在于它是一个完全开源的平台。可以去深入研究这些代码看看他们是如何实现framework的。Github中有成千上万的开源库，只需选择一个看看人家是如何实现的。 福利：这里是一些最佳library的列表，这里是几乎所有开源安卓app的列表。 4. 看在上帝的份上，维护一个恰当的编程规范吧 如果把编码比作写作，那么编程规范就是你的书法水平。 就跟你阅读别人的代码一样，别人也会阅读你的代码，我想你也不想把别人吓到是吧？如果你在一个公司，需要和同事协同工作，那么务必重视这个问题。 编写简短，干净，可读性强的代码可以让你和别人读代码的时候很享受。代码应该读起来像是读故事一样。 代码是诗。 如果你写了一段代码结果你的同事几天都不跟你说话，怨不得别人。 福利：你应该从通读这个和这个开始。 5. 你需要混淆，是的，真的需要！ 绝对不要犯还没有使用ProGuard的情况下就在Play Store上发布app的错误。ProGuard不仅仅减小了你的代码，还混淆了代码，让逆向工程师更难理解和复制。 它是Android SDK附带的，完全免费，因此没有理由不用。 我曾见过几个开发者没有使用ProGuard就把app发布了。对于一个技术很普通的黑客来说破解你的app也就是几个小时的事情。 小贴士：但是如果你需要顶尖的安全性，ProGuard就力不从心了，你需要DexGuard。 6. 使用一个恰当的架构 你永远都会庆幸自己从一开始就选择了一个恰当的架构。 你可以使用MVP (Model-View-Presenter)架构，它可以把你的代码解耦成不同的层便于管理，从而提高代码的灵活性并极大的减小维护的时间成本。 可以参考一个demo项目。如果觉得很难掌握，可以看看这篇针对初学者的指南。 福利：务必看看这里,这里尤其是这里。它们将为你实现MVP提供极大的帮助。 7.用户界面就像笑话，如果还需要解释那就糟糕了 如果你是在公司，做的是纯安卓开发，你很可能不需要关心这个问题，因为有UI&#x2F;UX设计师管这个问题。 但是如果你是一个独立开发者，你就需要考虑它了。我曾经见过一些把app功能做的很好，但是用户体验很恐怖的开发者。 要设计一个干净，简单直观的界面，你不要站在开发者的角度思考问题，而要挖掘自己内心中埋藏的设计师的潜力。 尽量尝试设计一个漂亮的界面，让你的用户持续保持印象，这样用户回到你的app的次数就比别人多，从而产生更多的收获（也许是购买高级版本）。 你应该乐于去减少元素，而不是增加。保持简洁和小巧。 福利：你可以从Dribble或者MaterialUp的热门设计师那里获得灵感。如果你对设计感兴趣，你很可能会喜欢这本书。 8. 分析是你最好的朋友 如果你想创建一个真正令人惊叹的app，你需要重度依赖分析工具去分析app不同部分的性能和用例。 对于分析，我借助于crash reporting和app usage tracking。 不管你怎么做，永远无法做到完美。当真实的用户开始在各种各样的设备以及版本上使用你的app的时候，你会发现即时写的最好的代码也难以保证不出岔子。 一旦发生崩溃，Crash reporting工具可以帮助你跟踪与修复它们。 你必须学会像销售那样思考问题并分析app不同模块的使用。这样可以帮助你减小产品和用户实际需求之间的落差。 小贴士：使用FirebaseCrash Reporting以及Analytics tools。 9. 做一个营销专家 如果你是一个个人开发者，你必须超出作为开发者的思维，去理解市场。 我见过一些很好的产品因为缺乏正确的市场营销而失败，同时也见过并不怎么样的产品因为牛逼的市场营销而取得极大成功。 如果你对你的工作是认真的希望它能获得可观的用户，你必须把在市场营销上花费必要的时间和金钱。但是在营销活动开始之前，确保app已经完全稳定，功能已经完善。 花时间研究谁是你的竞争对手以及如何打败他们。确定一个可以立即打败的以及一个将来会打败的。 小贴士：这里是一个价钱合理的市场分析工具，我比较喜欢用。 10. 是时候优化你的app了 这是一个大多数人都不会去做的事情，但是你应该做。 写代码与写高性能的代码之间有很大的区别。高性能的代码是指运行速度快，内存和存储消耗更少的代码。 一个未经优化的的app也许在普通情况下运行良好，但是当放在各种压力情景中，它就原形毕露了。检查你app的内存使用情况看看有没有内存泄漏存在。记住小漏不补沉大船。花时间弄懂Java的内存回收机制是怎么回事，创建并分析你的活对象。 小贴士：可以使用Leak Canary检测你的内存泄漏。它可以节省你不少时间。 11. 每周在Gradle编译上最少节省5小时 你极有可能正在使用Android Studio开发app，编译系统使用的是Gradle。Gradle很棒但是也很慢，当项目显著增大的时候慢得根蜗牛样。 有时候工作忙的时候我还需要在Gradle编译上浪费差不多一个小时。 但是，总有加速的办法。 你可以照着这篇以及这篇文章的做法显著提高编译速度。经过优化之后我的编译时间从4分钟降到了30秒钟。 12.测试，测试，再测试！ 没有什么比测试更重要的了。它应该是你的首要任务。 尽可能全面的测试你的app。花时间写自动化测试用例，创造各种极端的条件，看看你的app是否能经受住考验。 我曾经犯过未经充分测试就发布app的错误。等用户报告bug然后修复。 绝对不要那样做。你可能通过砍掉测试时间而节省了一两天或者一周，但是以后你很可能会花双倍的时间。 做任何事都要不慌不忙，从容应对并长远打算。做一个有远见的人。此时播种，以后总会有收获。 13. 安卓的碎片化是魔鬼 碎片化可能是安卓最大的问题了。而谷歌似乎并不愿意修复它，你必须适应。 安卓设备种类繁多，不同屏幕尺寸，不同硬件配置以及各个厂商的自定义系统。 除此之外，谷歌在不同版本上还莫名其妙的添加或者删除API，进一步加重了你的工作量（这里是一个例子）。 比如，几乎每个开发者都需要使用SharedPreferences API来完成一个app，它是如此常见，但是在Android 2.2版本的Samsung Galaxy S 上还是出问题了（bug报告这里）。 花更多的时间为不同屏幕尺寸的设备创建不同的布局。在不同版本，不同定制，不同OEM厂商的设备上测试。 永远别觉得某个东西看似可行就不去测试了。 14. 从今天开始使用git！ 如果你还没有使用Git，从现在开始吧。 当我开始安卓开发的时候，悲剧的我并不知道git是什么东西。我每天都拷贝整个项目，一个备份在硬盘上，一个备份在云盘上。看起来很傻是吗？是的，的确很傻。 Git可以极大的提高你的工作效率。如果叫我说出一个我每天都要使用并且离不开的工具的名字，那就是Git了。 在你使用几天之后，你很可能会爱上它，并好奇Git的内部工作原理。建议你看看这个。 过了一段时间之后，你可能开始了一个大项目，对于如何维护一个分支模型感到困惑，那么可以看看这个。 福利：如果你刚刚开始，还付不起GitHub的私人仓库的月费，你可以试试BitBucket。国内用户的选择更多，oschina的git服务也不错－译者注。 15.为黑客制造麻烦 安卓的开源特性让其易受攻击。每个安卓app都可以轻易的被反编译，逆向分析。 你不希望你的app发生这种事对吧？ 你需要知道如何安全的存储app中的API keys。如果你要处理用户的敏感数据，你必须知道如何加密，选择何种加密算法（安全且快速）。 你还应该安全的把密钥存储在本地或者服务器上。应该防止app数据被人用ADB备份。如果你在数据库中存储敏感数据，要考虑做适当的伪装。 如果你的app有高级版本，被别人破解免费发布就损失大了。 有几种方法可以避免你的app被人篡改。但并不是100&amp;安全。任何一个技术扎实，决心坚决的黑客只要有正确的资源，工具和耐心都可以破解你的app。 你能做的就是尽量让黑客的破解变得困难，及其困难。 福利：可以从阅读这个和这个开始。 16. 在低端手机上开发 每个人都喜欢使用一个高端安卓手机，我也是。但是记得只作为个人使用，而不是开发的目的。 高端机会隐藏app的许多缺陷。假设你在UI线程上做了导致卡顿的事情，但是因为手机过于强大，可能导致你无法察觉。 17. 学习设计模式 这是一项终生受益的投资。 在开发大型app的时候，你会遇到一些已经被比你牛逼的人所解决了的问题。 从今天开始就花点时间去学习设计模式。这里是一个演示了所有已知设计模式的的Github项目。 可以从最常见的开始，比如单例，适配器模式，工厂方法模式，迭代模式，依赖注入模式，事件驱动架构，建造者模式，回调，策略模式，外观模式以及生产消费者模式。 看起来很多是吧？实际上并不多。一旦深入你就会爱上它们的。 小贴士：阅读一些书籍，比如GoF的 Design Patterns，Martin Fowler的重构以及Joshua Bloch的Effective Java。 18. 回馈 你得承认，我们都曾从别人和互联网那得到许多帮助。 每当你遇到问题的时候，你会做的第一件事就是谷歌，发现第一条来自StackOverflow的链接。有时候你很忙，结果直接拷贝粘贴得分最高的答案。 你有没有想过Github上那些开源库其实也是别人花时间创建然后贡献给社区的。 当你被一个难以理解的概念卡住或者遇到一个新的东西时，你发现一篇让你豁然开朗的博客，这个时候记住是某人牺牲了约炮时间而写了这篇文章。 所以也该你回馈了。给予的越多，得到的也就越多。 我们都忙于自己的工作，很难找到时间为别人做什么事情。但是尽量每周找点时间做点贡献让安卓社区更丰富。 我已经分享了自己短暂的安卓生涯中所学到的一些东西。我将继续下去，学更多，分享更多。希望能为别人的生活带来微小的帮助。","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[]},{"title":"10 个你有可能不知道的Android Studio技巧","slug":"android-10-technique","date":"11/10/2016","updated":"06/09/2017","comments":true,"path":"2016/10/11/android-10-technique/","link":"","permalink":"http://smuyyh.top/2016/10/11/android-10-technique/","excerpt":"英文原文：medium Android Studio 是每一个 Android 开发每天都要使用的工具，但是即使你是一个经验丰富的开发人员，你也可能已经错过了许多可以节约生命的技巧，这篇文章也许就可以帮助你掌握它们其中的一部分。我不会一字一句地翻译，而是以最简洁易懂的方式介绍给你，同时提供必要的注解和延伸，让你可以在一遍快速阅读之后迅速掌握。","text":"英文原文：medium Android Studio 是每一个 Android 开发每天都要使用的工具，但是即使你是一个经验丰富的开发人员，你也可能已经错过了许多可以节约生命的技巧，这篇文章也许就可以帮助你掌握它们其中的一部分。我不会一字一句地翻译，而是以最简洁易懂的方式介绍给你，同时提供必要的注解和延伸，让你可以在一遍快速阅读之后迅速掌握。 当你想不起来某个功能怎么用的时候如果你是 Windows&#x2F;Linux 用户, 那么请按Ctrl + Shift + A， 如果你是 Mac 用户，那么请按Command + Shift + A，在这个万能的输入框内可以输入你想要执行的操作（当然是英文），列表中会显示对应的可选操作以及快捷键。不仅仅是操作，如果你只是想改变某个设置的时候，也可以使用这个功能，例如你想设置Gradle为 offline work 的话，可以在输入框输入offline，对应的的结果中选择Toggle Offline Work即可，再比如你需要打开粘贴代码时候的Auto Import功能，那么也只要在输入框中输入Auto Import然后选择对应项即可。 修改快捷键在 Android Studio 中所有快捷键都是可以自定义的。请唤起伟大的Ctrl + Shift + A，输入keymap，选择位于Settings &gt; Keymap的那个选项，这里能看到所有的快键键，一般不建议在原有快捷键方案上直接修改快捷键，而是拷贝一份现有的方案再在上面改，在Keymaps的下拉框中选择一份现有的方案（默认为 Default），点击右边的Copy，然后在列表中需要修改的快捷键的项目上右键，选择Add Keyboard Shortcut，然后就可以设置自己喜欢的快捷键了，如果设置的快捷键与其它按键有冲突，会以红色错误信息提示。 由于列表中快捷键数量比较多，所以我们还可以利用右边的搜索框进行搜索，例如需要修改基本自动补全的快捷键我们只要输入Basic，就可以在结果中找到对应的项了。 你需要了解的自动补全一般使用 Android Studio 的时候，自动提示会在你想要提示的时候自动出现，比如输入Log.，就会提示一堆比如Log.d(), Log.e, Log.i()。不过如果你在自动提示的时候手一抖选错的话，比如想选Log.d()结果选了Log.e()，你是不是会把.e()都删掉，然后再输入一个.，其实遇到这种需要重新手动呼起自动补全的情形只需要使用Ctrl + Alt + 空格就可以了。 其实还有两种方法：一是基本补全Ctrl + 空格，然而 Windows 用户表示不开心，因为这和 Windwos 系统切换输入法快捷键冲突，如果你不想修改这个快捷键，那么使用Ctrl + Alt + 空格作为替代，如果你想修改这个快键键，那么你可以使用上一小节的方法设置新的快捷键，在Keymaps界面搜索Basic，然后在过滤后的结果中选择Code-&gt;Completion-&gt;Basic进行设置；另一种方法是智能补全Ctrl + Shift + 空格, 不过智能补全远远不止这个功能，当你调用方法时，可以使用智能补全在当前上下文联想符合该方法形参类型的变量。 在自动提示以后使用 Tab 键替换当前的方法或值如果我们手动呼出自动补全的时候，当前位置已经有对应的方法或者变量（比如原来调用Obj的A方法，然后我们把光标定位到A方法的位置，呼出自动补全，希望自动补全的B方法代替A方法），这时候如果我们选中补全的的项目，按下回车，那么补全的内容会插入到原来内容的前面，这不是我们想要的内容，其实这时候不应该按回车，而是Tab。 当你写完了一行代码这种情况非常常见，当你写完一行代码的时候，光标并不在当前行的末尾，比较常见的是光标右边还有 N 个 右括号，这时候你会怎么办？可能你会使用方向键把光标移动到行末，然后手动输入一个;。其实有更简单的方案，那就是Ctrl + Shift + 回车，这个快捷键会帮助你自动补全当前表达式所缺的部分，包括在行末输入;，值得一提的是，该快捷键对if，else，for，while控制循环同样有效。 还有一种情况，光标并不在行尾，但是你希望可以在下一行插入一个空行，Shift + 回车可以帮你完成这个任务。 三个定位的小技巧使用 4 个方向键定位光标是我们最熟悉的方法，但是其实可以更方便的。在按方向键的同时按住Ctrl，可以一个单词一个单词移动；在按上下键的同时按住Alt, 可以一个节点（方法或者字段）一个节点移动；如果在按上下键的同时按住Shift + Ctrl，可以把当前行和上下行交换位置。 根据后缀自动生成的代码模板日常使用编辑器的过程中，有很多固定格式的写法，例如if-else, for 等等，使用代码模板可以更快得帮助我们生成期望的代码。举个例子，先输入一个集合类型的变量并且加上后缀.fori，这时候自动提示会提示按照该集合类型生成for循环，同理，布尔类型的表达式加上.if后缀也可以生成以该表达式为条件的if语句。 实际上，上面这两种代码模板是IntelliJ自带的，Android Studio 还提供了许多与 Android 有关的代码模板，比如生成Toast和Parcelable的模板，查看所有可用模板以及自定义模板的方法是首先Ctrl + Shift + A呼出万能的搜索框，输入Live templates，选择位于Settings的Live Templates，在这里就可以看到所有可用的代码模板。 Debug 时自定义对象显示的技巧在调试代码的时候，我们常常需要查看一个对象的值。尤其是自定义的对象，我们常常没有实现它的toString方法，那么这个对象在 IDE 的值就是 ClassName:HashValue 这个样子。我们需要点开这个对象查看它里面各个成员的值。在不实现toString方法的情况下其实有更好的方法。在 Debug 的Variable窗口中右键需要查看的对象，选择View as，既可以设置该对象在 Debug 状态下显示的方式。 总结感谢你看到这里","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://smuyyh.top/tags/Android-Studio/"}]},{"title":"从源码角度分析AsyncTask的用法与原理","slug":"android-asynctask-source","date":"10/09/2016","updated":"06/09/2017","comments":true,"path":"2016/09/10/android-asynctask-source/","link":"","permalink":"http://smuyyh.top/2016/09/10/android-asynctask-source/","excerpt":"AsyncTask 是Android特有的一个轻量级异步抽象类，在类中通过doInBackground()在子线程执行耗时操作，执行完毕在主线程调用onPostExecute()","text":"AsyncTask 是Android特有的一个轻量级异步抽象类，在类中通过doInBackground()在子线程执行耗时操作，执行完毕在主线程调用onPostExecute() 前言众所周知，Android视图的绘制、监听、事件等都UI线程（主线程，Main Thread）执行，如果执行访问网络请求、数据库等耗时操作，可能会阻塞主线程，若阻塞时间超过5秒，可能会引起系统的ANR异常（Application Not Responding）。所以耗时操作需要放在子线程（也称为Worker Thread）执行，这样就避免了主线程的阻塞，然而在线程是不能有更新UI的操作的，比如在子线程调用TextView.setText()就会引发以下错误： 1Only the original thread that created a view hierarchy can touch its views. 故而可以用 “Handle + Thread”的方式，子线程执行耗时操作，通过Handler通知主线程更新UI。但是这个方式略微麻烦，于是便引入了AsyncTask。 AsyncTask特点AsyncTask&lt;Params, Progress, Result&gt; 定义了三种泛型，作用如下： Params：启动AsyncTask任务所需要的参数，在doInBackground方法接收 Progress：后台任务执行进度 Result：后台任务执行完毕之后回馈给onPostExecute的结果 AsyncTask 内部提供了多个方法，子类可重写，会自动在相应的时刻自动调用，并且用户最好不好手动调用以下的方法，避免引起不可预知的错误。以下方法只有doInBackground方法是必须重写的，其他方法可选。 **onPreExecute()**：任务执行之前调用 **doInBackground(Params… params)**：子线程执行任务，在这个方法中是不可以进行UI更新操作的，如果需要更新UI元素，例如展示该任务的执行进度，可以调用publishProgress(Progress… progress)方法来完成。 **onProgressUpdate(Progress… values)**：任务执行进度。可用于进度条显示 **onPostExecute(Result result)**：任务执行完毕 **onCancelled(Result reslut)、onCancelled()**：用户取消任务 最后，调用execute()开启异步任务。 AsyncTask简单使用123456789101112131415161718192021222324252627282930313233343536373839404142434445public void request() &#123; AsyncTask&lt;String, Integer, Integer&gt; task = new AsyncTask&lt;String, Integer, Integer&gt;() &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); Log.i(&quot;AsyncTask&quot;, &quot;准备执行后台任务&quot;); &#125; @Override protected Integer doInBackground(String... params) &#123; String url_1 = params[0]; doRequest(url_1); publishProgress(50); String url_2 = params[1]; doRequest(url_2); publishProgress(100); return 1; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); Log.i(&quot;AsyncTask&quot;, &quot;当前进度&quot; + values[0] + &quot;%&quot;); &#125; @Override protected void onPostExecute(Integer ret) &#123; super.onPostExecute(ret); Log.i(&quot;AsyncTask&quot;, &quot;执行完毕，执行结果&quot; + ret); &#125; &#125;; String url_1 = &quot;https://api.github.com/users/smuyyh&quot;; String url_2 = &quot;https://api.github.com/users/smuyyh/followers&quot;; task.execute(url_1, url_2); // 开启后台任务&#125; 代码较为简单，就不做过多的解释了。后面着重介绍AsyncTask的内部实现机制。 原理分析这一节将从源码的角度来分析一下AsyncTask。以下源码基于Android-23. 开启后台任务之前，首先需要创建AsyncTask的实例，所以还得从构造函数说起。 12345678910111213141516171819202122232425262728public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); // 任务的具体实现 &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 在构造函数中，初始化了两个变量，分别是mWorker与mFuture，mFuture创建的时候传入了mWorker参数，而mWorker本身是一个Callable对象。那么，mFutrue是个什么东西呢？ mFuture是一个FutureTask对象，FutureTask实际上是一个任务的操作类，它并不启动新线程，并且只负责任务调度。任务的具体实现是构造FutureTask时提供的，实现自Callable接口，也就是刚才的mWorker。 AsyncTask对象穿件完毕之后调用execute(Params…)执行，跟进看看1234@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 只有一句话，可知是调用executeOnExecutor进行执行。这里就有个疑问了，sDefaultExecutor是个什么东西？在说这个之前，需要明确一下一下三个事： 1、Android3.0之前部分代码 123456private static final int CORE_POOL_SIZE = 5; private static final int MAXIMUM_POOL_SIZE = 128; private static final int KEEP_ALIVE = 10; private static final ThreadPoolExecutor sExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sWorkQueue, sThreadFactory); 2、在Android3.0之前，AsyncTask执行中最终触发的是把任务交给线池THREAD_POOL_EXECUTOR来执行，提交的任务并行的在线程池中运行，但这些规则在3.0之后发生了变化，3.0之后提交的任务是默认串行运行的，执行完一个任务才执行下一个！ 3、在Android3.0以前线程池里核心线程有5个，任务队列的任务数最大不能超过128个，线程池里的线程都是并行运行的，在3.0以后，直接调用execute(params)触发的是sDefaultExecutor的execute(runnable)方法，而不是原来的THREAD_POOL_EXECUTOR。在Android4.4以后，线程池大小等于 cpu核心数 + 1，最大值为cpu核心数 * 2 + 1。这些变化大家可以自行对比一下。 跟进源码不难发现，sDefaultExecutor实际上是指向SerialExecutor的一个实例，从名字上看是一个顺序执行的executor，并且它在AsyncTask中是以常量的形式存在的，因此在整个应用程序中的所有AsyncTask实例都会共用同一个SerialExecutor。 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; SerialExecutor是使用ArrayDeque这个队列来管理Runnable对象的。当Executor提交一个任务，执行一次execute()，在这里向mTasks队列添加一个Runnable对象。初次添加任务时mActive为null，故接下来会执行scheduleNext()，将mActive指向刚刚添加的runbale，并提交到THREAD_POOL_EXECUTOR中执行。 当AsyncTask不断提交任务时，那么此时mActive不为空了，所以后续添加的任务能得到执行的唯一条件，就是前一个任务执行完毕，也就是r.run()。所以这就保证了SerialExecutor的顺序执行。这个地方其实也是一个坑，初学者很容易在这里踩坑，同时提交多个任务，却无法同步执行。 如果想让其并行执行怎么办？AsyncTask提供了一下两种方式： 123task.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR); task.executeOnExecutor(executor, params); //可以自己指定线程池 继续跟进executeOnExecutor(Executor exec, Params… params)代码123456789101112131415161718192021222324@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 不难看出，最后是调用Executor的execute(Runnable command)方法启动mFuture。默认情况下，sDefaultExecutor就是SerialExecutor类，所以为串行执行。当然用户也可以提供自己的Executor来改变AsyncTask的运行方式。最后在THREAD_POOL_EXECUTOR真正启动任务执行的Executor。 上面已经提到，Execute执行是调用Runnable的run()方法，也就是mFuture的run方法，继续跟进代码 1234567891011121314151617181920212223242526public void run() &#123; if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; runner = null; int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 从第10行代码可发现，最后是调用callable的call()方法。那么这个callable是什么呢？就是初始化mFuture传入的mWorker对象。在前面的构造函数那边可以发现call()方法，我们单独分析一下这个方法 12345678public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result);&#125; 看了这么久，终于发现了doInBackground()，深深松了一口气。执行完之后得到的结果，传给postResult(result)。继续跟进 123456private Result postResult(Result result) &#123; Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 可以发现，最后是通过Handler的方式，把消息发送出去，消息中携带了MESSAGE_POST_RESULT常量和一个表示任务执行结果的AsyncTaskResult对象。而getHandler()返回的sHandler是一个InternalHandler对象，InternalHandler源码如下所示： 12345678910111213141516171819private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 这里对消息的类型进行了判断，如果是MESSAGE_POST_RESULT，就执行finish()，如果是MESSAGE_POST_PROGRESS，就onProgressUpdate()方法。那么什么时候触发如果是MESSAGE_POST_PROGRESS消息呢？就是在publishProgress()方法调用的时候，publishProgress()方法用finial标记，说明子类不能重写他，不过可以手动调用，通知进度更新，这就表明了publishProgress可在子线程执行。 123456protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; sHandler.obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125; &#125; 然后看一下finish()的代码。 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 不难发现，如果当前任务被取消掉了，就会调用onCancelled()方法，如果没有被取消，则调用onPostExecute()方法，这样当前任务的执行就全部结束了。并且，当你再次调用execute的时候，这个时候mStatus的状态为Status.FINISHED，表示已经执行过了，那么此时就会抛异常，这也就是为什么一个AsyncTask对象只能执行一次的原因。 123456789switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;);&#125; 到这里，就非常清晰了吧。彻底的了解了AsyncTask内部实现的逻辑。 总结可以看出，在使用AsyncTask的过程中，有许多需要注意的地方。 由于Handler需要和主线程交互，而Handler又是内置于AsnycTask中的，所以，AsyncTask的创建必须在主线程，execute的执行也应该在主线程。 AsyncTask的doInBackground(Params… Params)方法运行在子线程中，其他方法运行在主线程中，可以操作UI组件。 尽量不要手动的去调用AsyncTask的onPreExecute, doInBackground, publishProgress, onProgressUpdate, onPostExecute 这些方法，避免发生不可预知的问题。 一个任务AsyncTask任务只能被执行一次。否则会抛IllegalStateException异常 在doInBackground()中要检查isCancelled()的返回值，如果你的异步任务是可以取消的话。cancel()仅仅是给AsyncTask对象设置了一个标识位，虽然运行中可以随时调用cancel(boolean mayInterruptIfRunning)方法取消任务，如果成功调用isCancelled()会返回true，并且不会执行 onPostExecute() 方法了，取而代之的是调用 onCancelled() 方法。但是！！！值得注意的一点是，如果这个任务在执行之后调用cancel()方法是不会真正的把任务结束的，而是继续执行，只不过改变的是执行之后的回调方法是 onPostExecute还是onCancelled。可以在doInBackground里面去判断isCancle，如果取消了，那就直接return result; 当然，这种方式也并非非常完美。 Asynctask的生命周期和它所在的activity的生命周期并非一致的，当Activity终止时，它会以它自有的方式继续运行，即使你退出了整个应用程序。另一方面，要注意Android屏幕切换问题，因为这时候Activity会重新创建。","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"AsyncTask","slug":"AsyncTask","permalink":"http://smuyyh.top/tags/AsyncTask/"},{"name":"异步","slug":"异步","permalink":"http://smuyyh.top/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"JS实现类似于微博秀的GitHub挂件","slug":"javascript-github-widget","date":"29/08/2016","updated":"06/09/2017","comments":true,"path":"2016/08/29/javascript-github-widget/","link":"","permalink":"http://smuyyh.top/2016/08/29/javascript-github-widget/","excerpt":"项目地址：https://github.com/smuyyh/GitHubWidgets 先来几张效果图。 GitHub用户信息挂件 GitHub代码库信息挂件 GitHub个人贡献信息挂件 为CSDN博客添加GitHub用户信息挂件","text":"项目地址：https://github.com/smuyyh/GitHubWidgets 先来几张效果图。 GitHub用户信息挂件 GitHub代码库信息挂件 GitHub个人贡献信息挂件 为CSDN博客添加GitHub用户信息挂件 使用方式 User Widget 12&lt;div class=&quot;github-widget&quot; data-username=&quot;smuyyh&quot;&gt;&lt;/div&gt;&lt;script src=&quot;../js/github_user_widget_en.js&quot;&gt;&lt;/script&gt; Repo Widget 123&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/github_repo_widget_en.js&quot;&gt;&lt;/script&gt;&lt;div class=&quot;github-widget-repo&quot; data-repo=&quot;smuyyh/SprintNBA&quot; style=&quot;width:600px&quot;&gt;&lt;/div&gt; or 12345678910&lt;head&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;../css/github_repo_widget_2.css&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;gitinfo&quot; style=&quot;margin:15px 0; width:600px;&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../js/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;var git_name =&quot;/smuyyh/IncrementallyUpdate&quot;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/github_repo_widget_2_en.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; Activity Widget 12345678910111213141516&lt;head&gt; &lt;link href=&quot;../css/github_widget_activity.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;widget-container&quot; style=&quot;width:600px&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../js/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../js/github_widget_activity.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(&#x27;#widget-container&#x27;).activity(&#123; username: &#x27;smuyyh&#x27; &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; 为博客添加GitHub挂件（以CSDN博客为例）管理博客 -&gt; 博客栏目 -&gt; 添加栏目 12345&lt;div class=&quot;github-widget&quot; data-username=&quot;smuyyh&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://rawgit.com/smuyyh/GitHubWidgets/master/js/github_user_widget_en.js&quot;&gt;&lt;/script&gt;&lt;!--js文件真实地址是以raw.githubusercontent.com开头，raw.githubusercontent.com在Response中设置了X-Content-Type-Options:nosniff ，浏览器强制检查资源的MIME。解决方法就是将js链接中的raw.githubusercontent.com换成rawgit.com。 --&gt; 效果","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://smuyyh.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://smuyyh.top/tags/JavaScript/"},{"name":"Github","slug":"Github","permalink":"http://smuyyh.top/tags/Github/"},{"name":"Widget","slug":"Widget","permalink":"http://smuyyh.top/tags/Widget/"}]},{"title":"-bash ：gradlew command not found","slug":"gradlew-command-not-found","date":"28/08/2016","updated":"06/09/2017","comments":true,"path":"2016/08/28/gradlew-command-not-found/","link":"","permalink":"http://smuyyh.top/2016/08/28/gradlew-command-not-found/","excerpt":"","text":"mac下执行gradlew命令时，提示-bash ：gradlew command not found，主要原因是Android Project根目录下地gradlew文件没有执行权限。打开终端，执行以下命令： 1sudo chmod +x gradlew 为gradlew增加可执行权限。 值得一提的是，mac下执行当前目录下的命令需要在前面加上“.&#x2F;”，否则会到环境变量下找相应命令。例如 ./gradlew javadocJar","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[]},{"title":"Android 实现气泡布局/弹窗，可控制气泡尖角方向及偏移量","slug":"android-bubble-popup-window","date":"25/08/2016","updated":"06/09/2017","comments":true,"path":"2016/08/25/android-bubble-popup-window/","link":"","permalink":"http://smuyyh.top/2016/08/25/android-bubble-popup-window/","excerpt":"Android 自定义布局实现气泡弹窗，可控制气泡尖角方向及偏移量。 效果图","text":"Android 自定义布局实现气泡弹窗，可控制气泡尖角方向及偏移量。 效果图 实现首先自定义一个气泡布局。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/** * 气泡布局 */public class BubbleRelativeLayout extends RelativeLayout &#123; /** * 气泡尖角方向 */ public enum BubbleLegOrientation &#123; TOP, LEFT, RIGHT, BOTTOM, NONE &#125; public static int PADDING = 30; public static int LEG_HALF_BASE = 30; public static float STROKE_WIDTH = 2.0f; public static float CORNER_RADIUS = 8.0f; public static int SHADOW_COLOR = Color.argb(100, 0, 0, 0); public static float MIN_LEG_DISTANCE = PADDING + LEG_HALF_BASE; private Paint mFillPaint = null; private final Path mPath = new Path(); private final Path mBubbleLegPrototype = new Path(); private final Paint mPaint = new Paint(Paint.DITHER_FLAG); private float mBubbleLegOffset = 0.75f; private BubbleLegOrientation mBubbleOrientation = BubbleLegOrientation.LEFT; public BubbleRelativeLayout(Context context) &#123; this(context, null); &#125; public BubbleRelativeLayout(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public BubbleRelativeLayout(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(context, attrs); &#125; private void init(final Context context, final AttributeSet attrs) &#123; //setGravity(Gravity.CENTER); ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); setLayoutParams(params); if (attrs != null) &#123; TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.bubble); try &#123; PADDING = a.getDimensionPixelSize(R.styleable.bubble_padding, PADDING); SHADOW_COLOR = a.getInt(R.styleable.bubble_shadowColor, SHADOW_COLOR); LEG_HALF_BASE = a.getDimensionPixelSize(R.styleable.bubble_halfBaseOfLeg, LEG_HALF_BASE); MIN_LEG_DISTANCE = PADDING + LEG_HALF_BASE; STROKE_WIDTH = a.getFloat(R.styleable.bubble_strokeWidth, STROKE_WIDTH); CORNER_RADIUS = a.getFloat(R.styleable.bubble_cornerRadius, CORNER_RADIUS); &#125; finally &#123; if (a != null) &#123; a.recycle(); &#125; &#125; &#125; mPaint.setColor(SHADOW_COLOR); mPaint.setStyle(Style.FILL); mPaint.setStrokeCap(Cap.BUTT); mPaint.setAntiAlias(true); mPaint.setStrokeWidth(STROKE_WIDTH); mPaint.setStrokeJoin(Paint.Join.MITER); mPaint.setPathEffect(new CornerPathEffect(CORNER_RADIUS)); if (Build.VERSION.SDK_INT &gt;= 11) &#123; setLayerType(LAYER_TYPE_SOFTWARE, mPaint); &#125; mFillPaint = new Paint(mPaint); mFillPaint.setColor(Color.WHITE); mFillPaint.setShader(new LinearGradient(100f, 0f, 100f, 200f, Color.WHITE, Color.WHITE, TileMode.CLAMP)); if (Build.VERSION.SDK_INT &gt;= 11) &#123; setLayerType(LAYER_TYPE_SOFTWARE, mFillPaint); &#125; mPaint.setShadowLayer(2f, 2F, 5F, SHADOW_COLOR); renderBubbleLegPrototype(); setPadding(PADDING, PADDING, PADDING, PADDING); &#125; @Override protected void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); &#125; /** * 尖角path */ private void renderBubbleLegPrototype() &#123; mBubbleLegPrototype.moveTo(0, 0); mBubbleLegPrototype.lineTo(PADDING * 1.5f, -PADDING / 1.5f); mBubbleLegPrototype.lineTo(PADDING * 1.5f, PADDING / 1.5f); mBubbleLegPrototype.close(); &#125; public void setBubbleParams(final BubbleLegOrientation bubbleOrientation, final float bubbleOffset) &#123; mBubbleLegOffset = bubbleOffset; mBubbleOrientation = bubbleOrientation; &#125; /** * 根据显示方向，获取尖角位置矩阵 * @param width * @param height * @return */ private Matrix renderBubbleLegMatrix(final float width, final float height) &#123; final float offset = Math.max(mBubbleLegOffset, MIN_LEG_DISTANCE); float dstX = 0; float dstY = Math.min(offset, height - MIN_LEG_DISTANCE); final Matrix matrix = new Matrix(); switch (mBubbleOrientation) &#123; case TOP: dstX = Math.min(offset, width - MIN_LEG_DISTANCE); dstY = 0; matrix.postRotate(90); break; case RIGHT: dstX = width; dstY = Math.min(offset, height - MIN_LEG_DISTANCE); matrix.postRotate(180); break; case BOTTOM: dstX = Math.min(offset, width - MIN_LEG_DISTANCE); dstY = height; matrix.postRotate(270); break; &#125; matrix.postTranslate(dstX, dstY); return matrix; &#125; @Override protected void onDraw(Canvas canvas) &#123; final float width = canvas.getWidth(); final float height = canvas.getHeight(); mPath.rewind(); mPath.addRoundRect(new RectF(PADDING, PADDING, width - PADDING, height - PADDING), CORNER_RADIUS, CORNER_RADIUS, Direction.CW); mPath.addPath(mBubbleLegPrototype, renderBubbleLegMatrix(width, height)); canvas.drawPath(mPath, mPaint); canvas.scale((width - STROKE_WIDTH) / width, (height - STROKE_WIDTH) / height, width / 2f, height / 2f); canvas.drawPath(mPath, mFillPaint); &#125;&#125; 样式 attrs.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;bubble&quot;&gt; &lt;attr name=&quot;shadowColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;padding&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;strokeWidth&quot; format=&quot;float&quot; /&gt; &lt;attr name=&quot;cornerRadius&quot; format=&quot;float&quot; /&gt; &lt;attr name=&quot;halfBaseOfLeg&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 然后自定义一个PopupWindow，用于显示气泡。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class BubblePopupWindow extends PopupWindow &#123; private BubbleRelativeLayout bubbleView; private Context context; public BubblePopupWindow(Context context) &#123; this.context = context; setWidth(ViewGroup.LayoutParams.WRAP_CONTENT); setHeight(ViewGroup.LayoutParams.WRAP_CONTENT); setFocusable(true); setOutsideTouchable(false); setClippingEnabled(false); ColorDrawable dw = new ColorDrawable(0); setBackgroundDrawable(dw); &#125; public void setBubbleView(View view) &#123; bubbleView = new BubbleRelativeLayout(context); bubbleView.setBackgroundColor(Color.TRANSPARENT); bubbleView.addView(view); setContentView(bubbleView); &#125; public void setParam(int width, int height) &#123; setWidth(width); setHeight(height); &#125; public void show(View parent) &#123; show(parent, Gravity.TOP, getMeasuredWidth() / 2); &#125; public void show(View parent, int gravity) &#123; show(parent, gravity, getMeasuredWidth() / 2); &#125; /** * 显示弹窗 * * @param parent * @param gravity * @param bubbleOffset 气泡尖角位置偏移量。默认位于中间 */ public void show(View parent, int gravity, float bubbleOffset) &#123; BubbleRelativeLayout.BubbleLegOrientation orientation = BubbleRelativeLayout.BubbleLegOrientation.LEFT; if (!this.isShowing()) &#123; switch (gravity) &#123; case Gravity.BOTTOM: orientation = BubbleRelativeLayout.BubbleLegOrientation.TOP; break; case Gravity.TOP: orientation = BubbleRelativeLayout.BubbleLegOrientation.BOTTOM; break; case Gravity.RIGHT: orientation = BubbleRelativeLayout.BubbleLegOrientation.LEFT; break; case Gravity.LEFT: orientation = BubbleRelativeLayout.BubbleLegOrientation.RIGHT; break; default: break; &#125; bubbleView.setBubbleParams(orientation, bubbleOffset); // 设置气泡布局方向及尖角偏移 int[] location = new int[2]; parent.getLocationOnScreen(location); switch (gravity) &#123; case Gravity.BOTTOM: showAsDropDown(parent); break; case Gravity.TOP: showAtLocation(parent, Gravity.NO_GRAVITY, location[0], location[1] - getMeasureHeight()); break; case Gravity.RIGHT: showAtLocation(parent, Gravity.NO_GRAVITY, location[0] + parent.getWidth(), location[1] - (parent.getHeight() / 2)); break; case Gravity.LEFT: showAtLocation(parent, Gravity.NO_GRAVITY, location[0] - getMeasuredWidth(), location[1] - (parent.getHeight() / 2)); break; default: break; &#125; &#125; else &#123; this.dismiss(); &#125; &#125; /** * 测量高度 * * @return */ public int getMeasureHeight() &#123; getContentView().measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED); int popHeight = getContentView().getMeasuredHeight(); return popHeight; &#125; /** * 测量宽度 * * @return */ public int getMeasuredWidth() &#123; getContentView().measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED); int popWidth = getContentView().getMeasuredWidth(); return popWidth; &#125;&#125; view_popup_window.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;com.yuyh.library.BubbleRelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/brlBackground&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/transparent&quot; app:cornerRadius=&quot;10&quot; app:halfBaseOfLeg=&quot;18dp&quot; app:padding=&quot;18dp&quot; app:shadowColor=&quot;#64000000&quot; app:strokeWidth=&quot;5&quot;&gt;&lt;/com.yuyh.library.BubbleRelativeLayout&gt; 调用123456BubblePopupWindow leftTopWindow = new BubblePopupWindow(MainActivity.this);View bubbleView = inflater.inflate(R.layout.layout_popup_view, null);TextView tvContent = (TextView) bubbleView.findViewById(R.id.tvContent);tvContent.setText(&quot;HelloWorld&quot;);leftTopWindow.setBubbleView(bubbleView); // 设置气泡内容leftTopWindow.show(view, Gravity.BOTTOM, 0); // 显示弹窗 依赖123dependencies &#123; compile &#x27;com.yuyh.bubble:library:1.0.0&#x27;&#125; 项目地址https://github.com/smuyyh/BubblePopupWindow","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"Bubble","slug":"Bubble","permalink":"http://smuyyh.top/tags/Bubble/"},{"name":"气泡","slug":"气泡","permalink":"http://smuyyh.top/tags/%E6%B0%94%E6%B3%A1/"}]},{"title":"Java 代码规范初步","slug":"java-coding-standard","date":"16/08/2016","updated":"06/09/2017","comments":true,"path":"2016/08/16/java-coding-standard/","link":"","permalink":"http://smuyyh.top/2016/08/16/java-coding-standard/","excerpt":"谈到编码规范，对于团队项目开发来说，是很有必要的。如果说代码是一种社会行为，那么代码规范可以说是法律，通过法律来约束行为。养成一个良好编码规范的习惯，一是可以统一代码风格；二是便于团队成员协作开发；三是在review代码的时候，更加容易精确地判断需要修改的地方；四是提高代码的可读性和可维护性，提高编码效率及代码质量。 写代码就像写文章一样，逻辑调理清晰，在合适的地方分段，这样对方看起来也比较舒服。当然，以下一些规范是个人整理出来的一些建议，也并非绝对正确，欢迎提议，不喜勿喷~~","text":"谈到编码规范，对于团队项目开发来说，是很有必要的。如果说代码是一种社会行为，那么代码规范可以说是法律，通过法律来约束行为。养成一个良好编码规范的习惯，一是可以统一代码风格；二是便于团队成员协作开发；三是在review代码的时候，更加容易精确地判断需要修改的地方；四是提高代码的可读性和可维护性，提高编码效率及代码质量。 写代码就像写文章一样，逻辑调理清晰，在合适的地方分段，这样对方看起来也比较舒服。当然，以下一些规范是个人整理出来的一些建议，也并非绝对正确，欢迎提议，不喜勿喷~~ 文件编码为了使插件开发应用能有更好的国际化支持，能够最大程度的支持中文输出，则最好使 Java文件使用UTF-8编码。换行符统一为windows格式。不管是Eclipse还是AS，把IDE的环境配好是首当其冲的。 排版规范 缩进：也可以理解为代码对齐，正常情况下代码保存提交时，应该先让代码按统一样式对齐，默认对齐样式在Eclipse中快捷键是Ctrl(Command)+Shift+F，AS是Ctrl(Command)+Alt+L； 分界符：如”{“与”}”，一般遵循“{”前面不换行，后面换行，”}”前后都换行； 语句分割：单行代码太长的话应考虑分割，例如在 “if” 判断条件中，如果逻辑判断的条件太长，分割的原则尽可能是每部分逻辑判断单独一行，有利于代码可读性；属性或者方法之间有较强相关性的，可以放在一起，尽量不要交叉放置。 换行：不要为了怕代码太长而不换行，把一堆代码混在一起。 一行只写一条语句，不要多条语句写在同一行； if、for、do、while、case、switch、default等语句，最好独自占一行； 在同一个方法里面，逻辑或属性相对独立的代码块之间应加个换行； 空格： “，”后面要加个空格； 比较操作符(“&gt;”,”&lt;”,”&#x3D;&#x3D;”)、赋值操作符(“&#x3D;”,”+&#x3D;”)，算术操作符(“+”,”%”)，逻辑操作符(“&amp;&amp;”,”&amp;”,”||”)，位操作符(“&lt;&lt;”,”^”)等双目操作符的前后面加空格； 123456if (value &gt;= MAX_VALUE) &#123; a = b + c; a *= 2; a = b ^ 2; &#125; “！”、”~”、”++”、”–”等单目操作符前后不加空格 if、for、while、switch等与后面的括号之间应加空格，使if等关键字更为突出、明显。 12if (a &gt;= b &amp;&amp; c &gt; d) &#123;&#125; 注释规范 一般情况下，源程序有效注释亮须在20%以上，注释不宜过多，也不能太少，注释须精准易懂，言简意赅。 文件注释：从Java文件第一行开始，为避免被JavaDoc收集，以 &#x2F;* 开始，以 *&#x2F; 结束（JavaDoc收集的注释内容以 &#x2F;** 开始），中间每一行前面加一个“*”。一般是一些版权信息、描述信息及License。 1234/* * Copyright (c) 2016, smuyyh@gmail.com All Rights Reserved. */ 类注释：以 &#x2F;** 开头， 在Class、Interface、Enum之前。一般是用一句话描述类用途，也可有作者及时间等信息，这类信息不宜过多。 属性注释：以 &#x2F;** 开头。有时也可以直接写在一行 1234567/** * 注释信息 */private static final int TEXT_COLOR = Color.RED;/** 注释信息 */private static final int BG_COLOR = Color.RED; 方法注释：@since表明从那个版本开始就有这个方法；@exception或throws可能的异常；@deprecated表示不建议使用该方法。异常注释用@exception或@throws表示，在JavaDoc中二者等价，但推荐用@exception标注Runtime异常，@throws标注非Runtime异常。异常的注释必须说明该异常的含义及什么条件下抛出该异常。 123456789101112/*** 方法描述* @param [参数1] [参数1说明]* @param [参数2] [参数2说明]* @return [返回类型说明]* @exception/throws [违例类型] [违例说明]* @see [类、类#方法、类#成员]* @deprecated [说明及原因]*/public int method(String arg1, String agr2) throws Exception&#123;&#125; 对变量的定义和分支语句（条件分支、循环语句等），稍微复杂一点的最好编写注释，因为这些语句往往是程序实现某一特定功能的关键，对于维护人员来说，良好的注释帮助更好的理解程序，有时甚至优于看设计文档。 对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后需进入下一个case处理，最好在该case语句处理完、下一个case语句前加上明确的注释，这样比较清楚程序编写者的意图，有效防止无辜遗漏break语句 边写代码边注释，修改代码同时修改相应注释，以保证注释与代码的一致性。更新代码须和更新注释保持同步。 注释的内容要清晰、明了，含义明确，防止注释二义性，错误的注释不但无益反而有害。 尽量避免在注释中使用缩写，特别是不常用缩写。 命名规范 包名：包名全部小写，连续的单词只是简单地连接起来，不使用下划线 类名和接口：使用类意义完整的英文描述（如单词太长，可以考虑简写，但尽可能是通俗的简写），每个英文单词的首字母使用大写、其余字母使用小写的大小写混合法 方法名：第一个单词的字母使用小写、剩余单词首字母大写其余字母小写 属性名：规则与方法名类似，但值不能相同。 常量名：使用全大写的英文描述，英文单词之间用下划线分隔开，并且使用final static修饰 准确的确定成员函数的存取控制符号，不是必须使用public属性的，就使用protected，不是必须使用protected的，就使用private 编码准则 明确方法功能，精确（而不是近似）地实现方法设计。一个函数仅完成一件功能，即使简单功能也应该编写方法实现。虽然为仅用一两行就可完成的功能去编方法好像没有必要，但用方法可使功能明确化，增加程序可读性，亦可方便维护、测试。 明确规定对接口方法参数的合法性检查应由方法的调用者负责还是由接口方法本身负责，缺省是由方法调用者负责。 明确类的功能，精确（而非近似）地实现类的设计。一个类仅实现一组相近的功能。可以认为是迪米特法则。 12345678 public MessageBean&#123; private String message; public String toString()&#123; return&quot;message:&quot; + message; &#125;&#125; DB、IO操作等需要使用结束close()的对象必须在try-catch-finally的finally中close() 123456789101112 try&#123; //... ...&#125; catch(IOException e)&#123; //... ...&#125; finally&#123; try&#123; out.close(); &#125; catch (IOException e)&#123; //... ... &#125;&#125; 异常捕获后，如果不对该异常进行处理，则应该记录日志或者ex.printStackTrace() 自己抛出的异常必须要填写详细的描述信息 12throw new IOException(&quot;Writing data error!Data:&quot; + data.toString()); 注意运算符的优先级，并用括号明确表达式的操作顺序，避免使用默认优先级 123if ((a | b) &amp;&amp; (a &amp; c)) word = (high &lt;&lt; 8) | low; 避免使用不易理解的数字，用有意义的标识来代替。涉及物理状态或者含有物理意义的常量，不应直接使用数字，必须用有意义的静态变量来代替。 12345678910private final static int OPEN = 0;private final static int CLOSE = 1;private final static int UNKNOW = -1;if (state = CLOSE)&#123; state = OPEN; //...&#125; 数组声明的时候使用int[] index，有利于提高可读性，而不要使用int index[]。 其他 在switch 中每个case语句都应该包含break或者return，否则需要进行注释，避免遗漏。为switch语句提供一个default选项。 不要使用空的for、if、while语句 在运算中尽可能不要减小数据的精度。例如由double转为float，可能会遗失一部分，降低精度。 避免在if语句中使用等号&#x3D;进行赋值操作 方法重载的时候，一定要注意方法名相同，避免类中使用两个非常相似的方法名。 不要覆盖父类的静态方法和私有方法，也不要覆盖父类的属性。 不要使用两层嵌套以上的内部类 去掉接口中多余的定义（不使用public，abstract，static，final等，这是接口中默认的） 尽可能不要定义不会被用到的局部变量、类私有属性、类私有方法和方法参数 进行字符转换的时候应该尽可能的减少临时变量。 尽可能不要对浮点数进行比较运算，尤其是不要进行&#x3D;&#x3D;，！&#x3D;，容易出错。","categories":[{"name":"Java","slug":"Java","permalink":"http://smuyyh.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://smuyyh.top/tags/Java/"}]},{"title":"利用Gradle发布项目到JCenter","slug":"mac-library-to-jcenter","date":"13/07/2016","updated":"06/09/2017","comments":true,"path":"2016/07/13/mac-library-to-jcenter/","link":"","permalink":"http://smuyyh.top/2016/07/13/mac-library-to-jcenter/","excerpt":"Android Studio将远程仓库默认指定为Jcenter仓库，位于Bintray网站。Bintray网站下面还有其他好几个仓库。本文主要介绍如何将Android项目发布到Jcenter。","text":"Android Studio将远程仓库默认指定为Jcenter仓库，位于Bintray网站。Bintray网站下面还有其他好几个仓库。本文主要介绍如何将Android项目发布到Jcenter。 注册Bintray账号Bintray官网：https://bintray.com 也可使用GitHub账号登录。 获取APIKey上传项目之前我们需要两样东西，一个就是用户名，另一个是APIKey。APIKey可在这里查看。 点击show便可显示。 插件依赖在项目最外层的build.gradle添加“gradle-bintray-plugin”以及“android-maven-plugin”插件的依赖。 12345678910111213141516buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &#x27;com.android.tools.build:gradle:2.1.0&#x27; classpath &#x27;com.github.dcendents:android-maven-gradle-plugin:1.3&#x27; classpath &#x27;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0&#x27; &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; Module配置在需要发布到Jcenter的module（比如library）的build.gradle里配置以下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495apply plugin: &#x27;com.android.library&#x27;apply plugin: &#x27;com.github.dcendents.android-maven&#x27;apply plugin: &#x27;com.jfrog.bintray&#x27;version = &quot;1.0.0&quot; // 版本号android &#123; compileSdkVersion 23 buildToolsVersion &quot;23.0.3&quot; resourcePrefix &quot;bankcardformat&quot; // 随意命名 defaultConfig &#123; minSdkVersion 15 targetSdkVersion 23 versionCode 1 versionName &quot;1.0&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27; &#125; &#125;&#125;dependencies &#123; compile &#x27;com.android.support:appcompat-v7:23.+&#x27; compile fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;])&#125;def siteUrl = &#x27;https://github.com/smuyyh/BankCardFormat&#x27; // Git项目主页def gitUrl = &#x27;https://github.com/smuyyh/BankCardFormat.git&#x27; // Git仓库urlgroup = &quot;com.yuyh.bankcardformat&quot; // 一般为包名install &#123; repositories.mavenInstaller &#123; // 生成POM.xml pom &#123; project &#123; packaging &#x27;aar&#x27; name &#x27;Android BankCardFormat&#x27; // 项目描述 url siteUrl licenses &#123; license &#123; name &#x27;The Apache Software License, Version 2.0&#x27; url &#x27;http://www.apache.org/licenses/LICENSE-2.0.txt&#x27; &#125; &#125; developers &#123; developer &#123; // 开发者个人信息 id &#x27;smuyyh&#x27; name &#x27;smuyyh&#x27; email &#x27;smuyyh@gmail.com&#x27; &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125;task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = &#x27;sources&#x27;&#125;task javadoc(type: Javadoc) &#123; options.encoding = &quot;UTF-8&quot; // 设置编码，否则中文可能会提示出错 source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = &#x27;javadoc&#x27; from javadoc.destinationDir&#125;artifacts &#123; archives javadocJar archives sourcesJar&#125;Properties properties = new Properties()properties.load(project.rootProject.file(&#x27;local.properties&#x27;).newDataInputStream())bintray &#123; user = properties.getProperty(&quot;bintray.user&quot;) key = properties.getProperty(&quot;bintray.apikey&quot;) configurations = [&#x27;archives&#x27;] pkg &#123; repo = &quot;maven&quot; // 发布到Maven库 name = &quot;BankCardFormat&quot; // 发布到JCenter上的项目名字 websiteUrl = siteUrl vcsUrl = gitUrl licenses = [&quot;Apache-2.0&quot;] publish = true &#125;&#125; 配置Username和APIKey在local.properties文件配置Username和APIKey。 12bintray.user = xxxxbintray.apikey = xxxx 正常情况下local.properties应该加入到.gitignore文件里，因为这两项属于隐私信息，无需上传到GitHub。当然了，也可把bintray.user及bintray.apiKey配置在Gradle用户目录下的gradle.properties(不存在则新建)，例如Windows是在C:&#x2F;user&#x2F;username&#x2F;.gradle，OSX和Linux在~&#x2F;.gradle ReBuildRebuild一下项目，会发现在&#x2F;build&#x2F;outputs&#x2F;aar下生成两个文件，这就是library打包出来的二进制文件。 上传项目到Jcenter在Android Studio的Terminal执行以下命令： 1234gradlew javadocJargradlew sourcesJargradlew installgradlew bintrayUpload 执行成功之后，在Bintray个人主页下面可以看到Maven多了一个Package。 点击进去可看到刚刚上传的项目 申请项目加入Jcenter申请地址：https://bintray.com/bintray/jcenter搜索刚刚上传的项目，并选中。或者进入项目主页，点击右下角“Add to Jcenter” 输入项目描述，完成。 等待审核审核速度挺快，一般几个小时左右会通过。Bintray会向您发送一条成功的信息。那么就完成上传了。 项目依赖123dependencies &#123; compile &#x27;com.yuyh.bankcardformat:library:1.0.0&#x27;&#125; 项目更新上传的库进行升级的时候，须更改build.gradle下的version、versionCode、versionName，否则无法进行打包上传。更改完之后重新执行上传项目到Jcenter步骤。上传完成可在项目主页下看到更新的版本号。 问题若在上传的时候，出现GBK编码错误，尝试在task javadoc(type: Javadoc) 下设置UTF-8编码：options.encoding &#x3D; “UTF-8”无法解决请参考以下这个Gradle文件的配置：https://github.com/msdx/gradle-publish/blob/master/bintray.gradle","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://smuyyh.top/tags/Mac/"},{"name":"JCenter","slug":"JCenter","permalink":"http://smuyyh.top/tags/JCenter/"}]},{"title":"Android 全局异常捕获之CrashHandler","slug":"android-crash-handler","date":"28/01/2016","updated":"06/09/2017","comments":true,"path":"2016/01/28/android-crash-handler/","link":"","permalink":"http://smuyyh.top/2016/01/28/android-crash-handler/","excerpt":"一个App上线或者投入到生产环境的时候崩溃了，还不知道是什么原因，这肯定是开发者的痛…所以肯定要加入全局异常捕获，如果项目较大的话，可以考虑加入第三方诸如友盟的崩溃统计插件，以达到异常捕获的效果！ Crash，可以理解为崩溃、垮台，通常来讲就是App运行期间发生了不可预料的错误，虽然在经历发布之前，测试人员进行了大量的测试，但是并不能保证App的正常运行，总会或多或少有一些BUG的。 Java的Thread中有一个UncaughtExceptionHandler接口，该接口的作用主要是为了当Thread 因未捕获的异常而突然终止时，调用处理程序。我们可以通过setDefaultUncaughtExceptionHandler方法，来改变异常默认处理程序。","text":"一个App上线或者投入到生产环境的时候崩溃了，还不知道是什么原因，这肯定是开发者的痛…所以肯定要加入全局异常捕获，如果项目较大的话，可以考虑加入第三方诸如友盟的崩溃统计插件，以达到异常捕获的效果！ Crash，可以理解为崩溃、垮台，通常来讲就是App运行期间发生了不可预料的错误，虽然在经历发布之前，测试人员进行了大量的测试，但是并不能保证App的正常运行，总会或多或少有一些BUG的。 Java的Thread中有一个UncaughtExceptionHandler接口，该接口的作用主要是为了当Thread 因未捕获的异常而突然终止时，调用处理程序。我们可以通过setDefaultUncaughtExceptionHandler方法，来改变异常默认处理程序。 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178import android.content.Context;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.content.pm.PackageManager.NameNotFoundException;import android.os.Build;import java.io.PrintWriter;import java.io.StringWriter;import java.io.Writer;import java.lang.Thread.UncaughtExceptionHandler;import java.lang.reflect.Field;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.HashMap;import java.util.Map;/** * UncaughtException处理类,当程序发生Uncaught异常的时候,有该类来接管程序,并记录发送错误报告. * &lt;p&gt; * Created by yuyuhang on 15/12/7. */public class CrashHandler implements UncaughtExceptionHandler &#123; //系统默认的UncaughtException处理类 private Thread.UncaughtExceptionHandler mDefaultHandler; //CrashHandler实例 private static CrashHandler INSTANCE; //程序的Context对象 private Context mContext; //用来存储设备信息和异常信息 private Map&lt;String, String&gt; infos = new HashMap&lt;String, String&gt;(); private CrashHandler() &#123; &#125; /** * 获取CrashHandler实例 ,单例模式 */ public static CrashHandler getInstance() &#123; if (INSTANCE == null) INSTANCE = new CrashHandler(); return INSTANCE; &#125; /** * 初始化 * * @param context */ public void init(Context context) &#123; mContext = context; //获取系统默认的UncaughtException处理器 mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler(); //设置该CrashHandler为程序的默认处理器 Thread.setDefaultUncaughtExceptionHandler(this); &#125; /** * 当UncaughtException发生时会转入该函数来处理 */ @Override public void uncaughtException(Thread thread, Throwable ex) &#123; if (!handleException(ex) &amp;&amp; mDefaultHandler != null) &#123; //如果用户没有处理则让系统默认的异常处理器来处理 mDefaultHandler.uncaughtException(thread, ex); &#125; else &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; LogUtils.e(e.toString()); &#125; //退出程序 android.os.Process.killProcess(android.os.Process.myPid()); System.exit(1); &#125; &#125; /** * 自定义错误处理,收集错误信息 发送错误报告等操作均在此完成. * * @param ex * @return true:如果处理了该异常信息;否则返回false. */ private boolean handleException(Throwable ex) &#123; if (ex == null) &#123; return false; &#125; //收集设备参数信息 collectDeviceInfo(mContext); //保存日志文件 saveCrashInfo2File(ex); return true; &#125; /** * 收集设备参数信息 * * @param ctx */ public void collectDeviceInfo(Context ctx) &#123; try &#123; PackageManager pm = ctx.getPackageManager(); PackageInfo pi = pm.getPackageInfo(ctx.getPackageName(), PackageManager.GET_ACTIVITIES); if (pi != null) &#123; String versionName = pi.versionName == null ? &quot;null&quot; : pi.versionName; String versionCode = pi.versionCode + &quot;&quot;; infos.put(&quot;versionName&quot;, versionName); infos.put(&quot;versionCode&quot;, versionCode); &#125; &#125; catch (NameNotFoundException e) &#123; LogUtils.e(&quot;CrashHandleran.NameNotFoundException---&gt; error occured when collect package info&quot;, e); &#125; Field[] fields = Build.class.getDeclaredFields(); for (Field field : fields) &#123; try &#123; field.setAccessible(true); infos.put(field.getName(), field.get(null).toString()); &#125; catch (Exception e) &#123; LogUtils.e(&quot;CrashHandler.NameNotFoundException---&gt; an error occured when collect crash info&quot;, e); &#125; &#125; &#125; /** * 保存错误信息到文件中 * * @param ex * @return 返回文件名称, 便于将文件传送到服务器 */ private String saveCrashInfo2File(Throwable ex) &#123; StringBuffer sb = new StringBuffer(); sb.append(&quot;---------------------sta--------------------------&quot;); for (Map.Entry&lt;String, String&gt; entry : infos.entrySet()) &#123; String key = entry.getKey(); String value = entry.getValue(); sb.append(key + &quot;=&quot; + value + &quot;\\n&quot;); &#125; Writer writer = new StringWriter(); PrintWriter printWriter = new PrintWriter(writer); ex.printStackTrace(printWriter); Throwable cause = ex.getCause(); while (cause != null) &#123; cause.printStackTrace(printWriter); cause = cause.getCause(); &#125; printWriter.close(); String result = writer.toString(); sb.append(result); sb.append(&quot;--------------------end---------------------------&quot;); LogUtils.e(sb.toString()); return null; &#125;&#125;然后我们在Application中，对CrashHandler进行初始化。import android.app.Application;import android.content.Context;import com.yuyh.utils.CrashHandler;/** * Created by yuyuhang on 15/12/7. */public class App extends Application &#123; public static Context mContext; @Override public void onCreate() &#123; super.onCreate(); CrashHandler crashHandler = CrashHandler.getInstance(); crashHandler.init(getApplicationContext()); mContext = this; &#125;&#125; 这样的话，当程序代码中并未捕获异常，但发生了异常的时候，就会交由CrashHandler进行处理，异常信息可以保存到日志文件中。日志文件记录请参考：Android 日志打印工具类 可显示打印所在的方法和行号,这样子，就能把异常信息及其异常发生所在的位置，保存在日志文件中。","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"Handler","slug":"Handler","permalink":"http://smuyyh.top/tags/Handler/"},{"name":"Crash","slug":"Crash","permalink":"http://smuyyh.top/tags/Crash/"}]},{"title":"浅谈Android开发中内存泄露与优化","slug":"android-memory-leak-optimization","date":"25/01/2016","updated":"06/09/2017","comments":true,"path":"2016/01/25/android-memory-leak-optimization/","link":"","permalink":"http://smuyyh.top/2016/01/25/android-memory-leak-optimization/","excerpt":"内存泄露是在Android开发中尤其要重视的一个问题，对开发人员开说，这是一个很容易犯也很常见的错误。优化内存泄露的问题，主要从两方面着手，一是开发人员避免写出有内存泄露的代码，二是通过一些诸如MAT的内存分析工具来找出潜在的内存泄露并解决它。其实平时遇到的最多的情况，就是对 Activity 或 Context 保持一个长生命周期的引用。下面主要来分析一下造成内存泄露的各种原因。","text":"内存泄露是在Android开发中尤其要重视的一个问题，对开发人员开说，这是一个很容易犯也很常见的错误。优化内存泄露的问题，主要从两方面着手，一是开发人员避免写出有内存泄露的代码，二是通过一些诸如MAT的内存分析工具来找出潜在的内存泄露并解决它。其实平时遇到的最多的情况，就是对 Activity 或 Context 保持一个长生命周期的引用。下面主要来分析一下造成内存泄露的各种原因。 一、静态变量导致的内存泄露要不怎么说static关键字要慎用呢？来看看下面这段代码，Context对象为静态的，那么Activity就无法正常销毁，会常驻内存。 123456789public class MemoryActivity extends Activity&#123; public static Context mContext; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mContext = this; &#125;&#125; 这是一个很隐晦的内存泄漏的情况，在开发过程中，Context 能使用 ApplicationContext 得尽量使用 ApplicationContext ，因为这个 Context 的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。除此之外，在 Activity 里面创建了静态的View，这就意味着该View持有一个对当前这个 Activity 的引用，那么 Activity 也是无法正常销毁的。 二、引用没释放导致的内存泄露1、注册服务没取消导致的内存泄露假如我们在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen 中定义一个 PhoneStateListener 的对象，同时将它注册到 TelephonyManager 服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。但是如果在释放LockScreen对象的时候没有取消之前注册的PhoneStateListener对象，那么则会导致LockScreen无法被垃圾回收。而锁屏界面又不断的创建和销毁，则最终会由于大量的LockScreen对象没有办法被回收而引起 OutOfMemory 。类似的，BraodcastReceiver，ContentObserver，FileObserver 在 Activity onDeatory或者某类声明周期结束之后一定要unregister掉，否则这个Activity类会被system强引用，不会被内存回收。 2、集合中的对象没有及时清理导致的内存泄露当该集合为静态的时候，那么在集合里面对象越来越多的时候，最好要及时清理不需要用到的对象。 三、单例模式导致的内存泄露单例模式的特点就是它的生命周期和 Application 一样，那么如果某个 Activity 实例被一个单例所持有，也就是说在单例里面引用了它，那么就会造成 Activity 对象无法正常回收释放。 四、资源对象未关闭导致的内存泄露资源性对象(如 Cursor，File 文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null，而不关闭它们，往往会造成内存泄露。例如程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。类似的，Bitmap在不需要之后，应该调用recycle回收，再置为null。 五、属性动画导致的内存泄露例如下面的代码，由于该属性动画为循环动画，如果在 Activity 销毁时，没有取消动画，那么虽然我们看不见动画在执行，实际上动画仍然一直播放下去，这个时候Button会被动画所持有，而 Button 又持有对应的 Activity 对象，那么就会造成 Activity 无法正常释放。 123456789101112public class MemoryActivity extends Activity&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.btn_end); ObjectAnimator animator = ObjectAnimator.ofFloat(button, &quot;&quot;, 0,180); animator.setDuration(2000); animator.setRepeatCount(-1); animator.start(); // 没有调用cancle() &#125;&#125; 六、Adapter未使用缓存的convertView导致的内存泄露ListView提供每一个item所需要的view对象，初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的View对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的Item的View对象会被回收，然后被用来构造新出现的最下面的Item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。正确的写法如下 1234567891011public View getView(int position, ViewconvertView, ViewGroup parent) &#123; View view = null; if (convertView != null) &#123; // 不应该直接new view = convertView; ... &#125; else &#123; view = new Xxx(...); ... &#125; return view; &#125; 七、Handler内部类内存泄露当使用内部类（包括匿名类）来创建 Handler 的时候，Handler 对象会隐式地持有一个外部类对象（通常是一个 Activity ）的引用，而Handler通常会伴随着一个耗时的后台线程（例如从网络拉取图片）一起出现，这个后台线程在任务执行完毕（例如图片下载完毕）之后，通过消息机制通知Handler，然后 Handler 把图片更新到界面。然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用，这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束（例如图片下载完毕）。另外，如果你执行了Handler的postDelayed()方法，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，那么在你设定的delay到达之前，会有一条MessageQueue -&gt; Message -&gt; Handler -&gt; Activity的链，导致你的Activity被持有引用而无法被回收。可以在Activity结束后，关闭线程，如果你的Handler是被delay的Message持有了引用，那么调用removeCallbacks方法来移除消息队列。 内存泄露检测工具MAT的使用请参考：http://jingyan.baidu.com/article/ae97a646b4eea8bbfc461d5a.html，这里需要强调一点，有一些内存泄露通过Mat是查不出来的，比如native的代码，MAT对C&#x2F;C++是无能为力的。","categories":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/tags/Android/"},{"name":"性能优化","slug":"性能优化","permalink":"http://smuyyh.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"内存泄露","slug":"内存泄露","permalink":"http://smuyyh.top/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://smuyyh.top/categories/Java/"},{"name":"Terminal","slug":"Terminal","permalink":"http://smuyyh.top/categories/Terminal/"},{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/categories/Android/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://smuyyh.top/categories/JavaScript/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://smuyyh.top/tags/%E6%8E%92%E5%BA%8F/"},{"name":"io","slug":"io","permalink":"http://smuyyh.top/tags/io/"},{"name":"Terminal","slug":"Terminal","permalink":"http://smuyyh.top/tags/Terminal/"},{"name":"idea plugin","slug":"idea-plugin","permalink":"http://smuyyh.top/tags/idea-plugin/"},{"name":"java","slug":"java","permalink":"http://smuyyh.top/tags/java/"},{"name":"Android","slug":"Android","permalink":"http://smuyyh.top/tags/Android/"},{"name":"动画","slug":"动画","permalink":"http://smuyyh.top/tags/%E5%8A%A8%E7%94%BB/"},{"name":"页面性能","slug":"页面性能","permalink":"http://smuyyh.top/tags/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://smuyyh.top/tags/RecyclerView/"},{"name":"Java","slug":"Java","permalink":"http://smuyyh.top/tags/Java/"},{"name":"Volatile","slug":"Volatile","permalink":"http://smuyyh.top/tags/Volatile/"},{"name":"多线程","slug":"多线程","permalink":"http://smuyyh.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"recyclerview","slug":"recyclerview","permalink":"http://smuyyh.top/tags/recyclerview/"},{"name":"VirtualAPK","slug":"VirtualAPK","permalink":"http://smuyyh.top/tags/VirtualAPK/"},{"name":"Handler","slug":"Handler","permalink":"http://smuyyh.top/tags/Handler/"},{"name":"Message","slug":"Message","permalink":"http://smuyyh.top/tags/Message/"},{"name":"Looper","slug":"Looper","permalink":"http://smuyyh.top/tags/Looper/"},{"name":"HashMap","slug":"HashMap","permalink":"http://smuyyh.top/tags/HashMap/"},{"name":"3D Touch","slug":"3D-Touch","permalink":"http://smuyyh.top/tags/3D-Touch/"},{"name":"JVM","slug":"JVM","permalink":"http://smuyyh.top/tags/JVM/"},{"name":"Camera","slug":"Camera","permalink":"http://smuyyh.top/tags/Camera/"},{"name":"View","slug":"View","permalink":"http://smuyyh.top/tags/View/"},{"name":"异步","slug":"异步","permalink":"http://smuyyh.top/tags/%E5%BC%82%E6%AD%A5/"},{"name":"RxJava","slug":"RxJava","permalink":"http://smuyyh.top/tags/RxJava/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://smuyyh.top/tags/Retrofit/"},{"name":"OkHttp","slug":"OkHttp","permalink":"http://smuyyh.top/tags/OkHttp/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://smuyyh.top/tags/Android-Studio/"},{"name":"AsyncTask","slug":"AsyncTask","permalink":"http://smuyyh.top/tags/AsyncTask/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://smuyyh.top/tags/JavaScript/"},{"name":"Github","slug":"Github","permalink":"http://smuyyh.top/tags/Github/"},{"name":"Widget","slug":"Widget","permalink":"http://smuyyh.top/tags/Widget/"},{"name":"Bubble","slug":"Bubble","permalink":"http://smuyyh.top/tags/Bubble/"},{"name":"气泡","slug":"气泡","permalink":"http://smuyyh.top/tags/%E6%B0%94%E6%B3%A1/"},{"name":"Mac","slug":"Mac","permalink":"http://smuyyh.top/tags/Mac/"},{"name":"JCenter","slug":"JCenter","permalink":"http://smuyyh.top/tags/JCenter/"},{"name":"Crash","slug":"Crash","permalink":"http://smuyyh.top/tags/Crash/"},{"name":"性能优化","slug":"性能优化","permalink":"http://smuyyh.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"内存泄露","slug":"内存泄露","permalink":"http://smuyyh.top/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"}]}