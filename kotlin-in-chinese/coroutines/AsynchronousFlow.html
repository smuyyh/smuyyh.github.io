<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="目录 异步Flow 表达多个值 序列 挂起函数 Flow   Flow是冷的 Flow取消 Flow构建器 中间Flow操作符 转换操作符 大小限制操作符   尾端Flow操作符 Flow是顺序的 Flow上下文 withContex 错误发射 flowOn 操作符   缓冲 合并 处理最后一个值   组合多个Flow zip  Combine   扁平化Flow flatMapConcat fl">
<meta property="og:type" content="website">
<meta property="og:title" content="LeBron_Six 的博客">
<meta property="og:url" content="http://smuyyh.top/kotlin-in-chinese/coroutines/AsynchronousFlow.html">
<meta property="og:site_name" content="LeBron_Six 的博客">
<meta property="og:description" content="目录 异步Flow 表达多个值 序列 挂起函数 Flow   Flow是冷的 Flow取消 Flow构建器 中间Flow操作符 转换操作符 大小限制操作符   尾端Flow操作符 Flow是顺序的 Flow上下文 withContex 错误发射 flowOn 操作符   缓冲 合并 处理最后一个值   组合多个Flow zip  Combine   扁平化Flow flatMapConcat fl">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-10-12T02:57:26.185Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeBron_Six 的博客">
<meta name="twitter:description" content="目录 异步Flow 表达多个值 序列 挂起函数 Flow   Flow是冷的 Flow取消 Flow构建器 中间Flow操作符 转换操作符 大小限制操作符   尾端Flow操作符 Flow是顺序的 Flow上下文 withContex 错误发射 flowOn 操作符   缓冲 合并 处理最后一个值   组合多个Flow zip  Combine   扁平化Flow flatMapConcat fl">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://smuyyh.top/kotlin-in-chinese/coroutines/AsynchronousFlow.html"/>





  <title> | LeBron_Six 的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LeBron_Six 的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

	<h1 class="post-title" itemprop="name headline"></h1>



</header>

      
      
      
      <div class="post-body">
        
        
          <h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h3><ul>
<li><a href="#异步Flow">异步Flow</a><ul>
<li><a href="#表达多个值">表达多个值</a><ul>
<li><a href="#序列">序列</a></li>
<li><a href="#挂起函数">挂起函数</a></li>
<li><a href="#Flow">Flow</a></li>
</ul>
</li>
<li><a href="#Flow是冷的">Flow是冷的</a></li>
<li><a href="#Flow取消">Flow取消</a></li>
<li><a href="#Flow构建器">Flow构建器</a></li>
<li><a href="#中间Flow操作符">中间Flow操作符</a><ul>
<li><a href="#转换操作符">转换操作符</a></li>
<li><a href="#大小限制操作符">大小限制操作符</a></li>
</ul>
</li>
<li><a href="#尾端Flow操作符">尾端Flow操作符</a></li>
<li><a href="#Flow是顺序的">Flow是顺序的</a></li>
<li><a href="#Flow上下文">Flow上下文</a><ul>
<li><a href="#withContex错误发射">withContex 错误发射</a></li>
<li><a href="#flowOn操作符">flowOn 操作符</a></li>
</ul>
</li>
<li><a href="#缓冲">缓冲</a><ul>
<li><a href="#合并">合并</a></li>
<li><a href="#处理最后一个值">处理最后一个值</a></li>
</ul>
</li>
<li><a href="#组合多个Flow">组合多个Flow</a><ul>
<li><a href="#zip">zip</a> </li>
<li><a href="#Combine">Combine</a></li>
</ul>
</li>
<li><a href="#扁平化Flow">扁平化Flow</a><ul>
<li><a href="#flatMapConcat">flatMapConcat</a></li>
<li><a href="#flatMapMerge">flatMapMerge</a></li>
<li><a href="#flatMapLatest">flatMapLatest</a></li>
</ul>
</li>
<li><a href="#Flow异常">Flow异常</a><ul>
<li><a href="#透明捕获">透明捕获</a></li>
<li><a href="#延迟捕获">延迟捕获</a></li>
</ul>
</li>
<li><a href="#Flow完成">Flow完成</a><ul>
<li><a href="#必定执行的finaly块">必定执行的 finaly 块</a></li>
<li><a href="#声明式处理">声明式处理</a></li>
<li><a href="#仅上游处理Flow异常">仅上游处理Flow异常</a></li>
</ul>
</li>
<li><a href="#命令式与声明式">命令式与声明式</a></li>
<li><a href="#启动Flow">启动Flow</a></li>
<li><a href="#Flow与响应式Stream">Flow与响应式Stream</a></li>
</ul>
</li>
</ul>
<h2 id="异步Flow"><a href="#异步Flow" class="headerlink" title="异步Flow"></a>异步Flow</h2><p>挂起函数异步返回一个值，但是我们如何返回多个异步计算的值呢？这就是为什么要引入 Kotlin Flows</p>
<h3 id="代表多个值"><a href="#代表多个值" class="headerlink" title="代表多个值"></a>代表多个值</h3><p>可以使用集合在Kotlin中表示多个值。例如，我们可以有一个 <code>foo()</code> 函数，该函数返回三个数字的列表，然后使用forEach将它们全部打印出来：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.flow01</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    foo().forEach &#123; value -&gt; println(value) &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure>
<h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><p>如果我们使用一些占用CPU的阻塞代码来进行计算（每次计算需要100毫秒），那么我们可以使用Sequence来表示数字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.flow02</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Sequence&lt;<span class="built_in">Int</span>&gt; = sequence &#123; <span class="comment">// sequence builder</span></div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// pretend we are computing it</span></div><div class="line">        yield(i) <span class="comment">// yield next value</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    foo().forEach &#123; value -&gt; println(value) &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该代码输出与上面相同，但在打印每个数字之前要等待100毫秒。</p>
<h4 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h4><p>但是，此计算将阻止正在运行代码的主线程。当这些值由异步代码计算时，我们可以将函数foo标记为suspend，这样它就可以在不阻塞的情况下执行其工作，并将结果作为列表返回：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</div><div class="line">    delay(<span class="number">1000</span>) <span class="comment">// pretend we are doing something asynchronous here</span></div><div class="line">    <span class="keyword">return</span> listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    foo().forEach &#123; value -&gt; println(value) &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此代码在等待一秒钟后打印数字。</p>
<h4 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h4><p>使用 <code>List&lt;Int&gt;</code> 作为结果类型，意味着我们只能一次返回所有值。为了表示异步计算的值Flow，我们可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html" target="_blank" rel="external">Flow<int></int></a> 类型，就像对同步计算的值使用 <code>Sequence&lt;Int&gt;</code> 类型一样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.flow04</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; <span class="comment">// flow builder</span></div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">        delay(<span class="number">100</span>) <span class="comment">// pretend we are doing something useful here</span></div><div class="line">        emit(i) <span class="comment">// emit next value</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    <span class="comment">// Launch a concurrent coroutine to check if the main thread is blocked</span></div><div class="line">    launch &#123;</div><div class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">            println(<span class="string">"I'm not blocked <span class="variable">$k</span>"</span>)</div><div class="line">            delay(<span class="number">100</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Collect the flow</span></div><div class="line">    foo().collect &#123; value -&gt; println(value) &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该代码在打印每个数字之前等待100毫秒，而不会阻塞主线程。这是通过每100毫秒从主线程中运行的单独协程打印“我未被阻止”来验证的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">I'm not blocked 1</div><div class="line">1</div><div class="line">I'm not blocked 2</div><div class="line">2</div><div class="line">I'm not blocked 3</div><div class="line">3</div></pre></td></tr></table></figure>
<p>请注意，代码与先前示例中的Flow有以下区别：</p>
<ul>
<li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html" target="_blank" rel="external">Flow</a> 类型的构建器函数称为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html" target="_blank" rel="external">flow</a>。</li>
<li><code>flow{...}</code> 构建器块中的代码是可挂起的。</li>
<li>函数 <code>foo（）</code> 不再标记为suspend。</li>
<li>使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html" target="_blank" rel="external">emit</a> 函数从flow中发射值。</li>
<li>使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html" target="_blank" rel="external">collect</a> 函数从flow中收集值。</li>
</ul>
<p>我们可以在foo的flow{…}的主体中将Thread.sleep替换为delay，在这种情况下主线程将被阻塞。</p>
<h3 id="Flow是冷的"><a href="#Flow是冷的" class="headerlink" title="Flow是冷的"></a>Flow是冷的</h3><p>Flow 是类似于序列的冷流 - 流构建器中的代码在开始收集前不会运行。 在以下示例中将体现这一特性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.flow05</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; </div><div class="line">    println(<span class="string">"Flow started"</span>)</div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">        delay(<span class="number">100</span>)</div><div class="line">        emit(i)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    println(<span class="string">"Calling foo..."</span>)</div><div class="line">    <span class="keyword">val</span> flow = foo()</div><div class="line">    println(<span class="string">"Calling collect..."</span>)</div><div class="line">    flow.collect &#123; value -&gt; println(value) &#125; </div><div class="line">    println(<span class="string">"Calling collect again..."</span>)</div><div class="line">    flow.collect &#123; value -&gt; println(value) &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出入下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Calling foo...</div><div class="line">Calling collect...</div><div class="line">Flow started</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">Calling collect again...</div><div class="line">Flow started</div><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure>
<p>这是 <code>foo()</code> 函数（返回流）未使用 suspend 修饰符标记的主要原因。 就其本身而言，foo（）快速返回并且不等待任何东西。 该流在每次收集时启动，这就是为什么当我们再次调用collect时看到“流已开始”的原因。</p>
<h3 id="Flow取消"><a href="#Flow取消" class="headerlink" title="Flow取消"></a>Flow取消</h3><p>Flow 必须与协程合作取消。 但流程基础结构不会引入其他取消点。 取消是完全透明。 与往常一样，当将流挂起在可取消的挂起函数（如delay）中时，可以取消流收集，否则不能取消。</p>
<p>以下示例显示了在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout-or-null.html" target="_blank" rel="external">withTimeoutOrNull</a> 块中运行代码时，如何在超时时取消该流：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; </div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">        delay(<span class="number">100</span>)          </div><div class="line">        println(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</div><div class="line">        emit(i)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    withTimeoutOrNull(<span class="number">250</span>) &#123; <span class="comment">// Timeout after 250ms </span></div><div class="line">        foo().collect &#123; value -&gt; println(value) &#125; </div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"Done"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里 <code>foo()</code> 仅发出两个数字,输出如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Emitting 1</div><div class="line">1</div><div class="line">Emitting 2</div><div class="line">2</div><div class="line">Done</div></pre></td></tr></table></figure>
<h3 id="Flow构建器"><a href="#Flow构建器" class="headerlink" title="Flow构建器"></a>Flow构建器</h3><p>上一个例子中的 <code>flow{...}</code> 是最基本的一个, 还有其他构建器可以实现更简单的声明Flow:</p>
<ul>
<li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-of.html" target="_blank" rel="external">flowOF</a> 构建器,定义一个生产固定集合值的流</li>
<li>可以使用.asFlow（）扩展函数将各种集合和序列转换为流。</li>
</ul>
<p>因此，例子中打印从1到3的数字可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Convert an integer range to a flow</span></div><div class="line">(<span class="number">1.</span><span class="number">.3</span>).asFlow().collect &#123; value -&gt; println(value) &#125;</div></pre></td></tr></table></figure>
<h3 id="中间Flow运算符"><a href="#中间Flow运算符" class="headerlink" title="中间Flow运算符"></a>中间Flow运算符</h3><p>可以使用运算符来转换流，就像使用集合和序列一样。中间运算符应用于上游流，并返回下游流。这些运算符是冷的，就像流一样。调用此类运算符本身并非暂停函数。它会迅速返回新的转换流的定义。</p>
<p>基本运算符具有熟悉的名称，例如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html" target="_blank" rel="external">map</a> 和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html" target="_blank" rel="external">filter</a> 。序列的重要区别是这些运算符中的代码块可以调用挂起函数。</p>
<p>例如，即使执行请求是由挂起函数实现的长时间运行的操作，也可以使用map运算符将传入请求的流映射到结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">performRequest</span><span class="params">(request: <span class="type">Int</span>)</span></span>: String &#123;</div><div class="line">    delay(<span class="number">1000</span>) <span class="comment">// imitate long-running asynchronous work</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"response <span class="variable">$request</span>"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow() <span class="comment">// a flow of requests</span></div><div class="line">        .map &#123; request -&gt; performRequest(request) &#125;</div><div class="line">        .collect &#123; response -&gt; println(response) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出如下,每行直接相隔 1 秒打印:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">response 1</div><div class="line">response 2</div><div class="line">response 3</div></pre></td></tr></table></figure>
<h4 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h4><p>在流转换操作符中,最常见的是 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html" target="_blank" rel="external">transform</a>. 它可以用来模仿简单的转换，例如map和filter，也可以实现更复杂的转换。使用 <code>transform</code> 运算符，我们可以发出任意次数的任意值。</p>
<p>例如，使用 transform 我们可以在执行长时间运行的异步请求之前发出一个字符串，并在其后添加一个响应：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1.</span><span class="number">.3</span>).asFlow() <span class="comment">// a flow of requests</span></div><div class="line">    .transform &#123; request -&gt;</div><div class="line">        emit(<span class="string">"Making request <span class="variable">$request</span>"</span>) </div><div class="line">        emit(performRequest(request)) </div><div class="line">    &#125;</div><div class="line">    .collect &#123; response -&gt; println(response) &#125;</div></pre></td></tr></table></figure>
<p>此代码的输出是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Making request <span class="number">1</span></div><div class="line">response <span class="number">1</span></div><div class="line">Making request <span class="number">2</span></div><div class="line">response <span class="number">2</span></div><div class="line">Making request <span class="number">3</span></div><div class="line">response <span class="number">3</span></div></pre></td></tr></table></figure>
<h4 id="大小限制操作符"><a href="#大小限制操作符" class="headerlink" title="大小限制操作符"></a>大小限制操作符</h4><p>限制大小的中间运算符（如<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/take.html" target="_blank" rel="external">take</a>）会在达到相应的限制时取消流程的执行。协程中的取消总是通过抛出异常来执行的，因此在取消的情况下，所有资源管理功能（例如try {…}finally{…}块）都可以正常运行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numbers</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</div><div class="line">    <span class="keyword">try</span> &#123;                          </div><div class="line">        emit(<span class="number">1</span>)</div><div class="line">        emit(<span class="number">2</span>) </div><div class="line">        println(<span class="string">"This line will not execute"</span>)</div><div class="line">        emit(<span class="number">3</span>)    </div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        println(<span class="string">"Finally in numbers"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    numbers() </div><div class="line">        .take(<span class="number">2</span>) <span class="comment">// take only the first two</span></div><div class="line">        .collect &#123; value -&gt; println(value) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果显示 <code>flow{...}</code> 块中发射第二个数字后就停止了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">Finally in numbers</div></pre></td></tr></table></figure>
<h3 id="尾端Flow操作符"><a href="#尾端Flow操作符" class="headerlink" title="尾端Flow操作符"></a>尾端Flow操作符</h3><p>流上的尾端操作符是一个挂起函数，该函数启动流收集工作。 collect 操作符是最基本的操作符，但还有其他尾端操作符，可以使操作变得更简单：</p>
<ul>
<li>转换为各种集合，如<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html" target="_blank" rel="external">toList</a> 和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-set.html" target="_blank" rel="external">toSet</a>。</li>
<li>运算符获取<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html" target="_blank" rel="external">first</a>值并确保流只发射<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/single.html" target="_blank" rel="external">single</a>值。</li>
<li>压缩合并流为某个值 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/reduce.html" target="_blank" rel="external">reduce</a> <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/fold.html" target="_blank" rel="external">fold</a></li>
</ul>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> sum = (<span class="number">1.</span><span class="number">.5</span>).asFlow()</div><div class="line">    .map &#123; it * it &#125; <span class="comment">// squares of numbers from 1 to 5                           </span></div><div class="line">    .reduce &#123; a, b -&gt; a + b &#125; <span class="comment">// sum them (terminal operator)</span></div><div class="line">println(sum)</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">55</div></pre></td></tr></table></figure>
<h3 id="Flow是顺序的"><a href="#Flow是顺序的" class="headerlink" title="Flow是顺序的"></a>Flow是顺序的</h3><p>除非使用对多个流进行操作的特殊运算符，否则将依次执行流的每个单独集合。集合直接在协程中工作，该协程调用终尾端操作符。默认情况下，不启动新的协程。每个发出的值都由所有中间操作符从上游到下游进行处理，然后再传递给尾端操作符。</p>
<p>请参见以下示例，该示例过滤偶数整数并将其映射到字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1.</span><span class="number">.5</span>).asFlow()</div><div class="line">    .filter &#123;</div><div class="line">        println(<span class="string">"Filter <span class="variable">$it</span>"</span>)</div><div class="line">        it % <span class="number">2</span> == <span class="number">0</span>              </div><div class="line">    &#125;              </div><div class="line">    .map &#123; </div><div class="line">        println(<span class="string">"Map <span class="variable">$it</span>"</span>)</div><div class="line">        <span class="string">"string <span class="variable">$it</span>"</span></div><div class="line">    &#125;.collect &#123; </div><div class="line">        println(<span class="string">"Collect <span class="variable">$it</span>"</span>)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Filter <span class="number">1</span></div><div class="line">Filter <span class="number">2</span></div><div class="line">Map <span class="number">2</span></div><div class="line">Collect string <span class="number">2</span></div><div class="line">Filter <span class="number">3</span></div><div class="line">Filter <span class="number">4</span></div><div class="line">Map <span class="number">4</span></div><div class="line">Collect string <span class="number">4</span></div><div class="line">Filter <span class="number">5</span></div></pre></td></tr></table></figure>
<h3 id="Flow上下文"><a href="#Flow上下文" class="headerlink" title="Flow上下文"></a>Flow上下文</h3><p>流的收集总是发生在调用协程的上下文中。例如，如果有一个foo流，那么以下代码将在该代码的作者指定的上下文中运行，而不管foo流的实现细节如何：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">withContext（context）&#123;</div><div class="line">    foo.collect &#123;value-&gt;</div><div class="line">        println（value）<span class="comment">//在指定的上下文中运行</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>流的此属性称为上下文保留。</p>
<p>因此，默认情况下，flow{…} 构建器中的代码在相应流的收集器提供的上下文中运行。例如，考虑foo的实现，该实现打印被调用的线程并发出三个数字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</div><div class="line">    log(<span class="string">"Started foo flow"</span>)</div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">        emit(i)</div><div class="line">    &#125;</div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    foo().collect &#123; value -&gt; log(<span class="string">"Collected <span class="variable">$value</span>"</span>) &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码输出如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[main @coroutine#1] Started foo flow</div><div class="line">[main @coroutine#1] Collected 1</div><div class="line">[main @coroutine#1] Collected 2</div><div class="line">[main @coroutine#1] Collected 3</div></pre></td></tr></table></figure>
<p>因为 <code>foo().collect</code> 是在主线程调用, foo 流主体也将在主线程中调用.这是快速运行或异步代码的理想默认值，这些代码不关心执行上下文并且不会阻塞调用者。</p>
<h3 id="withContex错误发射"><a href="#withContex错误发射" class="headerlink" title="withContex错误发射"></a>withContex错误发射</h3><p>然而，长时间运行的CPU消耗代码可能需要在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html" target="_blank" rel="external">Dispatchers.Default</a> 上下文中执行。UI更新代码可能需要在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html" target="_blank" rel="external">Dispatchers.Main</a> 的上下文中执行。 通常，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html" target="_blank" rel="external">withContext</a> 将用于Kotlin协程更改代码的上下文，但是 flow{…} 构建器中的代码必须遵守上下文保留属性，并且不允许从其他上下文中发出。</p>
<p>尝试运行以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</div><div class="line">    <span class="comment">// The WRONG way to change context for CPU-consuming code in flow builder</span></div><div class="line">    kotlinx.coroutines.withContext(Dispatchers.Default) &#123;</div><div class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">            Thread.sleep(<span class="number">100</span>) <span class="comment">// pretend we are computing it in CPU-consuming way</span></div><div class="line">            emit(i) <span class="comment">// emit next value</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    foo().collect &#123; value -&gt; println(value) &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码将产生如下异常:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Exception in thread "main" java.lang.IllegalStateException: Flow invariant is violated:</div><div class="line">        Flow was collected in [CoroutineId(1), "coroutine#1":BlockingCoroutine&#123;Active&#125;@5511c7f8, BlockingEventLoop@2eac3323],</div><div class="line">        but emission happened in [CoroutineId(1), "coroutine#1":DispatchedCoroutine&#123;Active&#125;@2dae0000, DefaultDispatcher].</div><div class="line">        Please refer to 'flow' documentation or use 'flowOn' instead</div><div class="line">    at ...</div></pre></td></tr></table></figure>
<h3 id="flowOn操作符"><a href="#flowOn操作符" class="headerlink" title="flowOn操作符"></a>flowOn操作符</h3><p>这里的异常可以借助 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html" target="_blank" rel="external">flowOn</a> 函数来改变 flow 发射上下文.正确修改 flow 上下文方法如下, 例子中还会打印出对应线程:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// pretend we are computing it in CPU-consuming way</span></div><div class="line">        log(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</div><div class="line">        emit(i) <span class="comment">// emit next value</span></div><div class="line">    &#125;</div><div class="line">&#125;.flowOn(Dispatchers.Default) <span class="comment">// RIGHT way to change context for CPU-consuming code in flow builder</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    foo().collect &#123; value -&gt;</div><div class="line">        log(<span class="string">"Collected <span class="variable">$value</span>"</span>) </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 <code>flow{...}</code> 在后台线程工作,而收集发生在主线程:</p>
<p>另一个需要注意的是,这里的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html" target="_blank" rel="external">flowOn</a> 操作符改变了流天然的顺序性. 现在，收集发生在一个协程（“协程1”）中，发射发生在另一个协程（“协程2”）中，该协程与收集协程同时在另一个线程中运行。 当FlowOn运算符必须在其上下文中更改CoroutineDispatcher时，它会为上游流创建另一个协程。</p>
<h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>从收集流程所花费的总时间来看，尤其是在涉及长时间运行的异步操作时，以不同的协程运行流程的不同部分可能会有所帮助。 例如，考虑以下情况：foo（）流的发射速度很慢，花费100毫秒来生成一个元素； 收集器也很慢，需要300毫秒来处理一个元素。 让我们看看用流收集三个数字需要多长时间：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">        delay(<span class="number">100</span>) <span class="comment">// pretend we are asynchronously waiting 100 ms</span></div><div class="line">        emit(i) <span class="comment">// emit next value</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </div><div class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</div><div class="line">        foo().collect &#123; value -&gt; </div><div class="line">            delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></div><div class="line">            println(value) </div><div class="line">        &#125; </div><div class="line">    &#125;   </div><div class="line">    println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>产生结果如下，整个集合大约需要1200毫秒（三个数字，每个数字400毫秒）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">Collected in 1220 ms</div></pre></td></tr></table></figure>
<p>我们可以在流上使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html" target="_blank" rel="external">buffer</a> 运算符，可以在收集开始时并行发送数据, 而不是顺序进行:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> time = measureTimeMillis &#123;</div><div class="line">    foo()</div><div class="line">        .buffer() <span class="comment">// buffer emissions, don't wait</span></div><div class="line">        .collect &#123; value -&gt; </div><div class="line">            delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></div><div class="line">            println(value) </div><div class="line">        &#125; </div><div class="line">&#125;   </div><div class="line">println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</div></pre></td></tr></table></figure>
<p>由于我们已经有效地创建了处理管道，因此它只需要等待100毫秒即可处理第一个数字，然后只需花费300毫秒来处理每个数字，因此它会更快地产生相同的数字。这样大约需要1000毫秒才能运行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line">Collected <span class="keyword">in</span> <span class="number">1071</span> ms</div></pre></td></tr></table></figure>
<p>请注意，flowOn运算符在必须更改CoroutineDispatcher时使用相同的缓冲机制，但是在这里，我们显式地请求缓冲而不更改执行上下文。</p>
<p><strong>合并</strong></p>
<p>当流表示操作的部分结果或操作状态更新时，可能不必处理每个值，而只需要处理最近的值即可。在这种情况下，当收集器太慢而无法处理中间值时，可以使用合并运算符跳过中间值。以前面的示例为基础：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.flow18</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</div><div class="line"><span class="keyword">import</span> kotlin.system.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">        delay(<span class="number">100</span>) <span class="comment">// pretend we are asynchronously waiting 100 ms</span></div><div class="line">        emit(i) <span class="comment">// emit next value</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </div><div class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</div><div class="line">        foo()</div><div class="line">            .conflate() <span class="comment">// conflate emissions, don't process each one</span></div><div class="line">            .collect &#123; value -&gt; </div><div class="line">                delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></div><div class="line">                println(value) </div><div class="line">            &#125; </div><div class="line">    &#125;   </div><div class="line">    println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到，虽然第一个数字仍在处理中，第二个和第三个已经发出，所以第二个被合并了，只有最新的（第三个）被交付给收集器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">3</div><div class="line">Collected in 758 ms</div></pre></td></tr></table></figure>
<h3 id="处理最新值"><a href="#处理最新值" class="headerlink" title="处理最新值"></a>处理最新值</h3><p>当发射器和收集器都很慢时，合并是加快处理速度的一种方法。它通过删除发射值来实现。另一种方法是取消缓慢的收集器，并在每次发出新值时重新启动它。有一组 <code>xxxLatest</code> 运算符，它们执行与 <code>xxx</code> 运算符相同的基本逻辑，但是会在其块上取消新值的代码。在上一个示例中，让我们尝试将 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html" target="_blank" rel="external">conflate</a>  改为 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html" target="_blank" rel="external">collectLatest</a>:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> time = measureTimeMillis &#123;</div><div class="line">    foo()</div><div class="line">        .collectLatest &#123; value -&gt; <span class="comment">// cancel &amp; restart on the latest value</span></div><div class="line">            println(<span class="string">"Collecting <span class="variable">$value</span>"</span>) </div><div class="line">            delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></div><div class="line">            println(<span class="string">"Done <span class="variable">$value</span>"</span>) </div><div class="line">        &#125; </div><div class="line">&#125;   </div><div class="line">println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</div></pre></td></tr></table></figure>
<p>由于 collectLatest 的主体需要300毫秒，但是每100毫秒会发出一个新值，因此我们可以看到该块在每个值上运行，但仅针对最后一个值才完成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Collecting 1</div><div class="line">Collecting 2</div><div class="line">Collecting 3</div><div class="line">Done 3</div><div class="line">Collected in 741 ms</div></pre></td></tr></table></figure>
<h3 id="组和多个流"><a href="#组和多个流" class="headerlink" title="组和多个流"></a>组和多个流</h3><p>有很多方法可以组和多个流。</p>
<p><strong>zip (压缩)</strong></p>
<p>就像Kotlin标准库中的 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/zip.html" target="_blank" rel="external">Sequence.zip</a> 扩展功能一样，流具有zip运算符，该运算符结合了两个流的相应值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> nums = (<span class="number">1.</span><span class="number">.3</span>).asFlow() <span class="comment">// numbers 1..3</span></div><div class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>) <span class="comment">// strings </span></div><div class="line">nums.zip(strs) &#123; a, b -&gt; <span class="string">"<span class="variable">$a</span> -&gt; <span class="variable">$b</span>"</span> &#125; <span class="comment">// compose a single string</span></div><div class="line">    .collect &#123; println(it) &#125; <span class="comment">// collect and print</span></div></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 -&gt; one</div><div class="line">2 -&gt; two</div><div class="line">3 -&gt; three</div></pre></td></tr></table></figure>
<p><strong>Combine (组合)</strong></p>
<p>当流表示变量或操作的最新值时（另请参阅有关<a href="https://kotlinlang.org/docs/reference/coroutines/flow.html#conflation" target="_blank" rel="external">合并</a>的部分），可能需要执行依赖于相应流的最新值的计算，并在任何上游有变动时重新进行计算。流发出一个值。相应的运算符族称为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html" target="_blank" rel="external">Combine</a>。</p>
<p>例如，如果上一个示例中的数字每300毫秒更新一次，但是字符串每400毫秒更新一次，使用zip运算符对它们进行压缩仍会产生相同的结果,尽管结果任然是没 400<br>毫秒打印一次：</p>
<p>在此示例中，我们使用onEach中间运算符来延迟每个元素，并使发出采样流的代码更具声明性且更短。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> nums = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// numbers 1..3 every 300 ms</span></div><div class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// strings every 400 ms</span></div><div class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// remember the start time </span></div><div class="line">nums.zip(strs) &#123; a, b -&gt; <span class="string">"<span class="variable">$a</span> -&gt; <span class="variable">$b</span>"</span> &#125; <span class="comment">// compose a single string with "zip"</span></div><div class="line">    .collect &#123; value -&gt; <span class="comment">// collect and print </span></div><div class="line">        println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然而当使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html" target="_blank" rel="external">combine</a> 运算符取代 zip:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> nums = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// numbers 1..3 every 300 ms</span></div><div class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// strings every 400 ms          </span></div><div class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// remember the start time </span></div><div class="line">nums.combine(strs) &#123; a, b -&gt; <span class="string">"<span class="variable">$a</span> -&gt; <span class="variable">$b</span>"</span> &#125; <span class="comment">// compose a single string with "combine"</span></div><div class="line">    .collect &#123; value -&gt; <span class="comment">// collect and print </span></div><div class="line">        println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们会得到完全不同的结果,每次 <code>nums</code> 或者 <code>strs</code> 流都会打印一行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1 -&gt; one at 452 ms from start</div><div class="line">2 -&gt; one at 651 ms from start</div><div class="line">2 -&gt; two at 854 ms from start</div><div class="line">3 -&gt; two at 952 ms from start</div><div class="line">3 -&gt; three at 1256 ms from start</div></pre></td></tr></table></figure>
<h3 id="扁平化流"><a href="#扁平化流" class="headerlink" title="扁平化流"></a>扁平化流</h3><p>流表示异步接收的值序列，因此会有每产生一个值,就会触发对另一个值序列的请求的情形。例如，我们可以具有以下函数，该函数返回两个字符串，每个字符串的间隔为500 ms：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</div><div class="line">    emit(<span class="string">"<span class="variable">$i</span>: First"</span>) </div><div class="line">    delay(<span class="number">500</span>) <span class="comment">// wait 500 ms</span></div><div class="line">    emit(<span class="string">"<span class="variable">$i</span>: Second"</span>)    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，如果我们有三个整数流，并为每个整数调用 <code>requestFlow</code> ，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1.</span><span class="number">.3</span>).asFlow().map &#123; requestFlow(it) &#125;</div></pre></td></tr></table></figure>
<p>然后，我们得到一个流的流（Flow<flow<string>&gt;），该流需要扁平化为单个流以进行进一步处理。集合和序列为此具有 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/flatten.html" target="_blank" rel="external">flatten</a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/flat-map.html" target="_blank" rel="external">flatMap</a> 运算符。但是，由于流的异步性质，它们要求使用不同的扁平化模式，因此，在流上有一系列扁平化运算符。</flow<string></p>
<p><strong>flatMapConcat</strong></p>
<p>串联模式由 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html" target="_blank" rel="external">flatMapConcat</a> 和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-concat.html" target="_blank" rel="external">flattenConcat</a> 运算符实现。它们是相应序列运算符的最直接类似物。他们等待内部流完成，然后开始收集下一个，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.flow23</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</div><div class="line">    emit(<span class="string">"<span class="variable">$i</span>: First"</span>) </div><div class="line">    delay(<span class="number">500</span>) <span class="comment">// wait 500 ms</span></div><div class="line">    emit(<span class="string">"<span class="variable">$i</span>: Second"</span>)    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </div><div class="line">    <span class="keyword">val</span> startTime = currentTimeMillis() <span class="comment">// remember the start time </span></div><div class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// a number every 100 ms </span></div><div class="line">        .flatMapConcat &#123; requestFlow(it) &#125;                                                                           </div><div class="line">        .collect &#123; value -&gt; <span class="comment">// collect and print </span></div><div class="line">            println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从输出中可以清楚地看到f latMapConcat 的顺序性质：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1: First at 121 ms from start</div><div class="line">1: Second at 622 ms from start</div><div class="line">2: First at 727 ms from start</div><div class="line">2: Second at 1227 ms from start</div><div class="line">3: First at 1328 ms from start</div><div class="line">3: Second at 1829 ms from start</div></pre></td></tr></table></figure>
<p><strong>flatMapMerge</strong></p>
<p>另一种扁平模式是同时收集所有传入流并将其值合并为单个流，以便尽快发出值。它由 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html" target="_blank" rel="external">flatMapMerge</a> 和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-merge.html" target="_blank" rel="external">flattenMerge</a> 运算符实现。它们都接受一个可选的 <code>concurrency</code> 参数，该参数限制了同时收集的并发流的数量（默认情况下它等于 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-d-e-f-a-u-l-t_-c-o-n-c-u-r-r-e-n-c-y.html" target="_blank" rel="external">DEFAULT_CONCURRENCY</a> ）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// remember the start time </span></div><div class="line">(<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// a number every 100 ms </span></div><div class="line">    .flatMapMerge &#123; requestFlow(it) &#125;                                                                           </div><div class="line">    .collect &#123; value -&gt; <span class="comment">// collect and print </span></div><div class="line">        println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>flatMapMerge 的并发本质是显而易见的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>: First at <span class="number">136</span> ms from start</div><div class="line"><span class="number">2</span>: First at <span class="number">231</span> ms from start</div><div class="line"><span class="number">3</span>: First at <span class="number">333</span> ms from start</div><div class="line"><span class="number">1</span>: Second at <span class="number">639</span> ms from start</div><div class="line"><span class="number">2</span>: Second at <span class="number">732</span> ms from start</div><div class="line"><span class="number">3</span>: Second at <span class="number">833</span> ms from start</div></pre></td></tr></table></figure>
<p>请注意，flatMapMerge 顺序调用其代码块（在此示例中为{requestFlow（it）}），但同时收集结果流，这等效于先执行顺序映射{requestFlow（it）}，然后在对结果调用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-merge.html" target="_blank" rel="external">flattenMerge</a></p>
<p><strong>flatMapLatest</strong></p>
<p>用与“处理最新值”一节中所示的 collectLatest 运算符类似的方式，存在对应的“最新”扁平模式，在该模式下，一旦发出新流，就会取消先前流的集合。它由 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html" target="_blank" rel="external">flatMapLatest</a> 运算符实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.flow25</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</div><div class="line">    emit(<span class="string">"<span class="variable">$i</span>: First"</span>) </div><div class="line">    delay(<span class="number">500</span>) <span class="comment">// wait 500 ms</span></div><div class="line">    emit(<span class="string">"<span class="variable">$i</span>: Second"</span>)    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </div><div class="line">    <span class="keyword">val</span> startTime = currentTimeMillis() <span class="comment">// remember the start time </span></div><div class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// a number every 100 ms </span></div><div class="line">        .flatMapLatest &#123; requestFlow(it) &#125;                               </div><div class="line">        .collect &#123; value -&gt; <span class="comment">// collect and print </span></div><div class="line">            println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此示例中的输出很好地演示了flatMapLatest的工作方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>: First at <span class="number">142</span> ms from start</div><div class="line"><span class="number">2</span>: First at <span class="number">322</span> ms from start</div><div class="line"><span class="number">3</span>: First at <span class="number">425</span> ms from start</div><div class="line"><span class="number">3</span>: Second at <span class="number">931</span> ms from start</div></pre></td></tr></table></figure>
<p>请注意，flatMapLatest取消了其块（在此示例中为{requestFlow（it）}）上的所有代码的新值。在此特定示例中，这没有什么区别，因为对requestFlow本身的调用是快速，非挂起的并且无法取消。但是，如果要在其中使用诸如delay之类的暂停功能，它的优点才显示出来。</p>
<h3 id="Flow异常"><a href="#Flow异常" class="headerlink" title="Flow异常"></a>Flow异常</h3><p>当运算符中的发射器或代码引发异常时，流收集将提前完成并带有返回异常。有几种处理这些异常的方法。</p>
<p><strong>收集器 try catch</strong></p>
<p>收集器可以使用 Kotlin 的 try/catch 块来处理异常：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">        println(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</div><div class="line">        emit(i) <span class="comment">// emit next value</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        foo().collect &#123; value -&gt;         </div><div class="line">            println(value)</div><div class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">"Collected <span class="variable">$value</span>"</span> &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</div><div class="line">        println(<span class="string">"Caught <span class="variable">$e</span>"</span>)</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码成功地在collect终端操作符中捕获了一个异常，并且正如我们所看到的，此后不再发出任何值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Emitting <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">Emitting <span class="number">2</span></div><div class="line"><span class="number">2</span></div><div class="line">Caught java.lang.IllegalStateException: Collected <span class="number">2</span></div></pre></td></tr></table></figure>
<p><strong>所有的东西都可以捕获</strong></p>
<p>前面的示例实际上捕获了在发射器或任何中间或终端运算符中发生的任何异常。例如，让我们更改代码，以便将发出的值<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html" target="_blank" rel="external">映射</a>到字符串，但是相应的代码会产生异常：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;String&gt; = </div><div class="line">    flow &#123;</div><div class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">            println(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</div><div class="line">            emit(i) <span class="comment">// emit next value</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    .map &#123; value -&gt;</div><div class="line">        check(value &lt;= <span class="number">1</span>) &#123; <span class="string">"Crashed on <span class="variable">$value</span>"</span> &#125;                 </div><div class="line">        <span class="string">"string <span class="variable">$value</span>"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        foo().collect &#123; value -&gt; println(value) &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</div><div class="line">        println(<span class="string">"Caught <span class="variable">$e</span>"</span>)</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仍然会捕获此异常，并且停止收集：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Emitting 1</div><div class="line">string 1</div><div class="line">Emitting 2</div><div class="line">Caught java.lang.IllegalStateException: Crashed on 2</div></pre></td></tr></table></figure>
<h3 id="异常透明化"><a href="#异常透明化" class="headerlink" title="异常透明化"></a>异常透明化</h3><p>但是，发射器的代码如何封装其异常处理行为？</p>
<p>流必须对异常透明，<code>try/catch</code> 块内部的 <code>flow{...}</code> 构建器中发出值,违反了异常透明性。这样可以保证引发异常的收集器始终可以使用上一个示例中的 try/catch 捕获异常。</p>
<p>发射器可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html" target="_blank" rel="external">catch</a> 运算符，该运算符保留此异常透明性并允许对其异常处理进行封装。 catch运算符的主体可以分析异常并根据捕获到的异常以不同的方式对异常作出反应：</p>
<ul>
<li>可以使用 <code>throw</code> 再次抛出异常。</li>
<li>异常可以在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html" target="_blank" rel="external">catch</a> 块内借助 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html" target="_blank" rel="external">emit</a> 转换为异常为发射值。</li>
<li>异常可以被记录,处理,或者被其他代码处理.</li>
</ul>
<p>比如,我们可以在捕获异常时发出一段文本:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.flow28</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;String&gt; = </div><div class="line">    flow &#123;</div><div class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">            println(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</div><div class="line">            emit(i) <span class="comment">// emit next value</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    .map &#123; value -&gt;</div><div class="line">        check(value &lt;= <span class="number">1</span>) &#123; <span class="string">"Crashed on <span class="variable">$value</span>"</span> &#125;                 </div><div class="line">        <span class="string">"string <span class="variable">$value</span>"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    foo()</div><div class="line">        .<span class="keyword">catch</span> &#123; e -&gt; emit(<span class="string">"Caught <span class="variable">$e</span>"</span>) &#125; <span class="comment">// emit on exception</span></div><div class="line">        .collect &#123; value -&gt; println(value) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使我们不使用 try/catch 代码，示例的输出也相同。</p>
<p><strong>透明 catch</strong></p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html" target="_blank" rel="external">catch</a> 中间操作符遵循异常透明性，仅捕获上游异常（这是catch之上而非之下所有运算符的异常）。如果collect {…}中的块（放置在catch下方）抛出异常，则它不会被捕获：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">        println(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</div><div class="line">        emit(i)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    foo()</div><div class="line">        .<span class="keyword">catch</span> &#123; e -&gt; println(<span class="string">"Caught <span class="variable">$e</span>"</span>) &#125; <span class="comment">// does not catch downstream exceptions</span></div><div class="line">        .collect &#123; value -&gt;</div><div class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">"Collected <span class="variable">$value</span>"</span> &#125;                 </div><div class="line">            println(value) </div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管有捕获操作符，但不会打印“Caught…”消息：</p>
<p><strong>声明式捕捉</strong></p>
<p>我们可以将catch操作符的声明性与处理所有异常的目的结合起来,将collect操作符的主体移到<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html" target="_blank" rel="external">onEach</a> 内并将其放在catch操作符之前。这时必须通过不带参数的调用collect（）来触发此流的收集：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo()</div><div class="line">    .onEach &#123; value -&gt;</div><div class="line">        check(value &lt;= <span class="number">1</span>) &#123; <span class="string">"Collected <span class="variable">$value</span>"</span> &#125;                 </div><div class="line">        println(value) </div><div class="line">    &#125;</div><div class="line">    .<span class="keyword">catch</span> &#123; e -&gt; println(<span class="string">"Caught <span class="variable">$e</span>"</span>) &#125;</div><div class="line">    .collect()</div></pre></td></tr></table></figure>
<p>现在我们看到打印了一条“ Caught…”消息，因此我们可以捕获所有异常，而无需显式使用try / catch块：</p>
<h3 id="流完成"><a href="#流完成" class="headerlink" title="流完成"></a>流完成</h3><p>流收集完成时（正常或异常），可能需要执行一个操作。你可能已经注意到，它可以通过两种方式完成：命令式或声明式。</p>
<p><strong>必定执行的finaly块</strong></p>
<p>除了try/catch之外，收集器还可以使用 <code>finally</code> 块在收集完成后执行操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = (<span class="number">1.</span><span class="number">.3</span>).asFlow()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        foo().collect &#123; value -&gt; println(value) &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        println(<span class="string">"Done"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码打印出foo()流产生的三个数字，后跟一个“Done”字符串：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">Done</div></pre></td></tr></table></figure>
<p><strong>声明式处理</strong></p>
<p>对于声明性方法，流具有 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html" target="_blank" rel="external">onCompletion</a> 中间操作符，该操作符在流已全部收集完成时被调用。</p>
<p>可以使用onCompletion运算符重写前面的示例，并产生相同的输出：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo()</div><div class="line">    .onCompletion &#123; println(<span class="string">"Done"</span>) &#125;</div><div class="line">    .collect &#123; value -&gt; println(value) &#125;</div></pre></td></tr></table></figure>
<p>onCompletion 的主要优点是 lambda 的可空的Throwable参数，可用于确定流收集是正常完成还是异常完成。在下面的示例中，foo() 流在发出数字1之后引发异常：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</div><div class="line">    emit(<span class="number">1</span>)</div><div class="line">    <span class="keyword">throw</span> RuntimeException()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    foo()</div><div class="line">        .onCompletion &#123; cause -&gt; <span class="keyword">if</span> (cause != <span class="literal">null</span>) println(<span class="string">"Flow completed exceptionally"</span>) &#125;</div><div class="line">        .<span class="keyword">catch</span> &#123; cause -&gt; println(<span class="string">"Caught exception"</span>) &#125;</div><div class="line">        .collect &#123; value -&gt; println(value) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所料，它将打印：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line">Flow completed exceptionally</div><div class="line">Caught exception</div></pre></td></tr></table></figure>
<p>与catch不同，onCompletion运算符不处理异常。从上面的示例代码可以看出，异常仍然向下游流动。它会交付给其他onCompletion运算符，并且可以由catch运算符处理。</p>
<p><strong>仅上游处理Flow异常</strong></p>
<p>就像catch运算符一样，仅来自上游的异常对 onCompletion 可见，而下游异常对其不可见。 例如，运行以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = (<span class="number">1.</span><span class="number">.3</span>).asFlow()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    foo()</div><div class="line">        .onCompletion &#123; cause -&gt; println(<span class="string">"Flow completed with <span class="variable">$cause</span>"</span>) &#125;</div><div class="line">        .collect &#123; value -&gt;</div><div class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">"Collected <span class="variable">$value</span>"</span> &#125;                 </div><div class="line">            println(value) </div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到完成原因为null，但收集失败，出现以下异常：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line">Flow completed with <span class="literal">null</span></div><div class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.IllegalStateException: Collected <span class="number">2</span></div></pre></td></tr></table></figure>
<h3 id="命令式与声明式"><a href="#命令式与声明式" class="headerlink" title="命令式与声明式"></a>命令式与声明式</h3><p>现在我们知道了如何收集流，并以命令式和声明式方式处理流的完成和异常。那么问题来了，首选哪种方法，为什么？作为一个库，我们不主张采用任何特定的方法，并且认为这两个选项都是有效的，应根您自己的喜好和代码风格进行选择。</p>
<h3 id="启动流"><a href="#启动流" class="headerlink" title="启动流"></a>启动流</h3><p>使用流来表示来自某个源的异步事件很容易。在这种情况下，我们需要一个 <code>addEventListener</code> 函数的类似物，该函数通过对传入事件的反应来注册一段代码，并继续进行进一步的工作。 onEach 运算符可以担任此角色。但是，onEach是中间运算符。我们还需要尾端操作符来收集流。否则，仅调用onEach无效。</p>
<p>如果我们在onEach之后使用collect尾端操作符，那么它后面的代码将直到流收集完成后触发：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Imitate a flow of events</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">events</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    events()</div><div class="line">        .onEach &#123; event -&gt; println(<span class="string">"Event: <span class="variable">$event</span>"</span>) &#125;</div><div class="line">        .collect() <span class="comment">// &lt;--- Collecting the flow waits</span></div><div class="line">    println(<span class="string">"Done"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出如下:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Event: <span class="number">1</span></div><div class="line">Event: <span class="number">2</span></div><div class="line">Event: <span class="number">3</span></div><div class="line">Done</div></pre></td></tr></table></figure>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html" target="_blank" rel="external">launchIn</a> 尾端操作符出现了。通过用 launchIn 代替collect，我们可以在单独的协程中启动流的集合，以便立即继续执行其他代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.flow36</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</div><div class="line"></div><div class="line"><span class="comment">// Imitate a flow of events</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">events</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    events()</div><div class="line">        .onEach &#123; event -&gt; println(<span class="string">"Event: <span class="variable">$event</span>"</span>) &#125;</div><div class="line">        .launchIn(<span class="keyword">this</span>) <span class="comment">// &lt;--- Launching the flow in a separate coroutine</span></div><div class="line">    println(<span class="string">"Done"</span>)</div></pre></td></tr></table></figure>
<p>它打印：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Done</div><div class="line">Event: <span class="number">1</span></div><div class="line">Event: <span class="number">2</span></div><div class="line">Event: <span class="number">3</span></div></pre></td></tr></table></figure>
<p>launchIn的必需参数必须指定一个 CoroutineScope ，在其中启动用于收集流的协程。在上面的示例中，此作用域来自 runBlocking 协程构建器，因此，在运行流程时，此runBlocking范围等待其子协程完成，并防止main函数返回并终止此示例。</p>
<p>在实际应用中，范围将来自生命周期有限的实体。一旦此实体的生命周期终止，则将取消相应的作用域，从而取消相应流的收集。这样，一对 onEach { … }.launchIn(scope) 就像addEventListener 一样工作。但是，由于取消和结构化并发达到了此目的，因此不需要相应的removeEventListener函数。</p>
<p>请注意，launchIn还返回一个Job，该Job仅可在不取消整个作用域或不加入整个作用域的情况下用于取消相应的流程集合协程。</p>
<h3 id="Flow-和反应式-Streams"><a href="#Flow-和反应式-Streams" class="headerlink" title="Flow 和反应式 Streams"></a>Flow 和反应式 Streams</h3><p>对于那些熟悉<a href="https://www.reactive-streams.org/" target="_blank" rel="external">reactive stream</a>或反应式框架（例如RxJava和 project Reactor）的人来说，Flow的设计可能看起来非常熟悉。</p>
<p>确实，它的设计受到了Reactive Streams及其各种实现的启发。但是Flow的主要目标是拥有尽可能简单的设计，是Kotlin和挂起(suspesion)友好且遵循结构化并发。没有 其它框架及其出色大量的工作，就不不会有 Kotlin 中 flowd 的实现。你可以在 <a href="https://medium.com/@elizarov/reactive-streams-and-kotlin-flows-bfd12772cda4" target="_blank" rel="external">Reactive Streams和Kotlin Flows</a> 文章中阅读完整故事。</p>
<p>从概念上讲，Flow虽然有所不同，但它是反应性流，而且也可以将其转换为反应性（符合规范和TCK规范）的发布者，反之亦然。这样的转换器是由kotlinx.coroutines开箱即用地提供的，可以在相应的反应模块中找到（针对 Reactive Streams 的kotlinx-coroutines-active，用于P roject Reactor 的kotlinx-coroutines-reactor和针对RxJava2的kotlinx-coroutines-rx2） 。集成模块包括与 Flow 的相互转换，与Reactor的Context集成以及与各种反应式实体一起使用的易于挂起的方式。</p>

        
      </div>
      
      
      
    </div>
    
    
    
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars0.githubusercontent.com/u/15133565?s=460&v=4"
                alt="LeBron_Six" />
            
              <p class="site-author-name" itemprop="name">LeBron_Six</p>
              <p class="site-description motion-element" itemprop="description">欢迎访问我的博客~</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/smuyyh" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:smuyyh@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#目录"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步Flow"><span class="nav-number"></span> <span class="nav-text">异步Flow</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代表多个值"><span class="nav-number">1.</span> <span class="nav-text">代表多个值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#序列"><span class="nav-number">1.1.</span> <span class="nav-text">序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#挂起函数"><span class="nav-number">1.2.</span> <span class="nav-text">挂起函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Flow"><span class="nav-number">1.3.</span> <span class="nav-text">Flow</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flow是冷的"><span class="nav-number">2.</span> <span class="nav-text">Flow是冷的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flow取消"><span class="nav-number">3.</span> <span class="nav-text">Flow取消</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flow构建器"><span class="nav-number">4.</span> <span class="nav-text">Flow构建器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中间Flow运算符"><span class="nav-number">5.</span> <span class="nav-text">中间Flow运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#转换操作符"><span class="nav-number">5.1.</span> <span class="nav-text">转换操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#大小限制操作符"><span class="nav-number">5.2.</span> <span class="nav-text">大小限制操作符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尾端Flow操作符"><span class="nav-number">6.</span> <span class="nav-text">尾端Flow操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flow是顺序的"><span class="nav-number">7.</span> <span class="nav-text">Flow是顺序的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flow上下文"><span class="nav-number">8.</span> <span class="nav-text">Flow上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#withContex错误发射"><span class="nav-number">9.</span> <span class="nav-text">withContex错误发射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flowOn操作符"><span class="nav-number">10.</span> <span class="nav-text">flowOn操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲"><span class="nav-number">11.</span> <span class="nav-text">缓冲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理最新值"><span class="nav-number">12.</span> <span class="nav-text">处理最新值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组和多个流"><span class="nav-number">13.</span> <span class="nav-text">组和多个流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扁平化流"><span class="nav-number">14.</span> <span class="nav-text">扁平化流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flow异常"><span class="nav-number">15.</span> <span class="nav-text">Flow异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常透明化"><span class="nav-number">16.</span> <span class="nav-text">异常透明化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流完成"><span class="nav-number">17.</span> <span class="nav-text">流完成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令式与声明式"><span class="nav-number">18.</span> <span class="nav-text">命令式与声明式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动流"><span class="nav-number">19.</span> <span class="nav-text">启动流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flow-和反应式-Streams"><span class="nav-number">20.</span> <span class="nav-text">Flow 和反应式 Streams</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"><a href="https://github.com/smuyyh" target="_blank">LeBron_Six</a></span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://www.wenjunjiang.win/css/gitment.css">
        <script src="https://www.wenjunjiang.win/js/gitment.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitment({
            id: window.location.pathname, 
            owner: 'smuyyh',
            repo: 'smuyyh.github.io',
            
            oauth: {
            
            
                client_secret: '774c6e487b59087f22aea6b51bbbd69e2ef0a5c2',
            
                client_id: '0a452de0f03398d1ea74'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  





  

  

  

  
  

  

  

  

</body>
</html>
