<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="目录  通道（实验性的） 通道基础 通道的关闭与迭代 构建通道生产者 管道 使用管道生产素数 扇出 扇入 带缓冲的通道 通道是公平的 计时器通道    通道（实验性的)延迟值提供了在协程之间传输单个值的便捷方法。通道提供了一种传输值流的方法。  通道是kotlinx.coroutines的实验性功能。他们的API预计将在即将发布的kotlinx.coroutines库更新中发展，并且可能会发生重大">
<meta property="og:type" content="website">
<meta property="og:title" content="LeBron_Six 的博客">
<meta property="og:url" content="http://smuyyh.top/kotlin-in-chinese/coroutines/Channels.html">
<meta property="og:site_name" content="LeBron_Six 的博客">
<meta property="og:description" content="目录  通道（实验性的） 通道基础 通道的关闭与迭代 构建通道生产者 管道 使用管道生产素数 扇出 扇入 带缓冲的通道 通道是公平的 计时器通道    通道（实验性的)延迟值提供了在协程之间传输单个值的便捷方法。通道提供了一种传输值流的方法。  通道是kotlinx.coroutines的实验性功能。他们的API预计将在即将发布的kotlinx.coroutines库更新中发展，并且可能会发生重大">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-10-12T02:57:26.187Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeBron_Six 的博客">
<meta name="twitter:description" content="目录  通道（实验性的） 通道基础 通道的关闭与迭代 构建通道生产者 管道 使用管道生产素数 扇出 扇入 带缓冲的通道 通道是公平的 计时器通道    通道（实验性的)延迟值提供了在协程之间传输单个值的便捷方法。通道提供了一种传输值流的方法。  通道是kotlinx.coroutines的实验性功能。他们的API预计将在即将发布的kotlinx.coroutines库更新中发展，并且可能会发生重大">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://smuyyh.top/kotlin-in-chinese/coroutines/Channels.html"/>





  <title> | LeBron_Six 的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LeBron_Six 的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

	<h1 class="post-title" itemprop="name headline"></h1>



</header>

      
      
      
      <div class="post-body">
        
        
          <p><strong>目录</strong></p>
<ul>
<li><a href="#通道实验性的">通道（实验性的）</a><ul>
<li><a href="#通道基础">通道基础</a></li>
<li><a href="#通道的关闭与迭代">通道的关闭与迭代</a></li>
<li><a href="#构建通道生产者">构建通道生产者</a></li>
<li><a href="#管道">管道</a></li>
<li><a href="#使用管道生产素数">使用管道生产素数</a></li>
<li><a href="#扇出">扇出</a></li>
<li><a href="#扇入">扇入</a></li>
<li><a href="#带缓冲的通道">带缓冲的通道</a></li>
<li><a href="#通道是公平的">通道是公平的</a></li>
<li><a href="#计时器通道">计时器通道</a></li>
</ul>
</li>
</ul>
<h3 id="通道（实验性的"><a href="#通道（实验性的" class="headerlink" title="通道（实验性的)"></a>通道（实验性的)</h3><p>延迟值提供了在协程之间传输单个值的便捷方法。通道提供了一种传输值流的方法。</p>
<blockquote>
<p>通道是kotlinx.coroutines的实验性功能。他们的API预计将在即将发布的kotlinx.coroutines库更新中发展，并且可能会发生重大变化。</p>
</blockquote>
<h3 id="通道基础"><a href="#通道基础" class="headerlink" title="通道基础"></a>通道基础</h3><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html" target="_blank" rel="external">Channel</a>在概念上与BlockingQueue非常相似。一个关键的区别是队列的 put 操作是非阻塞的，而channel 的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html" target="_blank" rel="external">send</a> 操作是可挂起的，队列的 take 操作是阻塞的,channel 的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html" target="_blank" rel="external">reveive</a> 是可挂起的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</div><div class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</div><div class="line">    launch &#123;</div><div class="line">        <span class="comment">// this might be heavy CPU-consuming computation or async logic, we'll just send five squares</span></div><div class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) channel.send(x * x)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// here we print five received integers:</span></div><div class="line">    repeat(<span class="number">5</span>) &#123; println(channel.receive()) &#125;</div><div class="line">    println(<span class="string">"Done!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码的输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">4</div><div class="line">9</div><div class="line">16</div><div class="line">25</div><div class="line">Done!</div></pre></td></tr></table></figure>
<h3 id="通道的关闭与迭代"><a href="#通道的关闭与迭代" class="headerlink" title="通道的关闭与迭代"></a>通道的关闭与迭代</h3><p>与队列不同,通道可以关闭以表示没有即将到来的元素. 在接收者一边,可以使用普通的 <code>for</code> 循环从通道中读取元素.</p>
<p>概念上讲, <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/close.html" target="_blank" rel="external">close</a> 类似于给通道发送一个特殊的关闭令牌. 一旦收到结束令牌循环既停止,因此可以保证前面发送的元素都被接收到了:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</div><div class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</div><div class="line">    launch &#123;</div><div class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) channel.send(x * x)</div><div class="line">        channel.close() <span class="comment">// we're done sending</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// here we print received values using `for` loop (until the channel is closed)</span></div><div class="line">    <span class="keyword">for</span> (y <span class="keyword">in</span> channel) println(y)</div><div class="line">    println(<span class="string">"Done!"</span>)</div></pre></td></tr></table></figure>
<h3 id="构建通道生产者"><a href="#构建通道生产者" class="headerlink" title="构建通道生产者"></a>构建通道生产者</h3><p>协程生产元素队列的模式很常见. 这是生产者-消费者模式的一部分,在并发代码中十分常见. 你把生产者抽象为一个接收通道作为参数的一个函数,但这与编程常识有些不同,因为通常结果必须从函数中返回.</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html" target="_blank" rel="external">produce</a> 是一个很方便的协程生产者,在生产者端可以很好的工作， 并且扩展函数 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html" target="_blank" rel="external">consumeEach</a> 在消费者端可以很方便的替代 for 循环：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">produceSquares</span><span class="params">()</span></span>: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce &#123;</div><div class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) send(x * x)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</div><div class="line">    <span class="keyword">val</span> squares = produceSquares()</div><div class="line">    squares.consumeEach &#123; println(it) &#125;</div><div class="line">    println(<span class="string">"Done!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是一种协程生成的模式，可以生产无穷多个元素：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">produceNumbers</span><span class="params">()</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) send(x++) <span class="comment">// infinite stream of integers starting from 1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其它的协程可以消费该流,做些操作,或者生产其它结果.下面的例子中对流中的数字进行了求平方操作:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">square</span><span class="params">(numbers: <span class="type">ReceiveChannel</span>&lt;<span class="type">Int</span>&gt;)</span></span>: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce &#123;</div><div class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> numbers) send(x * x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主代码开始并连接该通道:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</div><div class="line">    <span class="keyword">val</span> numbers = produceNumbers() <span class="comment">// produces integers from 1 and on</span></div><div class="line">    <span class="keyword">val</span> squares = square(numbers) <span class="comment">// squares integers</span></div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) println(squares.receive()) <span class="comment">// print first five</span></div><div class="line">    println(<span class="string">"Done!"</span>) <span class="comment">// we are done</span></div><div class="line">    coroutineContext.cancelChildren() <span class="comment">// cancel children coroutines</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">produceNumbers</span><span class="params">()</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) send(x++) <span class="comment">// infinite stream of integers starting from 1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">square</span><span class="params">(numbers: <span class="type">ReceiveChannel</span>&lt;<span class="type">Int</span>&gt;)</span></span>: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce &#123;</div><div class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> numbers) send(x * x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>所有创建协程的函数都被定义为CoroutineScope的扩展函数，因此我们可以依赖结构化并发来确保我们的应用程序中没有延迟的全局协同程序。</p>
</blockquote>
<h3 id="使用管道生产素数"><a href="#使用管道生产素数" class="headerlink" title="使用管道生产素数"></a>使用管道生产素数</h3><p>让我们来展示一个极端的例子,在协程中使用一个管道来生成素数。首先创建一个无限数字序列。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">numbersFrom</span><span class="params">(start: <span class="type">Int</span>)</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</div><div class="line">    <span class="keyword">var</span> x = start</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) send(x++) <span class="comment">// infinite stream of integers from start</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来的管道中对接收到数字队列进行过滤,移除所有可以被给定素数整除的数字:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">filter</span><span class="params">(numbers: <span class="type">ReceiveChannel</span>&lt;<span class="type">Int</span>&gt;, prime: <span class="type">Int</span>)</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</div><div class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> numbers) <span class="keyword">if</span> (x % prime != <span class="number">0</span>) send(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来构建一个从数字2开始的管道,从当前通道中获得素数,并不断的用当前发现的素数用于新的通道进行过滤:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numbersFrom(2) -&gt; filter(2) -&gt; filter(3) -&gt; filter(5) -&gt; filter(7) ...</div></pre></td></tr></table></figure>
<p>下面的例子打印了前十个素数， 在主线程的上下文中运行整个管道。直到所有的协程在该主协程 runBlocking 的作用域中被启动完成。 我们不必使用一个显式的列表来保存所有被我们已经启动的协程。 我们使用 cancelChildren 扩展函数在我们打印了前十个素数以后来取消所有的子协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</div><div class="line">    <span class="keyword">var</span> cur = numbersFrom(<span class="number">2</span>)</div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</div><div class="line">        <span class="keyword">val</span> prime = cur.receive()</div><div class="line">        println(prime)</div><div class="line">        cur = filter(cur, prime)</div><div class="line">    &#125;</div><div class="line">    coroutineContext.cancelChildren() <span class="comment">// cancel all children to let main finish    </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">numbersFrom</span><span class="params">(start: <span class="type">Int</span>)</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</div><div class="line">    <span class="keyword">var</span> x = start</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) send(x++) <span class="comment">// infinite stream of integers from start</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">filter</span><span class="params">(numbers: <span class="type">ReceiveChannel</span>&lt;<span class="type">Int</span>&gt;, prime: <span class="type">Int</span>)</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</div><div class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> numbers) <span class="keyword">if</span> (x % prime != <span class="number">0</span>) send(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">2</div><div class="line">3</div><div class="line">5</div><div class="line">7</div><div class="line">11</div><div class="line">13</div><div class="line">17</div><div class="line">19</div><div class="line">23</div><div class="line">29</div></pre></td></tr></table></figure>
<p>注意，你可以使用标准库中的 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/build-iterator.html" target="_blank" rel="external">buildIterator</a> 协程构建器来构建一个相似的管道。 使用 buildIterator 替换 produce、用 yield 替换 send、用next 替换 receive、 以及Iterator 替换 ReceiveChannel 来摆脱协程作用域，你将不再需要 runBlocking。 然而，如上所示，如果你在 Dispatchers.Default 上下文中运行它，使用通道的管道的好处在于它可以充分利用多核心 CPU。</p>
<p>无论如何，这是找到素数的极不切实际的方法。 实际上，管道确实涉及一些其他的挂起调用（比如对远程服务的异步调用），并且这些管道不能使用buildSequence / buildIterator构建，因为它们不允许任意挂起，这与完全异步的 <code>produce</code> 操作不同。</p>
<h3 id="扇出"><a href="#扇出" class="headerlink" title="扇出"></a>扇出</h3><p>多个协程可能从同一个通道获取数据,并在它们之间进行分布式工作. 我们先建立一个生产者协程,该协程定期产生一个整数(每秒钟10个):</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">produceNumbers</span><span class="params">()</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">1</span> <span class="comment">// start from 1</span></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        send(x++) <span class="comment">// produce next</span></div><div class="line">        delay(<span class="number">100</span>) <span class="comment">// wait 0.1s</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们可以有不同的消费者协程. 在这个例子中,只是打印自己 id 以及收到的数字:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launchProcessor</span><span class="params">(id: <span class="type">Int</span>, channel: <span class="type">ReceiveChannel</span>&lt;<span class="type">Int</span>&gt;)</span></span> = launch &#123;</div><div class="line">    <span class="keyword">for</span> (msg <span class="keyword">in</span> channel) &#123;</div><div class="line">        println(<span class="string">"Processor #<span class="variable">$id</span> received <span class="variable">$msg</span>"</span>)</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来启动五个消费者并让它们不间断工作.看看会发生什么:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> producer = produceNumbers()</div><div class="line">repeat(<span class="number">5</span>)&#123;</div><div class="line">    launchProcessor(it, producer)</div><div class="line">&#125;</div><div class="line"></div><div class="line">delay(<span class="number">950</span>)</div><div class="line">producer.cancel()</div></pre></td></tr></table></figure>
<p>输出结果可能会和下面的相似,处理器收到的 id 或许会不同:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Processor #2 received 1</div><div class="line">Processor #4 received 2</div><div class="line">Processor #0 received 3</div><div class="line">Processor #1 received 4</div><div class="line">Processor #3 received 5</div><div class="line">Processor #2 received 6</div><div class="line">Processor #4 received 7</div><div class="line">Processor #0 received 8</div><div class="line">Processor #1 received 9</div><div class="line">Processor #3 received 10</div></pre></td></tr></table></figure>
<p>主义取消生产者协程并关闭他的通道,会导致对该通道正在进行的迭代终止.</p>
<p>还有，注意我们在 <code>launchProcessor</code> 中是怎样使用 for 循环显式迭代通道并执行扇出的。 与 consumeEach 不同，for 循环是可以在多个协程中十分安全地使用.如果其中一个处理者协程执行失败，其它的处理器协程仍然会继续处理通道，而用 consumeEach 编写的处理器始终在正常或非正常完成时消耗（取消）底层通道。</p>
<h3 id="扇入"><a href="#扇入" class="headerlink" title="扇入"></a>扇入</h3><p>多个协程可以发送消息到同一个通道。 比如说，创建一个字符串的通道，和一个往该通道中以指定的延迟发送指定字符串的挂起函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">sendString</span><span class="params">(channel: <span class="type">SendChannel</span>&lt;<span class="type">String</span>&gt;, s: <span class="type">String</span>, time: <span class="type">Long</span>)</span></span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        delay(time)</div><div class="line">        channel.send(s)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来让我们看看如果我们同时开启多个协程发送字符串会发生什么(本例中,我们在主线程的上下文中作为主协程的子协程来启动它们):</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> channel = Channel&lt;String&gt;()</div><div class="line">launch &#123; sendString(channel, <span class="string">"foo"</span>, <span class="number">200</span>L) &#125;</div><div class="line">launch &#123; sendString(channel, <span class="string">"BAR!"</span>, <span class="number">500</span>L) &#125;</div><div class="line">repeat(<span class="number">6</span>) &#123; <span class="comment">// receive first six</span></div><div class="line">    println(channel.receive())</div><div class="line">&#125;</div><div class="line">coroutineContext.cancelChildren() <span class="comment">// cancel all children to let main finish</span></div></pre></td></tr></table></figure>
<p>代码输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">foo</div><div class="line">foo</div><div class="line">BAR!</div><div class="line">foo</div><div class="line">foo</div><div class="line">BAR!</div></pre></td></tr></table></figure>
<h3 id="带缓冲的通道"><a href="#带缓冲的通道" class="headerlink" title="带缓冲的通道"></a>带缓冲的通道</h3><p>上面介绍的通道都是没有缓冲的.无缓冲的通道需要发送者和接受者相互匹配(既互相约定).如果先调起发送者,则会被挂起,直到接收者被调用, 如果接收者先被调用,则在发送者调起前它一直被挂起.</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel.html" target="_blank" rel="external">Channel()</a> 工厂函数和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html" target="_blank" rel="external">produce</a> 构建器都可以接收一个可选参数 <code>capacity</code> 来指定缓冲大小. 缓冲使得发送者在挂起前可以发送多个元素, 这个 <code>BlockingQueue</code> 指定容量是一致的, 它们会在缓冲慢之前一直阻塞.</p>
<p>看看下面代码的执行:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(<span class="number">4</span>) <span class="comment">// create buffered channel</span></div><div class="line">    <span class="keyword">val</span> sender = launch &#123; <span class="comment">// launch sender coroutine</span></div><div class="line">        repeat(<span class="number">10</span>) &#123;</div><div class="line">            println(<span class="string">"Sending <span class="variable">$it</span>"</span>) <span class="comment">// print before sending each element</span></div><div class="line">            channel.send(it) <span class="comment">// will suspend when buffer is full</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// don't receive anything... just wait....</span></div><div class="line">    delay(<span class="number">1000</span>)</div><div class="line">    sender.cancel() <span class="comment">// cancel sender coroutine    </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用缓冲通道并给 capacity 参数传入 四 它将打印 “sending” 五次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Sending 0</div><div class="line">Sending 1</div><div class="line">Sending 2</div><div class="line">Sending 3</div><div class="line">Sending 4</div></pre></td></tr></table></figure>
<p>前四个元素被加入到了缓冲区并且发送者在试图发送第五个元素的时候被挂起。</p>
<h3 id="通道是公平的"><a href="#通道是公平的" class="headerlink" title="通道是公平的"></a>通道是公平的</h3><p>发送和接收操作是公平的 并且严格按照调用它们的协程顺序进行。它们遵守先进先出原则，可以看到第一个协程调用 receive 并得到了元素。在下面的例子中两个协程 “乒” 和 “乓” 都从共享的“桌子”通道接收到这个“球”元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.*</div><div class="line"></div><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ball</span></span>(<span class="keyword">var</span> hits: <span class="built_in">Int</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</div><div class="line">    <span class="keyword">val</span> table = Channel&lt;Ball&gt;() <span class="comment">// a shared table</span></div><div class="line">    launch &#123; player(<span class="string">"ping"</span>, table) &#125;</div><div class="line">    launch &#123; player(<span class="string">"pong"</span>, table) &#125;</div><div class="line">    table.send(Ball(<span class="number">0</span>)) <span class="comment">// serve the ball</span></div><div class="line">    delay(<span class="number">1000</span>) <span class="comment">// delay 1 second</span></div><div class="line">    coroutineContext.cancelChildren() <span class="comment">// game over, cancel them</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">player</span><span class="params">(name: <span class="type">String</span>, table: <span class="type">Channel</span>&lt;<span class="type">Ball</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> (ball <span class="keyword">in</span> table) &#123; <span class="comment">// receive the ball in a loop</span></div><div class="line">        ball.hits++</div><div class="line">        println(<span class="string">"<span class="variable">$name</span> <span class="variable">$ball</span>"</span>)</div><div class="line">        delay(<span class="number">300</span>) <span class="comment">// wait a bit</span></div><div class="line">        table.send(ball) <span class="comment">// send the ball back</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>“ping”协程首先启动，因此它是第一个接收球的人。 即使“ping”coroutine在将球送回桌面后立即再次接球，球也会被“pong”协程接收，因为它已经在等待了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ping Ball(hits=1)</div><div class="line">pong Ball(hits=2)</div><div class="line">ping Ball(hits=3)</div><div class="line">pong Ball(hits=4)</div></pre></td></tr></table></figure>
<p>请注意，由于正在使用的执行程序的性质，有时通道可能会产生看起来不公平的执行。 有关详细信息，请参阅此<a href="https://github.com/Kotlin/kotlinx.coroutines/issues/111" target="_blank" rel="external">issue</a></p>
<h3 id="计时器通道"><a href="#计时器通道" class="headerlink" title="计时器通道"></a>计时器通道</h3><p>计时器通道是一种特别的会合通道，每次经过特定的延迟都会从该通道进行消费并产生 Unit。 虽然它看起来似乎没用，它被用来构建分段来创建复杂的基于时间的 produce 管道和进行窗口化操作以及其它时间相关的处理。 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html" target="_blank" rel="external">select</a> 中可以用计时器通道来进行“on tick”操作.</p>
<p>用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html" target="_blank" rel="external">ticker</a> 工厂方法可以创建一个这样的通道. 可以用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html" target="_blank" rel="external">ReceiveChannel.cancel</a> 方法表示接下来没有元素输出.</p>
<p>下面我们实践一下:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    <span class="keyword">val</span> tickerChannel = ticker(delayMillis = <span class="number">100</span>, initialDelayMillis = <span class="number">0</span>) <span class="comment">// create ticker channel</span></div><div class="line">    <span class="keyword">var</span> nextElement = withTimeoutOrNull(<span class="number">1</span>) &#123; tickerChannel.receive() &#125;</div><div class="line">    println(<span class="string">"Initial element is available immediately: <span class="variable">$nextElement</span>"</span>) <span class="comment">// initial delay hasn't passed yet</span></div><div class="line"></div><div class="line">    nextElement = withTimeoutOrNull(<span class="number">50</span>) &#123; tickerChannel.receive() &#125; <span class="comment">// all subsequent elements has 100ms delay</span></div><div class="line">    println(<span class="string">"Next element is not ready in 50 ms: <span class="variable">$nextElement</span>"</span>)</div><div class="line"></div><div class="line">    nextElement = withTimeoutOrNull(<span class="number">60</span>) &#123; tickerChannel.receive() &#125;</div><div class="line">    println(<span class="string">"Next element is ready in 100 ms: <span class="variable">$nextElement</span>"</span>)</div><div class="line"></div><div class="line">    <span class="comment">// Emulate large consumption delays</span></div><div class="line">    println(<span class="string">"Consumer pauses for 150ms"</span>)</div><div class="line">    delay(<span class="number">150</span>)</div><div class="line">    <span class="comment">// Next element is available immediately</span></div><div class="line">    nextElement = withTimeoutOrNull(<span class="number">1</span>) &#123; tickerChannel.receive() &#125;</div><div class="line">    println(<span class="string">"Next element is available immediately after large consumer delay: <span class="variable">$nextElement</span>"</span>)</div><div class="line">    <span class="comment">// Note that the pause between `receive` calls is taken into account and next element arrives faster</span></div><div class="line">    nextElement = withTimeoutOrNull(<span class="number">60</span>) &#123; tickerChannel.receive() &#125; </div><div class="line">    println(<span class="string">"Next element is ready in 50ms after consumer pause in 150ms: <span class="variable">$nextElement</span>"</span>)</div><div class="line"></div><div class="line">    tickerChannel.cancel() <span class="comment">// indicate that no more elements are needed</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Initial element is available immediately: kotlin.Unit</div><div class="line">Next element is not ready in 50 ms: null</div><div class="line">Next element is ready in 100 ms: kotlin.Unit</div><div class="line">Consumer pauses for 150ms</div><div class="line">Next element is available immediately after large consumer delay: kotlin.Unit</div><div class="line">Next element is ready in 50ms after consumer pause in 150ms: kotlin.Unit</div></pre></td></tr></table></figure>
<p>请注意，ticker 知道可能的消费者暂停，并且默认情况下会调整下一个生成的元素如果发生暂停则延迟，试图保持固定的生成元素率。</p>
<p>给可选的 mode 参数传入 TickerMode.FIXED_DELAY 可以保持固定元素之间的延迟。</p>

        
      </div>
      
      
      
    </div>
    
    
    
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars0.githubusercontent.com/u/15133565?s=460&v=4"
                alt="LeBron_Six" />
            
              <p class="site-author-name" itemprop="name">LeBron_Six</p>
              <p class="site-description motion-element" itemprop="description">欢迎访问我的博客~</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/smuyyh" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:smuyyh@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#通道（实验性的"><span class="nav-number">1.</span> <span class="nav-text">通道（实验性的)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道基础"><span class="nav-number">2.</span> <span class="nav-text">通道基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道的关闭与迭代"><span class="nav-number">3.</span> <span class="nav-text">通道的关闭与迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建通道生产者"><span class="nav-number">4.</span> <span class="nav-text">构建通道生产者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道"><span class="nav-number">5.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用管道生产素数"><span class="nav-number">6.</span> <span class="nav-text">使用管道生产素数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扇出"><span class="nav-number">7.</span> <span class="nav-text">扇出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扇入"><span class="nav-number">8.</span> <span class="nav-text">扇入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带缓冲的通道"><span class="nav-number">9.</span> <span class="nav-text">带缓冲的通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道是公平的"><span class="nav-number">10.</span> <span class="nav-text">通道是公平的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计时器通道"><span class="nav-number">11.</span> <span class="nav-text">计时器通道</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"><a href="https://github.com/smuyyh" target="_blank">LeBron_Six</a></span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://www.wenjunjiang.win/css/gitment.css">
        <script src="https://www.wenjunjiang.win/js/gitment.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitment({
            id: window.location.pathname, 
            owner: 'smuyyh',
            repo: 'smuyyh.github.io',
            
            oauth: {
            
            
                client_secret: '774c6e487b59087f22aea6b51bbbd69e2ef0a5c2',
            
                client_id: '0a452de0f03398d1ea74'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  





  

  

  

  
  

  

  

  

</body>
</html>
