<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="目录  协程上下文和调度器 调度器和线程 不确定与确定调度器 调试协程和线程 在线程之间跳转 在上下文中的Job 子协程 父协程的责任 命名协程以进行调试 结合上下文元素 协程作用域 Thradd-local数据    协程上下文和调度器协程始终在由Kotlin标准库中定义的CoroutineContext类型的值表示的上下文中执行。 协程上下文是一组各种元素。主要元素是协程的 Job（我们之前已">
<meta property="og:type" content="website">
<meta property="og:title" content="LeBron_Six 的博客">
<meta property="og:url" content="http://smuyyh.top/kotlin-in-chinese/coroutines/CoroutineContextAndDispatchers.html">
<meta property="og:site_name" content="LeBron_Six 的博客">
<meta property="og:description" content="目录  协程上下文和调度器 调度器和线程 不确定与确定调度器 调试协程和线程 在线程之间跳转 在上下文中的Job 子协程 父协程的责任 命名协程以进行调试 结合上下文元素 协程作用域 Thradd-local数据    协程上下文和调度器协程始终在由Kotlin标准库中定义的CoroutineContext类型的值表示的上下文中执行。 协程上下文是一组各种元素。主要元素是协程的 Job（我们之前已">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-10-12T02:57:26.188Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeBron_Six 的博客">
<meta name="twitter:description" content="目录  协程上下文和调度器 调度器和线程 不确定与确定调度器 调试协程和线程 在线程之间跳转 在上下文中的Job 子协程 父协程的责任 命名协程以进行调试 结合上下文元素 协程作用域 Thradd-local数据    协程上下文和调度器协程始终在由Kotlin标准库中定义的CoroutineContext类型的值表示的上下文中执行。 协程上下文是一组各种元素。主要元素是协程的 Job（我们之前已">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://smuyyh.top/kotlin-in-chinese/coroutines/CoroutineContextAndDispatchers.html"/>





  <title> | LeBron_Six 的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LeBron_Six 的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

	<h1 class="post-title" itemprop="name headline"></h1>



</header>

      
      
      
      <div class="post-body">
        
        
          <p><strong>目录</strong></p>
<ul>
<li><a href="#协程上下文和调度器">协程上下文和调度器</a><ul>
<li><a href="#调度器和线程">调度器和线程</a></li>
<li><a href="#不确定与确定调度器">不确定与确定调度器</a></li>
<li><a href="#调试协程和线程">调试协程和线程</a></li>
<li><a href="#在线程之间跳转">在线程之间跳转</a></li>
<li><a href="#在上下文中的Job">在上下文中的Job</a></li>
<li><a href="#子协程">子协程</a></li>
<li><a href="#父协程的责任">父协程的责任</a></li>
<li><a href="#命名协程以进行调试">命名协程以进行调试</a></li>
<li><a href="#结合上下文元素">结合上下文元素</a></li>
<li><a href="#协程作用域">协程作用域</a></li>
<li><a href="#Thradd-local数据">Thradd-local数据</a></li>
</ul>
</li>
</ul>
<h2 id="协程上下文和调度器"><a href="#协程上下文和调度器" class="headerlink" title="协程上下文和调度器"></a>协程上下文和调度器</h2><p>协程始终在由Kotlin标准库中定义的CoroutineContext类型的值表示的上下文中执行。</p>
<p>协程上下文是一组各种元素。主要元素是协程的 Job（我们之前已经看到过）及其调度器，本节将对此进行介绍。</p>
<h3 id="调度器和线程"><a href="#调度器和线程" class="headerlink" title="调度器和线程"></a>调度器和线程</h3><p>协程上下文包括一个协程调度器（请参阅 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html" target="_blank" rel="external">CoroutineDispatcher</a> ），该调度器确定相应协程用于执行哪个线程或多个线程。协程调度器可以将协程执行限制在特定线程中，将其分派到线程池，或者让它不确定地运行。</p>
<p>所有协程构建器（如 launch 和 async ）都接受可选的CoroutineContext参数，该参数可用于为新协程和其他上下文元素显式指定调度器。</p>
<p>尝试以下示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">launch &#123; <span class="comment">// context of the parent, main runBlocking coroutine</span></div><div class="line">    println(<span class="string">"main runBlocking      : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</div><div class="line">&#125;</div><div class="line">launch(Dispatchers.Unconfined) &#123; <span class="comment">// not confined -- will work with main thread</span></div><div class="line">    println(<span class="string">"Unconfined            : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</div><div class="line">&#125;</div><div class="line">launch(Dispatchers.Default) &#123; <span class="comment">// will get dispatched to DefaultDispatcher </span></div><div class="line">    println(<span class="string">"Default               : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</div><div class="line">&#125;</div><div class="line">launch(newSingleThreadContext(<span class="string">"MyOwnThread"</span>)) &#123; <span class="comment">// will get its own new thread</span></div><div class="line">    println(<span class="string">"newSingleThreadContext: I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出如下（可能以不同的顺序）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Unconfined            : I'm working in thread main</div><div class="line">Default               : I'm working in thread DefaultDispatcher-worker-1</div><div class="line">newSingleThreadContext: I'm working in thread MyOwnThread</div><div class="line">main runBlocking      : I'm working in thread main</div></pre></td></tr></table></figure>
<p>当不带参数使用 launch{…}时，它将从要启动的 CoroutineScope 继承上下文（并因此继承调度器）。在这种情况下，它继承了在主线程中运行的主 runBlocking 协程的上下文。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html" target="_blank" rel="external">Dispatchers.Unconfined</a> 是一种特殊的调度器，它似乎也运行在主线程中，但实际上，这是一种不同的机制，稍后将进行说明。</p>
<p>在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html" target="_blank" rel="external">GlobalScope</a> 中启动协程时使用的默认调度器由<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html" target="_blank" rel="external">Dispatchers.Default</a>表示，并使用共享的后台线程池，因此 launch（Dispatchers.Default）{…}与GlobalScope.launch {..使用相同的调度器。 }。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html" target="_blank" rel="external">newSingleThreadContext</a> 为协程创建一个线程来运行。专用线程是非常昂贵的资源。在实际的应用程序中，必须在不需要时使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-executor-coroutine-dispatcher/close.html" target="_blank" rel="external">close</a> 函数将其释放，或者将其存储在顶级变量中，然后在整个应用程序中重复使用。</p>
<h3 id="不确定与确定调度器"><a href="#不确定与确定调度器" class="headerlink" title="不确定与确定调度器"></a>不确定与确定调度器</h3><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html" target="_blank" rel="external">Dispatchers.Unconfined</a> 协程调度器在调用者线程中启动协程，但仅直到第一个挂起点为止。挂起后，它将在线程中恢复协程，该协程完全由调用的挂起函数确定。不确定调度器适用于既不占用CPU时间也不更新确定于特定线程的任何共享数据（如UI）的协程。</p>
<p>另一方面，默认情况下，调度器是从外部CoroutineScope继承的。特别是，runBlocking协程的默认调度器仅限于调用程序线程，因此继承它的作用是通过可预测的FIFO调度将执行限制在此线程中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">launch(Dispatchers.Unconfined) &#123; <span class="comment">// not confined -- will work with main thread</span></div><div class="line">    println(<span class="string">"Unconfined      : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</div><div class="line">    delay(<span class="number">500</span>)</div><div class="line">    println(<span class="string">"Unconfined      : After delay in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</div><div class="line">&#125;</div><div class="line">launch &#123; <span class="comment">// context of the parent, main runBlocking coroutine</span></div><div class="line">    println(<span class="string">"main runBlocking: I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</div><div class="line">    delay(<span class="number">1000</span>)</div><div class="line">    println(<span class="string">"main runBlocking: After delay in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Unconfined      : I'm working in thread main</div><div class="line">main runBlocking: I'm working in thread main</div><div class="line">Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor</div><div class="line">main runBlocking: After delay in thread main</div></pre></td></tr></table></figure>
<p>因此，具有从 <code>runBlocking {...}</code> 继承的上下文的协程将继续在主线程中执行，而不受约束的协程将在延迟函数使用的默认执行程序线程中继续执行。</p>
<p>不确定调度程序是一种高级机制，在某些情况下很有用，因为在这种情况下不需要协程进行分派以便以后执行，否则会产生不良的副作用，因为协程中的某些操作必须立即执行。不确定的调度程序不应在通用代码中使用。</p>
<h3 id="调试协程和线程"><a href="#调试协程和线程" class="headerlink" title="调试协程和线程"></a>调试协程和线程</h3><p>协程可以在一个线程上挂起，并在另一个线程上恢复。即使使用单线程调度程序，也可能很难弄清楚协程在做什么，在何时何地进行。使用线程调试应用程序的常用方法是在每个log语句的日志文件中打印线程名称。日志记录框架普遍支持此功能。当使用协程时，仅线程名不会提供太多上下文，因此 <code>kotlinx.coroutines</code> 包含调试工具以使其更容易。</p>
<p>使用 <code>-Dkotlinx.coroutines.debug</code> JVM选项运行以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.context03</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    <span class="keyword">val</span> a = async &#123;</div><div class="line">        log(<span class="string">"I'm computing a piece of the answer"</span>)</div><div class="line">        <span class="number">6</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">val</span> b = async &#123;</div><div class="line">        log(<span class="string">"I'm computing another piece of the answer"</span>)</div><div class="line">        <span class="number">7</span></div><div class="line">    &#125;</div><div class="line">    log(<span class="string">"The answer is <span class="subst">$&#123;a.await() * b.await()&#125;</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有三个协程。 runBlocking 内部的主要协程（＃1）和两个协程计算延迟值a（＃2）和b（＃3）。它们都在runBlocking上下文中执行，并且仅限于主线程。此代码的输出是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[main @coroutine#2] I'm computing a piece of the answer</div><div class="line">[main @coroutine#3] I'm computing another piece of the answer</div><div class="line">[main @coroutine#1] The answer is 42</div></pre></td></tr></table></figure>
<p>log函数将线程的名称打印在方括号中，可以看到它是主线程，并附加了当前正在执行的协程的标识符。调试模式打开时，此标识符将连续分配给所有创建的协程。</p>
<blockquote>
<p>当使用 <code>-ea</code> 选项运行JVM时，调试模式也会打开。您可以在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-d-e-b-u-g_-p-r-o-p-e-r-t-y_-n-a-m-e.html" target="_blank" rel="external">DEBUG_PROPERTY_NAME</a> 属性的文档中阅读有关调试功能的更多信息。</p>
</blockquote>
<h3 id="在线程之间跳转"><a href="#在线程之间跳转" class="headerlink" title="在线程之间跳转"></a>在线程之间跳转</h3><p>使用-Dkotlinx.coroutines.debug JVM选项运行以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package kotlinx.coroutines.guide.context04</div><div class="line"></div><div class="line">import kotlinx.coroutines.*</div><div class="line"></div><div class="line">fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)</div><div class="line"></div><div class="line">fun main() &#123;</div><div class="line">    newSingleThreadContext(&quot;Ctx1&quot;).use &#123; ctx1 -&gt;</div><div class="line">        newSingleThreadContext(&quot;Ctx2&quot;).use &#123; ctx2 -&gt;</div><div class="line">            runBlocking(ctx1) &#123;</div><div class="line">                log(&quot;Started in ctx1&quot;)</div><div class="line">                withContext(ctx2) &#123;</div><div class="line">                    log(&quot;Working in ctx2&quot;)</div><div class="line">                &#125;</div><div class="line">                log(&quot;Back to ctx1&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它演示了几种新技术。一种是在具有明确指定的上下文的情况下使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" target="_blank" rel="external">runBlocking</a>，另一种是使用 withContext 函数更改协程的上下文，同时仍保留在同一协程中，如下面的输出所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[Ctx1 @coroutine#1] Started in ctx1</div><div class="line">[Ctx2 @coroutine#1] Working in ctx2</div><div class="line">[Ctx1 @coroutine#1] Back to ctx1</div></pre></td></tr></table></figure>
<p>请注意，此示例还使用Kotlin标准库中的 <code>use</code> 函数，以在不再需要使用newSingleThreadContext创建的线程时释放它们。</p>
<h3 id="上下文中的-Job"><a href="#上下文中的-Job" class="headerlink" title="上下文中的 Job"></a>上下文中的 Job</h3><p>协程的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" target="_blank" rel="external">Job</a> 是其上下文的一部分，可以使用 <code>coroutineContext[Job]</code> 表达式从其检索：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.context05</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    println(<span class="string">"My job is <span class="subst">$&#123;coroutineContext[Job]&#125;</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<a href="https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html#debugging-coroutines-and-threads" target="_blank" rel="external">调试模式</a>下，它输出如下内容：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">My job <span class="keyword">is</span> <span class="string">"coroutine#1"</span>:BlockingCoroutine&#123;Active&#125;@<span class="number">6</span>d311334</div></pre></td></tr></table></figure>
<p>请注意，CoroutineScope中的 <a href="My job is &quot;coroutine#1&quot;:BlockingCoroutine{Active}@6d311334">isActive</a> 只是 <code>coroutineContext[Job]?.isActive == true</code> 的快捷方式。</p>
<h3 id="子协程"><a href="#子协程" class="headerlink" title="子协程"></a>子协程</h3><p>当协程在另一个协程的 CoroutineScope 中启动时，它会通过 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html" target="_blank" rel="external">CoroutineScope.coroutineContext</a>继承其上下文，新协程的Job成为父协程工作的子级。当父协程被取消时，其所有子进程也将被递归取消。</p>
<p>但是，当使用 GlobalScope 启动协程时，新协程的 Job 没有父项。因此，它不依赖于它的发布范围和独立运行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.context06</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    <span class="comment">// launch a coroutine to process some kind of incoming request</span></div><div class="line">    <span class="keyword">val</span> request = launch &#123;</div><div class="line">        <span class="comment">// it spawns two other jobs, one with GlobalScope</span></div><div class="line">        GlobalScope.launch &#123;</div><div class="line">            println(<span class="string">"job1: I run in GlobalScope and execute independently!"</span>)</div><div class="line">            delay(<span class="number">1000</span>)</div><div class="line">            println(<span class="string">"job1: I am not affected by cancellation of the request"</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// and the other inherits the parent context</span></div><div class="line">        launch &#123;</div><div class="line">            delay(<span class="number">100</span>)</div><div class="line">            println(<span class="string">"job2: I am a child of the request coroutine"</span>)</div><div class="line">            delay(<span class="number">1000</span>)</div><div class="line">            println(<span class="string">"job2: I will not execute this line if my parent request is cancelled"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    delay(<span class="number">500</span>)</div><div class="line">    request.cancel() <span class="comment">// cancel processing of the request</span></div><div class="line">    delay(<span class="number">1000</span>) <span class="comment">// delay a second to see what happens</span></div><div class="line">    println(<span class="string">"main: Who has survived request cancellation?"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此代码的输出是：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">job1: I run <span class="keyword">in</span> GlobalScope and execute independently!</div><div class="line">job2: I am a child of the request coroutine</div><div class="line">job1: I am not affected <span class="keyword">by</span> cancellation of the request</div><div class="line">main: Who has survived request cancellation?</div></pre></td></tr></table></figure></p>
<h3 id="父协程的责任"><a href="#父协程的责任" class="headerlink" title="父协程的责任"></a>父协程的责任</h3><p>父协程总是等待所有子进程完成。父级不必显式跟踪其启动的所有子级，也不必使用Job.join在末尾等待它们：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.context07</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    <span class="comment">// launch a coroutine to process some kind of incoming request</span></div><div class="line">    <span class="keyword">val</span> request = launch &#123;</div><div class="line">        repeat(<span class="number">3</span>) &#123; i -&gt; <span class="comment">// launch a few children jobs</span></div><div class="line">            launch  &#123;</div><div class="line">                delay((i + <span class="number">1</span>) * <span class="number">200</span>L) <span class="comment">// variable delay 200ms, 400ms, 600ms</span></div><div class="line">                println(<span class="string">"Coroutine <span class="variable">$i</span> is done"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        println(<span class="string">"request: I'm done and I don't explicitly join my children that are still active"</span>)</div><div class="line">    &#125;</div><div class="line">    request.join() <span class="comment">// wait for completion of the request, including all its children</span></div><div class="line">    println(<span class="string">"Now processing of the request is complete"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果将是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request: I<span class="string">'m done and I don'</span>t explicitly join my children that are still active</div><div class="line">Coroutine <span class="number">0</span> <span class="keyword">is</span> done</div><div class="line">Coroutine <span class="number">1</span> <span class="keyword">is</span> done</div><div class="line">Coroutine <span class="number">2</span> <span class="keyword">is</span> done</div><div class="line">Now processing of the request <span class="keyword">is</span> complete</div></pre></td></tr></table></figure>
<h3 id="命名协程以进行调试"><a href="#命名协程以进行调试" class="headerlink" title="命名协程以进行调试"></a>命名协程以进行调试</h3><p>当协程经常记录日志时，自动分配的ID是很好的方式，你只需要关联来自同一协程的日志记录。但是，当协程与特定请求的处理或执行某些特定的后台任务相关时，最好为调试目的明确命名它。 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/index.html" target="_blank" rel="external">CoroutineName</a> 上下文元素的作用与线程名称相同。当打开<a href="https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html#debugging-coroutines-and-threads" target="_blank" rel="external">调试模式</a>时，它包含在执行此协程的线程名称中。</p>
<p>下面的示例演示了此概念：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.context08</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(CoroutineName(<span class="string">"main"</span>)) &#123;</div><div class="line">    log(<span class="string">"Started main coroutine"</span>)</div><div class="line">    <span class="comment">// run two background value computations</span></div><div class="line">    <span class="keyword">val</span> v1 = async(CoroutineName(<span class="string">"v1coroutine"</span>)) &#123;</div><div class="line">        delay(<span class="number">500</span>)</div><div class="line">        log(<span class="string">"Computing v1"</span>)</div><div class="line">        <span class="number">252</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">val</span> v2 = async(CoroutineName(<span class="string">"v2coroutine"</span>)) &#123;</div><div class="line">        delay(<span class="number">1000</span>)</div><div class="line">        log(<span class="string">"Computing v2"</span>)</div><div class="line">        <span class="number">6</span></div><div class="line">    &#125;</div><div class="line">    log(<span class="string">"The answer for v1 / v2 = <span class="subst">$&#123;v1.await() / v2.await()&#125;</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用-Dkotlinx.coroutines.debug JVM选项生成的输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[main @main#1] Started main coroutine</div><div class="line">[main @v1coroutine#2] Computing v1</div><div class="line">[main @v2coroutine#3] Computing v2</div><div class="line">[main @main#1] The answer for v1 / v2 = 42</div></pre></td></tr></table></figure>
<h3 id="结合上下文元素"><a href="#结合上下文元素" class="headerlink" title="结合上下文元素"></a>结合上下文元素</h3><p>有时我们需要为协程环境定义多个元素。我们可以使用<code>+</code>运算符。例如，我们可以同时使用指定的调度器和指定的名称启动协程：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.context09</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    launch(Dispatchers.Default + CoroutineName(<span class="string">"test"</span>)) &#123;</div><div class="line">        println(<span class="string">"I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用-Dkotlinx.coroutines.debug JVM选项生成的输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I'm working in thread DefaultDispatcher-worker-1 @test#2</div></pre></td></tr></table></figure>
<h3 id="协程作用域"><a href="#协程作用域" class="headerlink" title="协程作用域"></a>协程作用域</h3><p>让我们将有关上下文，子协程和 Job 的知识放在一起。假设我们的应用程序有一个具有生命周期的对象，但是该对象不是协程。例如，我们正在编写一个Android应用程序，并在一个 Activity 的上下文中启动各种协程，以执行异步操作来获取和更新数据，制作动画等。在销毁该 Activity 时，必须取消所有这些协程以避免内存泄漏。当然，我们可以手动操作上下文和作业以绑定Activity及其协程的生命周期，但是kotlinx.coroutines提供了一个封装以下内容的抽象: <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" target="_blank" rel="external">CoroutineScope</a> 。你应该已经熟悉了协程作用域，因为所有协程构建器都被声明为它的扩展。</p>
<p>我们通过创建与Activity的生命周期相关联的CoroutineScope实例来管理协程的生命周期。可以通过 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html" target="_blank" rel="external">CoroutineScope()</a> 或 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html" target="_blank" rel="external">MainScope()</a>工厂函数创建CoroutineScope实例。前者创建通用作用域，而后者创建UI应用程序的作用域，并使用 Dispatchers.Main 作为默认调度器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mainScope = MainScope()</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</div><div class="line">        mainScope.cancel()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// to be continued ...</span></div></pre></td></tr></table></figure>
<p>另外，我们可以在Activity类中实现CoroutineScope接口。最好的方法是将委托与默认的工厂功能一起使用。我们还可以将所需的调度器（在此示例中使用Dispatchers.Default）与作用域相结合:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> : <span class="type">CoroutineScope by CoroutineScope</span></span>(Dispatchers.Default) &#123;</div><div class="line">    <span class="comment">// to be continued ...</span></div></pre></td></tr></table></figure>
<p>现在，我们可以在此Activity的范围内启动协程，而不必显式指定它们的上下文。为了演示，我们启动了十个协程，它们会在不同的时间延迟：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// class Activity continues</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// launch ten coroutines for a demo, each working for a different time</span></div><div class="line">        repeat(<span class="number">10</span>) &#123; i -&gt;</div><div class="line">            launch &#123;</div><div class="line">                delay((i + <span class="number">1</span>) * <span class="number">200</span>L) <span class="comment">// variable delay 200ms, 400ms, ... etc</span></div><div class="line">                println(<span class="string">"Coroutine <span class="variable">$i</span> is done"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="comment">// class Activity ends</span></div></pre></td></tr></table></figure>
<p>在我们的主函数中，我们创建 Activity ，调用测试doSomething函数，并在500毫秒后销毁。这将取消从doSomething启动的所有协程。我们可以看到，因为在Activity被破坏后，即使等待了更长的时间，也不会再打印任何消息。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.context10</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlin.coroutines.*</div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> : <span class="type">CoroutineScope by CoroutineScope</span></span>(Dispatchers.Default) &#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</div><div class="line">        cancel() <span class="comment">// Extension on CoroutineScope</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// to be continued ...</span></div><div class="line"></div><div class="line">    <span class="comment">// class Activity continues</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// launch ten coroutines for a demo, each working for a different time</span></div><div class="line">        repeat(<span class="number">10</span>) &#123; i -&gt;</div><div class="line">            launch &#123;</div><div class="line">                delay((i + <span class="number">1</span>) * <span class="number">200</span>L) <span class="comment">// variable delay 200ms, 400ms, ... etc</span></div><div class="line">                println(<span class="string">"Coroutine <span class="variable">$i</span> is done"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="comment">// class Activity ends</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    <span class="keyword">val</span> activity = Activity()</div><div class="line">    activity.doSomething() <span class="comment">// run test function</span></div><div class="line">    println(<span class="string">"Launched coroutines"</span>)</div><div class="line">    delay(<span class="number">500</span>L) <span class="comment">// delay for half a second</span></div><div class="line">    println(<span class="string">"Destroying activity!"</span>)</div><div class="line">    activity.destroy() <span class="comment">// cancels all coroutines</span></div><div class="line">    delay(<span class="number">1000</span>) <span class="comment">// visually confir</span></div></pre></td></tr></table></figure>
<p>该示例的输出为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Launched coroutines</div><div class="line">Coroutine <span class="number">0</span> <span class="keyword">is</span> done</div><div class="line">Coroutine <span class="number">1</span> <span class="keyword">is</span> done</div><div class="line">Destroying activity!</div></pre></td></tr></table></figure>
<p>如你所见，只有前两个协程打印一条消息，而其他两个在Activity.destroy（）中的一次job.cancel（）调用中被取消。</p>
<h3 id="Thradd-local数据"><a href="#Thradd-local数据" class="headerlink" title="Thradd-local数据"></a>Thradd-local数据</h3><p>有时，能够将一些线程局部数据传递到协程或在协程之间很方便。但是，由于它们未绑定到任何特定线程，因此如果手动完成，则可能会导致模板式代码。</p>
<p>对于 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html" target="_blank" rel="external">ThreadLocal</a> ，此处提供了 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/as-context-element.html" target="_blank" rel="external">asContextElement</a> 扩展函数以进行恢复。它创建一个额外的context元素，该元素保留给定ThreadLocal，并在协程每次切换其上下文时将其恢复。</p>
<p>请看下面演示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kotlinx.coroutines.guide.context11</div><div class="line"></div><div class="line"><span class="keyword">import</span> kotlinx.coroutines.*</div><div class="line"></div><div class="line"><span class="keyword">val</span> threadLocal = ThreadLocal&lt;String?&gt;() <span class="comment">// declare thread-local variable</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</div><div class="line">    threadLocal.<span class="keyword">set</span>(<span class="string">"main"</span>)</div><div class="line">    println(<span class="string">"Pre-main, current thread: <span class="subst">$&#123;Thread.currentThread()&#125;</span>, thread local value: '<span class="subst">$&#123;threadLocal.get()&#125;</span>'"</span>)</div><div class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default + threadLocal.asContextElement(value = <span class="string">"launch"</span>)) &#123;</div><div class="line">        println(<span class="string">"Launch start, current thread: <span class="subst">$&#123;Thread.currentThread()&#125;</span>, thread local value: '<span class="subst">$&#123;threadLocal.get()&#125;</span>'"</span>)</div><div class="line">        yield()</div><div class="line">        println(<span class="string">"After yield, current thread: <span class="subst">$&#123;Thread.currentThread()&#125;</span>, thread local value: '<span class="subst">$&#123;threadLocal.get()&#125;</span>'"</span>)</div><div class="line">    &#125;</div><div class="line">    job.join()</div><div class="line">    println(<span class="string">"Post-main, current thread: <span class="subst">$&#123;Thread.currentThread()&#125;</span>, thread local value: '<span class="subst">$&#123;threadLocal.get()&#125;</span>'"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在此示例中，我们使用Dispatchers.Default在后台线程池中启动了一个新协程，因此它在与线程池不同的线程上工作，但是它仍然具有我们使用 <code>threadLocal.asContextElement(value = &quot;launch&quot;)</code>，无论协程在哪个线程上执行。 因此，输出（带有调试）为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Pre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'</div><div class="line">Launch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: 'launch'</div><div class="line">After yield, current thread: Thread[DefaultDispatcher-worker-2 @coroutine#2,5,main], thread local value: 'launch'</div><div class="line">Post-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'</div></pre></td></tr></table></figure>
<p>很容易忘记设置相应的上下文元素。如果运行协程的线程不同，则从协程访问的线程局部变量可能会具有非期待值。为避免此类情况，建议使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html" target="_blank" rel="external">ensurePresent</a> 方法，并在使用不当时进行快速失败。</p>
<p>ThreadLocal 具有顶级的支持，可与任何原始 kotlinx.coroutines 一起使用。但是，它有一个关键限制：当对线程局部变量进行更改时，不会将新值传播到协程调用者（因为上下文元素无法跟踪所有ThreadLocal对象访问），并且在下一次挂起时更新的值会丢失。使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html" target="_blank" rel="external">withContext</a> 更新协程中 Thread-local 的值，有关更多详细信息，请参见 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/as-context-element.html" target="_blank" rel="external">asContextElement</a></p>
<p>同样，可以将值存储在可变类如 <code>class Counter(var i: Int)</code> 中，然后将其存储在线程局部变量中。但是，在这种情况下，你有责任将可能并发的修改同步到此可变的变量中。</p>
<p>对于高级用法，例如与日志记录MDC，事务上下文或内部使用线程本地传递数据的任何其他库的集成，请参阅 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-thread-context-element/index.html" target="_blank" rel="external">ThreadContextElement</a> 接口应实现的文档。</p>

        
      </div>
      
      
      
    </div>
    
    
    
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars0.githubusercontent.com/u/15133565?s=460&v=4"
                alt="LeBron_Six" />
            
              <p class="site-author-name" itemprop="name">LeBron_Six</p>
              <p class="site-description motion-element" itemprop="description">欢迎访问我的博客~</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/smuyyh" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:smuyyh@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#协程上下文和调度器"><span class="nav-number">1.</span> <span class="nav-text">协程上下文和调度器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调度器和线程"><span class="nav-number">1.1.</span> <span class="nav-text">调度器和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不确定与确定调度器"><span class="nav-number">1.2.</span> <span class="nav-text">不确定与确定调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调试协程和线程"><span class="nav-number">1.3.</span> <span class="nav-text">调试协程和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在线程之间跳转"><span class="nav-number">1.4.</span> <span class="nav-text">在线程之间跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文中的-Job"><span class="nav-number">1.5.</span> <span class="nav-text">上下文中的 Job</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子协程"><span class="nav-number">1.6.</span> <span class="nav-text">子协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#父协程的责任"><span class="nav-number">1.7.</span> <span class="nav-text">父协程的责任</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名协程以进行调试"><span class="nav-number">1.8.</span> <span class="nav-text">命名协程以进行调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结合上下文元素"><span class="nav-number">1.9.</span> <span class="nav-text">结合上下文元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程作用域"><span class="nav-number">1.10.</span> <span class="nav-text">协程作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thradd-local数据"><span class="nav-number">1.11.</span> <span class="nav-text">Thradd-local数据</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"><a href="https://github.com/smuyyh" target="_blank">LeBron_Six</a></span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://www.wenjunjiang.win/css/gitment.css">
        <script src="https://www.wenjunjiang.win/js/gitment.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitment({
            id: window.location.pathname, 
            owner: 'smuyyh',
            repo: 'smuyyh.github.io',
            
            oauth: {
            
            
                client_secret: '774c6e487b59087f22aea6b51bbbd69e2ef0a5c2',
            
                client_id: '0a452de0f03398d1ea74'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  





  

  

  

  
  

  

  

  

</body>
</html>
